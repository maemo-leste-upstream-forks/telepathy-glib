<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="telepathy-glib-channel-dispatch-operation">
<refmeta>
<refentrytitle role="top_of_page" id="telepathy-glib-channel-dispatch-operation.top_of_page">TpChannelDispatchOperation</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>TpChannelDispatchOperation</refname>
<refpurpose>proxy object for a to the Telepathy channel
 dispatcher</refpurpose>
</refnamediv>

<refsynopsisdiv id="telepathy-glib-channel-dispatch-operation.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>
<anchor id="TpChannelDispatchOperation"/>
<synopsis>

#include &lt;telepathy-glib/channel-dispatch-operation.h&gt;

struct              <link linkend="TpChannelDispatchOperation-struct">TpChannelDispatchOperation</link>;
struct              <link linkend="TpChannelDispatchOperationClass">TpChannelDispatchOperationClass</link>;
<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> * <link linkend="tp-channel-dispatch-operation-new">tp_channel_dispatch_operation_new</link>
                                                        (<link linkend="TpDBusDaemon">TpDBusDaemon</link> *bus_daemon,
                                                         const <link linkend="gchar">gchar</link> *object_path,
                                                         <link linkend="GHashTable">GHashTable</link> *immutable_properties,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                <link linkend="tp-channel-dispatch-operation-init-known-interfaces">tp_channel_dispatch_operation_init_known_interfaces</link>
                                                        (void);

<link linkend="void">void</link>                (<link linkend="tp-cli-channel-dispatch-operation-callback-for-claim">*tp_cli_channel_dispatch_operation_callback_for_claim</link>)
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-dispatch-operation-call-claim">tp_cli_channel_dispatch_operation_call_claim</link>
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-dispatch-operation-callback-for-claim">tp_cli_channel_dispatch_operation_callback_for_claim</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-dispatch-operation-callback-for-handle-with">*tp_cli_channel_dispatch_operation_callback_for_handle_with</link>)
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-dispatch-operation-call-handle-with">tp_cli_channel_dispatch_operation_call_handle_with</link>
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         const <link linkend="gchar">gchar</link> *in_Handler,
                                                         <link linkend="tp-cli-channel-dispatch-operation-callback-for-handle-with">tp_cli_channel_dispatch_operation_callback_for_handle_with</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-dispatch-operation-signal-callback-channel-lost">*tp_cli_channel_dispatch_operation_signal_callback_channel_lost</link>)
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         const <link linkend="gchar">gchar</link> *arg_Channel,
                                                         const <link linkend="gchar">gchar</link> *arg_Error,
                                                         const <link linkend="gchar">gchar</link> *arg_Message,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-dispatch-operation-connect-to-channel-lost">tp_cli_channel_dispatch_operation_connect_to_channel_lost</link>
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="tp-cli-channel-dispatch-operation-signal-callback-channel-lost">tp_cli_channel_dispatch_operation_signal_callback_channel_lost</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-dispatch-operation-signal-callback-finished">*tp_cli_channel_dispatch_operation_signal_callback_finished</link>)
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-dispatch-operation-connect-to-finished">tp_cli_channel_dispatch_operation_connect_to_finished</link>
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="tp-cli-channel-dispatch-operation-signal-callback-finished">tp_cli_channel_dispatch_operation_signal_callback_finished</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
</synopsis>
</refsynopsisdiv>

<refsect1 id="telepathy-glib-channel-dispatch-operation.object-hierarchy" role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<synopsis>
  <link linkend="GObject">GObject</link>
   +----<link linkend="TpProxy">TpProxy</link>
         +----TpChannelDispatchOperation
</synopsis>
</refsect1>








<refsect1 id="telepathy-glib-channel-dispatch-operation.description" role="desc">
<title role="desc.title">Description</title>
<para>
One of the channel dispatcher's functions is to offer incoming channels to
Approver clients for approval. Approvers respond to the channel dispatcher
via a <link linkend="TpChannelDispatchOperation"><type>TpChannelDispatchOperation</type></link> object.</para>
<para>
</para>
</refsect1>

<refsect1 id="telepathy-glib-channel-dispatch-operation.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="TpChannelDispatchOperation-struct" role="struct">
<title>struct TpChannelDispatchOperation</title>
<indexterm zone="TpChannelDispatchOperation-struct" role="0.7.32"><primary sortas="TpChannelDispatchOperation">TpChannelDispatchOperation</primary></indexterm><programlisting>struct TpChannelDispatchOperation;</programlisting>
<para>
One of the channel dispatcher's functions is to offer incoming channels to
Approver clients for approval. An approver should generally ask the user
whether they want to participate in the requested communication channels
(join the chat or chatroom, answer the call, accept the file transfer, or
whatever is appropriate). A collection of channels offered in this way
is represented by a ChannelDispatchOperation object.
</para>
<para>
If the user wishes to accept the communication channels, the approver
should call <link linkend="tp-cli-channel-dispatch-operation-call-handle-with"><function>tp_cli_channel_dispatch_operation_call_handle_with()</function></link> to
indicate the user's or approver's preferred handler for the channels (the
empty string indicates no particular preference, and will cause any
suitable handler to be used).
</para>
<para>
If the user wishes to reject the communication channels, or if the user
accepts the channels and the approver will handle them itself, the approver
should call <link linkend="tp-cli-channel-dispatch-operation-call-claim"><function>tp_cli_channel_dispatch_operation_call_claim()</function></link>. If this method
succeeds, the approver immediately has control over the channels as their
primary handler, and may do anything with them (in particular, it may close
them in whatever way seems most appropriate).
</para>
<para>
There are various situations in which the channel dispatch operation will
be closed, causing the <link linkend="TpProxy-invalidated"><type>"invalidated"</type></link> signal to be emitted. If this
happens, the approver should stop prompting the user.
</para>
<para>
Because all approvers are launched simultaneously, the user might respond
to another approver; if this happens, the invalidated signal will be
emitted with the domain <link linkend="TP-DBUS-ERRORS--CAPS"><literal>TP_DBUS_ERRORS</literal></link> and the error code
<link linkend="TP-DBUS-ERROR-OBJECT-REMOVED--CAPS"><literal>TP_DBUS_ERROR_OBJECT_REMOVED</literal></link>.
</para>
<para>
If a channel closes, the D-Bus signal ChannelLost is emitted; this class
doesn't (yet) have a GObject binding for this signal, but you can use
<link linkend="tp-cli-channel-dispatch-operation-connect-to-channel-lost"><function>tp_cli_channel_dispatch_operation_connect_to_channel_lost()</function></link>. If all channels
close, there is nothing more to dispatch, so the invalidated signal will be
emitted with the domain <link linkend="TP-DBUS-ERRORS--CAPS"><literal>TP_DBUS_ERRORS</literal></link> and the error code
<link linkend="TP-DBUS-ERROR-OBJECT-REMOVED--CAPS"><literal>TP_DBUS_ERROR_OBJECT_REMOVED</literal></link>.
</para>
<para>
If the channel dispatcher crashes or exits, the invalidated
signal will be emitted with the domain <link linkend="TP-DBUS-ERRORS--CAPS"><literal>TP_DBUS_ERRORS</literal></link> and the error code
<link linkend="TP-DBUS-ERROR-NAME-OWNER-LOST--CAPS"><literal>TP_DBUS_ERROR_NAME_OWNER_LOST</literal></link>. In a high-quality implementation, the
dispatcher should be restarted, at which point it will create new
channel dispatch operations for any undispatched channels, and the approver
will be notified again.
</para>
<para>
This proxy is usable but incomplete: accessors for the D-Bus properties will
be added in a later version of telepathy-glib, along with a mechanism
similar to <link linkend="tp-connection-call-when-ready"><function>tp_connection_call_when_ready()</function></link>.</para>
<para>
</para><para role="since">Since 0.7.32</para></refsect2>
<refsect2 id="TpChannelDispatchOperationClass" role="struct">
<title>struct TpChannelDispatchOperationClass</title>
<indexterm zone="TpChannelDispatchOperationClass"><primary sortas="TpChannelDispatchOperationClass">TpChannelDispatchOperationClass</primary></indexterm><programlisting>struct TpChannelDispatchOperationClass {
};
</programlisting>
<para>
The class of a <link linkend="TpChannelDispatchOperation"><type>TpChannelDispatchOperation</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="tp-channel-dispatch-operation-new" role="function">
<title>tp_channel_dispatch_operation_new ()</title>
<indexterm zone="tp-channel-dispatch-operation-new"><primary sortas="tp_channel_dispatch_operation_new">tp_channel_dispatch_operation_new</primary></indexterm><programlisting><link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> * tp_channel_dispatch_operation_new
                                                        (<link linkend="TpDBusDaemon">TpDBusDaemon</link> *bus_daemon,
                                                         const <link linkend="gchar">gchar</link> *object_path,
                                                         <link linkend="GHashTable">GHashTable</link> *immutable_properties,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Convenience function to create a new channel dispatch operation proxy.
</para>
<para>
The <parameter>immutable_properties</parameter> argument is not yet used.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>bus_daemon</parameter>&#160;:</term>
<listitem><simpara> Proxy for the D-Bus daemon
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>object_path</parameter>&#160;:</term>
<listitem><simpara> The non-NULL object path of this channel dispatch operation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>immutable_properties</parameter>&#160;:</term>
<listitem><simpara> As many as are known of the immutable D-Bus
 properties of this channel dispatch operation, or <link linkend="NULL--CAPS"><literal>NULL</literal></link> if none are known
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> Used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a new reference to an channel dispatch operation proxy, or <link linkend="NULL--CAPS"><literal>NULL</literal></link> if
   <parameter>object_path</parameter> is not syntactically valid or the channel dispatcher is not
   running
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-channel-dispatch-operation-init-known-interfaces" role="function" condition="since:0.7.32">
<title>tp_channel_dispatch_operation_init_known_interfaces ()</title>
<indexterm zone="tp-channel-dispatch-operation-init-known-interfaces" role="0.7.32"><primary sortas="tp_channel_dispatch_operation_init_known_interfaces">tp_channel_dispatch_operation_init_known_interfaces</primary></indexterm><programlisting><link linkend="void">void</link>                tp_channel_dispatch_operation_init_known_interfaces
                                                        (void);</programlisting>
<para>
Ensure that the known interfaces for TpChannelDispatchOperation have been
set up. This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
<link linkend="tp-proxy-or-subclass-hook-on-interface-add"><function>tp_proxy_or_subclass_hook_on_interface_add()</function></link> with first argument
<link linkend="TP-TYPE-CHANNEL-DISPATCH-OPERATION--CAPS"><literal>TP_TYPE_CHANNEL_DISPATCH_OPERATION</literal></link>.</para>
<para>
</para><para role="since">Since 0.7.32</para></refsect2>
<refsect2 id="tp-cli-channel-dispatch-operation-callback-for-claim" role="function">
<title>tp_cli_channel_dispatch_operation_callback_for_claim ()</title>
<indexterm zone="tp-cli-channel-dispatch-operation-callback-for-claim"><primary sortas="tp_cli_channel_dispatch_operation_callback_for_claim">tp_cli_channel_dispatch_operation_callback_for_claim</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_dispatch_operation_callback_for_claim)
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a Claim method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-dispatch-operation-call-claim" role="function">
<title>tp_cli_channel_dispatch_operation_call_claim ()</title>
<indexterm zone="tp-cli-channel-dispatch-operation-call-claim"><primary sortas="tp_cli_channel_dispatch_operation_call_claim">tp_cli_channel_dispatch_operation_call_claim</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_dispatch_operation_call_claim
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-dispatch-operation-callback-for-claim">tp_cli_channel_dispatch_operation_callback_for_claim</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a Claim method call.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Called by an approver to claim channels for handling           internally. If this method is called successfully, the process           calling this method becomes the handler for the channel, but           &lt;em&gt;does not&lt;/em&gt; have the &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Client.Handler&quot;&gt;HandleChannels&lt;/tp:dbus-ref&gt;           method called on it.&lt;/p&gt;          &lt;p&gt;Clients that call Claim on channels but do not immediately           close them SHOULD implement the Handler interface and its           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Client.Handler&quot;&gt;HandledChannels&lt;/tp:dbus-ref&gt;           property.&lt;/p&gt;          &lt;p&gt;Approvers wishing to reject channels MUST call this method to           claim ownership of them, and MUST NOT call           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Channel&quot;&gt;Close&lt;/tp:dbus-ref&gt;           on the channels unless/until this method returns successfully.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;The channel dispatcher can&apos;t know how best to close arbitrary             channel types, so it leaves it up to the approver to do so.             For instance, for Text channels it is necessary             to acknowledge any messages that have already been displayed to             the user first - ideally, the approver would display and then             acknowledge the messages - or to call &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy&quot;&gt;Channel.Interface.Destroyable.Destroy&lt;/tp:dbus-ref&gt;             if the destructive behaviour of that method is desired.&lt;/p&gt;            &lt;p&gt;Similarly, an Approver for StreamedMedia channels can close the             channel with a reason (e.g. &amp;quot;busy&amp;quot;) if desired. The channel             dispatcher, which is designed to have no specific knowledge             of particular channel types, can&apos;t do that.&lt;/p&gt;         &lt;/tp:rationale&gt;          &lt;p&gt;If successful, this method will cause the ChannelDispatchOperation           object to disappear, emitting           &lt;tp:member-ref&gt;Finished&lt;/tp:member-ref&gt;, in the same way as for           &lt;tp:member-ref&gt;HandleWith&lt;/tp:member-ref&gt;.&lt;/p&gt;          &lt;p&gt;This method may fail because the dispatch operation has already           been completed. Again, see HandleWith for more details. The approver           MUST NOT attempt to interact with the channels further in this           case.&lt;/p&gt;          &lt;p&gt;(FIXME: list some other possible errors)&lt;/p&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-dispatch-operation-callback-for-handle-with" role="function">
<title>tp_cli_channel_dispatch_operation_callback_for_handle_with ()</title>
<indexterm zone="tp-cli-channel-dispatch-operation-callback-for-handle-with"><primary sortas="tp_cli_channel_dispatch_operation_callback_for_handle_with">tp_cli_channel_dispatch_operation_callback_for_handle_with</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_dispatch_operation_callback_for_handle_with)
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a HandleWith method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-dispatch-operation-call-handle-with" role="function">
<title>tp_cli_channel_dispatch_operation_call_handle_with ()</title>
<indexterm zone="tp-cli-channel-dispatch-operation-call-handle-with"><primary sortas="tp_cli_channel_dispatch_operation_call_handle_with">tp_cli_channel_dispatch_operation_call_handle_with</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_dispatch_operation_call_handle_with
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         const <link linkend="gchar">gchar</link> *in_Handler,
                                                         <link linkend="tp-cli-channel-dispatch-operation-callback-for-handle-with">tp_cli_channel_dispatch_operation_callback_for_handle_with</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a HandleWith method call.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Called by an approver to accept a channel bundle and request that           the given handler be used to handle it.&lt;/p&gt;          &lt;p&gt;If successful, this method will cause the ChannelDispatchOperation           object to disappear, emitting           &lt;tp:member-ref&gt;Finished&lt;/tp:member-ref&gt;.&lt;/p&gt;          &lt;p&gt;However, this method may fail because the dispatch has already been           completed and the object has already gone. If this occurs, it           indicates that another approver has asked for the bundle to be           handled by a particular handler. The approver MUST NOT attempt           to interact with the channels further in this case, unless it is           separately invoked as the handler.&lt;/p&gt;          &lt;p&gt;Approvers which are also channel handlers SHOULD use           &lt;tp:member-ref&gt;Claim&lt;/tp:member-ref&gt; instead           of HandleWith to request that they can handle a channel bundle           themselves.&lt;/p&gt;          &lt;p&gt;(FIXME: list some possible errors)&lt;/p&gt;          &lt;p&gt;If the channel handler raises an error from &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Client.Handler&quot;&gt;HandleChannels&lt;/tp:dbus-ref&gt;,           this method           MAY respond by raising that same error, even if it is not           specifically documented here.&lt;/p&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Handler</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: &lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;           &lt;p&gt;The well-known bus name (starting with             &lt;code&gt;org.freedesktop.Telepathy.Client.&lt;/code&gt;) of the channel             handler that should handle the channel, or the empty string             if the client has no preferred channel handler.&lt;/p&gt;
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-dispatch-operation-signal-callback-channel-lost" role="function">
<title>tp_cli_channel_dispatch_operation_signal_callback_channel_lost ()</title>
<indexterm zone="tp-cli-channel-dispatch-operation-signal-callback-channel-lost"><primary sortas="tp_cli_channel_dispatch_operation_signal_callback_channel_lost">tp_cli_channel_dispatch_operation_signal_callback_channel_lost</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_dispatch_operation_signal_callback_channel_lost)
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         const <link linkend="gchar">gchar</link> *arg_Channel,
                                                         const <link linkend="gchar">gchar</link> *arg_Error,
                                                         const <link linkend="gchar">gchar</link> *arg_Message,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal ChannelLost.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-dispatch-operation-connect-to-channel-lost"><function>tp_cli_channel_dispatch_operation_connect_to_channel_lost()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Channel</parameter>&#160;:</term>
<listitem><simpara> The &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy&quot;&gt;Channel&lt;/tp:dbus-ref&gt;           that closed.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Error</parameter>&#160;:</term>
<listitem><simpara> &lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;           &lt;p&gt;The name of a D-Bus error indicating why the channel closed. If             no better reason can be found,             &lt;code&gt;org.freedesktop.Telepathy.Error.NotAvailable&lt;/code&gt; MAY             be used as a fallback; this means that this error SHOULD NOT be             given any more specific meaning.&lt;/p&gt;
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Message</parameter>&#160;:</term>
<listitem><simpara> A string associated with the D-Bus error.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-dispatch-operation-connect-to-channel-lost" role="function">
<title>tp_cli_channel_dispatch_operation_connect_to_channel_lost ()</title>
<indexterm zone="tp-cli-channel-dispatch-operation-connect-to-channel-lost"><primary sortas="tp_cli_channel_dispatch_operation_connect_to_channel_lost">tp_cli_channel_dispatch_operation_connect_to_channel_lost</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_dispatch_operation_connect_to_channel_lost
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="tp-cli-channel-dispatch-operation-signal-callback-channel-lost">tp_cli_channel_dispatch_operation_signal_callback_channel_lost</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal ChannelLost.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;A channel has closed before it could be claimed or handled. If           this is emitted for the last remaining channel in a channel           dispatch operation, it MUST immediately be followed by           &lt;tp:member-ref&gt;Finished&lt;/tp:member-ref&gt;.&lt;/p&gt;          &lt;p&gt;This signal MUST NOT be emitted until all Approvers that were           invoked have returned (successfully or with an error) from           their &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Client.Approver&quot;&gt;AddDispatchOperation&lt;/tp:dbus-ref&gt;           method.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;This means that Approvers can connect to the ChannelLost signal             in a race-free way. Non-approver processes that discover             a channel dispatch operation in some way (such as observers)             will have to follow the usual &amp;quot;connect to signals then recover             state&amp;quot; model - first connect to ChannelLost and             &lt;tp:member-ref&gt;Finished&lt;/tp:member-ref&gt;,             then download &lt;tp:member-ref&gt;Channels&lt;/tp:member-ref&gt; (and             on error, perhaps assume that the operation has already             Finished).&lt;/p&gt;         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannelDispatchOperation"><type>TpChannelDispatchOperation</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-dispatch-operation-signal-callback-finished" role="function">
<title>tp_cli_channel_dispatch_operation_signal_callback_finished ()</title>
<indexterm zone="tp-cli-channel-dispatch-operation-signal-callback-finished"><primary sortas="tp_cli_channel_dispatch_operation_signal_callback_finished">tp_cli_channel_dispatch_operation_signal_callback_finished</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_dispatch_operation_signal_callback_finished)
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal Finished.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-dispatch-operation-connect-to-finished"><function>tp_cli_channel_dispatch_operation_connect_to_finished()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-dispatch-operation-connect-to-finished" role="function">
<title>tp_cli_channel_dispatch_operation_connect_to_finished ()</title>
<indexterm zone="tp-cli-channel-dispatch-operation-connect-to-finished"><primary sortas="tp_cli_channel_dispatch_operation_connect_to_finished">tp_cli_channel_dispatch_operation_connect_to_finished</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_dispatch_operation_connect_to_finished
                                                        (<link linkend="TpChannelDispatchOperation">TpChannelDispatchOperation</link> *proxy,
                                                         <link linkend="tp-cli-channel-dispatch-operation-signal-callback-finished">tp_cli_channel_dispatch_operation_signal_callback_finished</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal Finished.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Emitted when this dispatch operation finishes. The dispatch           operation is no longer present and further methods must not be           called on it.&lt;/p&gt;          &lt;p&gt;Approvers that have a user interface SHOULD stop notifying the user           about the channels in response to this signal; they MAY assume that           on errors, they would have received           &lt;tp:member-ref&gt;ChannelLost&lt;/tp:member-ref&gt; first.&lt;/p&gt;          &lt;p&gt;Its object path SHOULD NOT be reused for a subsequent dispatch           operation; the ChannelDispatcher MUST choose object paths           in a way that avoids immediate re-use.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;Otherwise, clients might accidentally call             &lt;tp:member-ref&gt;HandleWith&lt;/tp:member-ref&gt; or             &lt;tp:member-ref&gt;Claim&lt;/tp:member-ref&gt; on a new dispatch operation             instead of the one they intended to handle.&lt;/p&gt;         &lt;/tp:rationale&gt;          &lt;p&gt;This signal MUST NOT be emitted until all Approvers that were           invoked have returned (successfully or with an error) from           their &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Client.Approver&quot;&gt;AddDispatchOperation&lt;/tp:dbus-ref&gt;           method.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;This means that Approvers can connect to the ChannelLost signal             in a race-free way. Non-approver processes that discover             a channel dispatch operation in some way (such as observers)             will have to follow the usual &amp;quot;connect to signals then recover             state&amp;quot; model - first connect to             &lt;tp:member-ref&gt;ChannelLost&lt;/tp:member-ref&gt; and             Finished, then download &lt;tp:member-ref&gt;Channels&lt;/tp:member-ref&gt;             (and on error, perhaps assume that the operation has already             Finished).&lt;/p&gt;         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannelDispatchOperation"><type>TpChannelDispatchOperation</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>



<refsect1 id="telepathy-glib-channel-dispatch-operation.see-also">
<title>See Also</title>
#TpChannelDispatcher
</refsect1>

</refentry>
