<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="telepathy-glib-proxy-subclass">
<refmeta>
<refentrytitle role="top_of_page">TpProxy subclasses and mixins</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>TpProxy subclasses and mixins</refname>
<refpurpose>Providing extra functionality for a <link linkend="TpProxy"><type>TpProxy</type></link> or
 subclass, or subclassing it</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;telepathy-glib/proxy-subclass.h&gt;


<link linkend="DBusGProxy">DBusGProxy</link>*         <link linkend="tp-proxy-add-interface-by-id">tp_proxy_add_interface_by_id</link>        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> interface);
<link linkend="DBusGProxy">DBusGProxy</link>*         <link linkend="tp-proxy-borrow-interface-by-id">tp_proxy_borrow_interface_by_id</link>     (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> interface,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                <link linkend="tp-proxy-invalidate">tp_proxy_invalidate</link>                 (<link linkend="TpProxy">TpProxy</link> *self,
                                                         const <link linkend="GError">GError</link> *error);
<link linkend="void">void</link>                (<link linkend="TpProxyInterfaceAddedCb">*TpProxyInterfaceAddedCb</link>)          (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="guint">guint</link> quark,
                                                         <link linkend="DBusGProxy">DBusGProxy</link> *proxy,
                                                         <link linkend="gpointer">gpointer</link> unused);
<link linkend="void">void</link>                <link linkend="tp-proxy-or-subclass-hook-on-interface-add">tp_proxy_or_subclass_hook_on_interface_add</link>
                                                        (<link linkend="GType">GType</link> proxy_or_subclass,
                                                         <link linkend="TpProxyInterfaceAddedCb">TpProxyInterfaceAddedCb</link> callback);
<link linkend="void">void</link>                <link linkend="tp-proxy-subclass-add-error-mapping">tp_proxy_subclass_add_error_mapping</link> (<link linkend="GType">GType</link> proxy_subclass,
                                                         const <link linkend="gchar">gchar</link> *static_prefix,
                                                         <link linkend="GQuark">GQuark</link> domain,
                                                         <link linkend="GType">GType</link> code_enum_type);

<link linkend="void">void</link>                (<link linkend="TpProxyInvokeFunc">*TpProxyInvokeFunc</link>)                (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GError">GError</link> *error,
                                                         <link linkend="GValueArray">GValueArray</link> *args,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link>* <link linkend="tp-proxy-pending-call-v0-new">tp_proxy_pending_call_v0_new</link>        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> interface,
                                                         const <link linkend="gchar">gchar</link> *member,
                                                         <link linkend="DBusGProxy">DBusGProxy</link> *iface_proxy,
                                                         <link linkend="TpProxyInvokeFunc">TpProxyInvokeFunc</link> invoke_callback,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="gboolean">gboolean</link> cancel_must_raise);
<link linkend="void">void</link>                <link linkend="tp-proxy-pending-call-v0-completed">tp_proxy_pending_call_v0_completed</link>  (<link linkend="gpointer">gpointer</link> p);
<link linkend="void">void</link>                <link linkend="tp-proxy-pending-call-v0-take-pending-call">tp_proxy_pending_call_v0_take_pending_call</link>
                                                        (<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> *self,
                                                         <link linkend="DBusGProxyCall">DBusGProxyCall</link> *pending_call);
<link linkend="void">void</link>                <link linkend="tp-proxy-pending-call-v0-take-results">tp_proxy_pending_call_v0_take_results</link>
                                                        (<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> *self,
                                                         <link linkend="GError">GError</link> *error,
                                                         <link linkend="GValueArray">GValueArray</link> *args);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link>* <link linkend="tp-proxy-signal-connection-v0-new">tp_proxy_signal_connection_v0_new</link>
                                                        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> interface,
                                                         const <link linkend="gchar">gchar</link> *member,
                                                         const <link linkend="GType">GType</link> *expected_types,
                                                         <link linkend="GCallback">GCallback</link> collect_args,
                                                         <link linkend="TpProxyInvokeFunc">TpProxyInvokeFunc</link> invoke_callback,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                <link linkend="tp-proxy-signal-connection-v0-take-results">tp_proxy_signal_connection_v0_take_results</link>
                                                        (<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> *self,
                                                         <link linkend="GValueArray">GValueArray</link> *args);
</synopsis>
</refsynopsisdiv>









<refsect1 role="desc">
<title role="desc.title">Description</title>
<para>
The implementations of <link linkend="TpProxy"><type>TpProxy</type></link> subclasses and "mixin" functions need
access to the underlying dbus-glib objects used to implement the
<link linkend="TpProxy"><type>TpProxy</type></link> API.
</para>
<para>
Mixin functions to implement particular D-Bus interfaces should usually
be auto-generated, by copying tools/glib-client-gen.py from telepathy-glib.</para>
<para>

</para>
</refsect1>

<refsect1 role="details">
<title role="details.title">Details</title>
<refsect2>
<title><anchor id="tp-proxy-add-interface-by-id" role="function" condition="since:0.7.1"/>tp_proxy_add_interface_by_id ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_add_interface_by_id</primary></indexterm><programlisting><link linkend="DBusGProxy">DBusGProxy</link>*         tp_proxy_add_interface_by_id        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> interface);</programlisting>
<para>
Declare that this proxy supports a given interface, and allocate a
<link linkend="DBusGProxy"><type>DBusGProxy</type></link> to access it.
</para>
<para>
To use methods and signals of that interface, either call
<link linkend="tp-proxy-borrow-interface-by-id"><function>tp_proxy_borrow_interface_by_id()</function></link> to get the <link linkend="DBusGProxy"><type>DBusGProxy</type></link>, or use the
tp_cli_* wrapper functions (strongly recommended).
</para>
<para>
If the interface is the proxy's "main interface", or has already been
added, then do nothing.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> the TpProxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interface</parameter>&nbsp;:</term>
<listitem><simpara> quark representing the interface to be added
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the borrowed DBusGProxy

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-borrow-interface-by-id" role="function" condition="since:0.7.1"/>tp_proxy_borrow_interface_by_id ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_borrow_interface_by_id</primary></indexterm><programlisting><link linkend="DBusGProxy">DBusGProxy</link>*         tp_proxy_borrow_interface_by_id     (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> interface,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
<!-- --></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> the TpProxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interface</parameter>&nbsp;:</term>
<listitem><simpara> quark representing the interface required
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> used to raise TP_DBUS_ERROR_NO_INTERFACE if this object does not
have the required interface
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a borrowed reference to a <link linkend="DBusGProxy"><type>DBusGProxy</type></link>
for which the bus name and object path are the same as for <parameter>self</parameter>, but the
interface is as given (or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if this proxy does not implement it).
The reference is only valid as long as <parameter>self</parameter> is.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-invalidate" role="function" condition="since:0.7.1"/>tp_proxy_invalidate ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_invalidate</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_invalidate                 (<link linkend="TpProxy">TpProxy</link> *self,
                                                         const <link linkend="GError">GError</link> *error);</programlisting>
<para>
Mark <parameter>self</parameter> as having been invalidated - no further calls will work, and
if not already invalidated, the <link linkend="TpProxy--invalidated"><type>"invalidated"</type></link> signal will be emitted
with the given error.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> a proxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> an error causing the invalidation
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="TpProxyInterfaceAddedCb" role="function" condition="since:0.7.1"/>TpProxyInterfaceAddedCb ()</title>
<indexterm role="0.7.1"><primary>TpProxyInterfaceAddedCb</primary></indexterm><programlisting><link linkend="void">void</link>                (*TpProxyInterfaceAddedCb)          (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="guint">guint</link> quark,
                                                         <link linkend="DBusGProxy">DBusGProxy</link> *proxy,
                                                         <link linkend="gpointer">gpointer</link> unused);</programlisting>
<para>
The signature of a <link linkend="TpProxy-interface-added"><type>"interface-added"</type></link> signal callback.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> the proxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>quark</parameter>&nbsp;:</term>
<listitem><simpara> a quark whose string value is the interface being added
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>proxy</parameter>&nbsp;:</term>
<listitem><simpara> the <link linkend="DBusGProxy"><type>DBusGProxy</type></link> for the added interface
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>unused</parameter>&nbsp;:</term>
<listitem><simpara> unused
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-or-subclass-hook-on-interface-add" role="function" condition="since:0.7.1"/>tp_proxy_or_subclass_hook_on_interface_add ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_or_subclass_hook_on_interface_add</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_or_subclass_hook_on_interface_add
                                                        (<link linkend="GType">GType</link> proxy_or_subclass,
                                                         <link linkend="TpProxyInterfaceAddedCb">TpProxyInterfaceAddedCb</link> callback);</programlisting>
<para>
Arrange for <parameter>callback</parameter> to be connected to <link linkend="TpProxy-interface-added"><type>"interface-added"</type></link>
during the <link linkend="TpProxy"><type>TpProxy</type></link> constructor. This is done sufficiently early that
it will see the signal for the default interface (<parameter>interface</parameter> member of
<link linkend="TpProxyClass"><type>TpProxyClass</type></link>), if any, being added. The intended use is for the callback
to call <link linkend="dbus-g-proxy-add-signal"><function>dbus_g_proxy_add_signal()</function></link> on the new <link linkend="DBusGProxy"><type>DBusGProxy</type></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>proxy_or_subclass</parameter>&nbsp;:</term>
<listitem><simpara> The <link linkend="GType"><type>GType</type></link> of <link linkend="TpProxy"><type>TpProxy</type></link> or a subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&nbsp;:</term>
<listitem><simpara> A signal handler for <link linkend="TpProxy-interface-added"><type>"interface-added"</type></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-subclass-add-error-mapping" role="function" condition="since:0.7.1"/>tp_proxy_subclass_add_error_mapping ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_subclass_add_error_mapping</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_subclass_add_error_mapping (<link linkend="GType">GType</link> proxy_subclass,
                                                         const <link linkend="gchar">gchar</link> *static_prefix,
                                                         <link linkend="GQuark">GQuark</link> domain,
                                                         <link linkend="GType">GType</link> code_enum_type);</programlisting>
<para>
Register a mapping from D-Bus errors received from the given proxy
subclass to <link linkend="GError"><type>GError</type></link> instances.
</para>
<para>
When a D-Bus error is received, the <link linkend="TpProxy"><type>TpProxy</type></link> code checks for error
mappings registered for the class of the proxy receiving the error,
then for all of its parent classes.
</para>
<para>
If there is an error mapping for which the D-Bus error name
starts with the mapping's <parameter>static_prefix</parameter>, the proxy will check the
corresponding <parameter>code_enum_type</parameter> for a value whose <parameter>value_nick</parameter> is
the rest of the D-Bus error name (with the leading dot removed). If there
isn't such a value, it will continue to try other error mappings.
</para>
<para>
If a suitable error mapping and code are found, the <link linkend="GError"><type>GError</type></link> that is raised
will have its error domain set to the <parameter>domain</parameter> from the error mapping,
and its error code taken from the enum represented by the <parameter>code_enum_type</parameter>.
</para>
<para>
If no suitable error mapping or code is found, the <link linkend="GError"><type>GError</type></link> will have
error domain <link linkend="TP-DBUS-ERRORS:CAPS"><literal>TP_DBUS_ERRORS</literal></link> and error code
<link linkend="TP-DBUS-ERROR-UNKNOWN-REMOTE-ERROR:CAPS"><literal>TP_DBUS_ERROR_UNKNOWN_REMOTE_ERROR</literal></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>proxy_subclass</parameter>&nbsp;:</term>
<listitem><simpara> The <link linkend="GType"><type>GType</type></link> of a subclass of <link linkend="TpProxy"><type>TpProxy</type></link> (which must not be
 <link linkend="TpProxy"><type>TpProxy</type></link> itself)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>static_prefix</parameter>&nbsp;:</term>
<listitem><simpara> A prefix for D-Bus error names, not including the trailing
 dot (which must remain valid forever, and should usually be in static
 storage)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>domain</parameter>&nbsp;:</term>
<listitem><simpara> A quark representing the corresponding <link linkend="GError"><type>GError</type></link> domain
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>code_enum_type</parameter>&nbsp;:</term>
<listitem><simpara> The type of a subclass of <link linkend="GEnumClass"><type>GEnumClass</type></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="TpProxyInvokeFunc" role="function" condition="since:0.7.1"/>TpProxyInvokeFunc ()</title>
<indexterm role="0.7.1"><primary>TpProxyInvokeFunc</primary></indexterm><programlisting><link linkend="void">void</link>                (*TpProxyInvokeFunc)                (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GError">GError</link> *error,
                                                         <link linkend="GValueArray">GValueArray</link> *args,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of a callback invoked by the <link linkend="TpProxy"><type>TpProxy</type></link> machinery after a D-Bus
method call has succeeded or failed. It is responsible for calling the
user-supplied callback.
</para>
<para>
Because parts of dbus-glib aren't reentrant, this callback may be called
from an idle handler shortly after the method call reply is received,
rather than from the callback for the reply.
</para>
<para>
At most one of <parameter>args</parameter> and <parameter>error</parameter> can be non-<link linkend="NULL:CAPS"><literal>NULL</literal></link> (implementations may
assert this). <parameter>args</parameter> and <parameter>error</parameter> may both be <link linkend="NULL:CAPS"><literal>NULL</literal></link> if a method with no
"out" arguments (i.e. a method that returns nothing) was called
successfully.
</para>
<para>
The <link linkend="TpProxyInvokeFunc"><type>TpProxyInvokeFunc</type></link> must call callback with <parameter>user_data</parameter>, <parameter>weak_object</parameter>,
and appropriate arguments derived from <parameter>error</parameter> and <parameter>args</parameter>. It is responsible
for freeing <parameter>error</parameter> and <parameter>args</parameter>, if their ownership has not been transferred.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link> on which the D-Bus method was invoked
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the method call succeeded, or a non-<link linkend="NULL:CAPS"><literal>NULL</literal></link> error if the
 method call failed
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>args</parameter>&nbsp;:</term>
<listitem><simpara> array of "out" arguments (return values) for the D-Bus method,
 or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if an error occurred or if there were no "out" arguments
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&nbsp;:</term>
<listitem><simpara> the callback that should be invoked, as passed to
 <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> user-supplied data to pass to the callback, as passed to
 <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&nbsp;:</term>
<listitem><simpara> user-supplied object to pass to the callback, as passed to
 <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-pending-call-v0-new" role="function" condition="since:0.7.1"/>tp_proxy_pending_call_v0_new ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_pending_call_v0_new</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link>* tp_proxy_pending_call_v0_new        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> interface,
                                                         const <link linkend="gchar">gchar</link> *member,
                                                         <link linkend="DBusGProxy">DBusGProxy</link> *iface_proxy,
                                                         <link linkend="TpProxyInvokeFunc">TpProxyInvokeFunc</link> invoke_callback,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="gboolean">gboolean</link> cancel_must_raise);</programlisting>
<para>
Allocate a new pending call structure. After calling this function, the
caller must start an asynchronous D-Bus call and give the resulting
DBusGProxyCall to the pending call object using
<link linkend="tp-proxy-pending-call-v0-take-pending-call"><function>tp_proxy_pending_call_v0_take_pending_call()</function></link>.
</para>
<para>
If dbus-glib gets a reply to the call before it's cancelled, the caller
must arrange for <link linkend="tp-proxy-pending-call-v0-take-results"><function>tp_proxy_pending_call_v0_take_results()</function></link> to be called
with the results (the intention is for this to be done immediately
after dbus_g_proxy_end_call in the callback supplied to dbus-glib).
</para>
<para>
When dbus-glib discards its reference to the user_data supplied in the
asynchronous D-Bus call (i.e. after the call is cancelled or a reply
arrives), tp_proxy_pending_call_v0_completed must be called (the intention
is for the <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> to be the <parameter>user_data</parameter> in the async call,
and for tp_proxy_pending_call_v0_completed to be the <link linkend="GDestroyNotify"><type>GDestroyNotify</type></link>
passed to the same async call).
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> a proxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interface</parameter>&nbsp;:</term>
<listitem><simpara> a quark whose string value is the D-Bus interface
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>member</parameter>&nbsp;:</term>
<listitem><simpara> the name of the method being called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface_proxy</parameter>&nbsp;:</term>
<listitem><simpara> the interface-specific <link linkend="DBusGProxy"><type>DBusGProxy</type></link> for <parameter>interface</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>invoke_callback</parameter>&nbsp;:</term>
<listitem><simpara> an implementation of <link linkend="TpProxyInvokeFunc"><type>TpProxyInvokeFunc</type></link> which will
 invoke <parameter>callback</parameter> with appropriate arguments
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&nbsp;:</term>
<listitem><simpara> a callback to be called when the call completes
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> user-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&nbsp;:</term>
<listitem><simpara> user-supplied destructor for the data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&nbsp;:</term>
<listitem><simpara> if not <link linkend="NULL:CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced by
  the signal connection - if it is destroyed, the pending call will
  automatically be cancelled
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cancel_must_raise</parameter>&nbsp;:</term>
<listitem><simpara> if <link linkend="TRUE:CAPS"><literal>TRUE</literal></link>, the <parameter>invoke_callback</parameter> will be run with
 error <link linkend="TP-DBUS-ERROR-CANCELLED:CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link> if the call is cancelled by a call to
 <link linkend="tp-proxy-pending-call-cancel"><function>tp_proxy_pending_call_cancel()</function></link> or by destruction of the <link linkend="weak-object"><function>weak_object()</function></link>;
 if <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>, the <parameter>invoke_callback</parameter> will not be run at all in these cases
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a new pending call structure

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-pending-call-v0-completed" role="function" condition="since:0.7.1"/>tp_proxy_pending_call_v0_completed ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_pending_call_v0_completed</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_pending_call_v0_completed  (<link linkend="gpointer">gpointer</link> p);</programlisting>
<para>
Indicate that dbus-glib has finished with this pending call, and therefore
either <link linkend="tp-proxy-pending-call-v0-take-results"><function>tp_proxy_pending_call_v0_take_results()</function></link> has already been called,
or it will never be called. See <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>.
</para>
<para>
The signature is chosen to match <link linkend="GDestroyNotify"><type>GDestroyNotify</type></link>.
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>p</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> allocated with <link linkend="tp-proxy-pending-call-new"><function>tp_proxy_pending_call_new()</function></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-pending-call-v0-take-pending-call" role="function" condition="since:0.7.1"/>tp_proxy_pending_call_v0_take_pending_call ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_pending_call_v0_take_pending_call</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_pending_call_v0_take_pending_call
                                                        (<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> *self,
                                                         <link linkend="DBusGProxyCall">DBusGProxyCall</link> *pending_call);</programlisting>
<para>
Set the underlying pending call to be used by this object.
See also <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>.
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A pending call on which this function has not yet been called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>pending_call</parameter>&nbsp;:</term>
<listitem><simpara> The underlying dbus-glib pending call
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-pending-call-v0-take-results" role="function" condition="since:0.7.1"/>tp_proxy_pending_call_v0_take_results ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_pending_call_v0_take_results</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_pending_call_v0_take_results
                                                        (<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> *self,
                                                         <link linkend="GError">GError</link> *error,
                                                         <link linkend="GValueArray">GValueArray</link> *args);</programlisting>
<para>
Set the "out" arguments (return values) from this pending call.
See also <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>.
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A pending call on which this function has not yet been called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the call was successful, or an error (whose ownership
 is taken over by the pending call object). Because of dbus-glib
 idiosyncrasies, this must be the error produced by dbus-glib, not a copy.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>args</parameter>&nbsp;:</term>
<listitem><simpara> <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the call failed or had no "out" arguments, or an array
 of "out" arguments (whose ownership is taken over by the pending call
 object)
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-signal-connection-v0-new" role="function" condition="since:0.7.1"/>tp_proxy_signal_connection_v0_new ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_signal_connection_v0_new</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link>* tp_proxy_signal_connection_v0_new
                                                        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> interface,
                                                         const <link linkend="gchar">gchar</link> *member,
                                                         const <link linkend="GType">GType</link> *expected_types,
                                                         <link linkend="GCallback">GCallback</link> collect_args,
                                                         <link linkend="TpProxyInvokeFunc">TpProxyInvokeFunc</link> invoke_callback,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Allocate a new structure representing a signal connection, and connect to
the signal, arranging for <parameter>invoke_callback</parameter> to be called when it arrives.
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> a proxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interface</parameter>&nbsp;:</term>
<listitem><simpara> a quark whose string value is the D-Bus interface
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>member</parameter>&nbsp;:</term>
<listitem><simpara> the name of the signal to which we're connecting
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>expected_types</parameter>&nbsp;:</term>
<listitem><simpara> an array of expected GTypes for the arguments, terminated
 by <link linkend="G-TYPE-INVALID:CAPS"><literal>G_TYPE_INVALID</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>collect_args</parameter>&nbsp;:</term>
<listitem><simpara> a callback to be given to <link linkend="dbus-g-proxy-connect-signal"><function>dbus_g_proxy_connect_signal()</function></link>,
 which must marshal the arguments into a <link linkend="GValueArray"><type>GValueArray</type></link> and use them to call
 <link linkend="tp-proxy-signal-connection-v0-take-results"><function>tp_proxy_signal_connection_v0_take_results()</function></link>; this callback is not
 guaranteed to be called by future versions of telepathy-glib, which might
 be able to implement its functionality internally. If no arguments are
 expected at all (expected_types = { G_TYPE_INVALID }) then this callback
 should instead be <link linkend="NULL:CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>invoke_callback</parameter>&nbsp;:</term>
<listitem><simpara> a function which will be called with <parameter>error</parameter> = <link linkend="NULL:CAPS"><literal>NULL</literal></link>,
 which should invoke <parameter>callback</parameter> with <parameter>user_data</parameter>, <parameter>weak_object</parameter> and other
 appropriate arguments taken from <parameter>args</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&nbsp;:</term>
<listitem><simpara> user callback to be invoked by <parameter>invoke_callback</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> user-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&nbsp;:</term>
<listitem><simpara> user-supplied destructor for the data, which will be called
  when the signal connection is disconnected for any reason,
  or will be called before this function returns if an error occurs
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&nbsp;:</term>
<listitem><simpara> if not <link linkend="NULL:CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced by
  the signal connection - if it is destroyed, the signal connection will
  automatically be disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> If not <link linkend="NULL:CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL:CAPS"><literal>NULL</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a signal connection structure, or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the proxy does not
 have the desired interface or has become invalid

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>
<refsect2>
<title><anchor id="tp-proxy-signal-connection-v0-take-results" role="function" condition="since:0.7.1"/>tp_proxy_signal_connection_v0_take_results ()</title>
<indexterm role="0.7.1"><primary>tp_proxy_signal_connection_v0_take_results</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_signal_connection_v0_take_results
                                                        (<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> *self,
                                                         <link linkend="GValueArray">GValueArray</link> *args);</programlisting>
<para>
Feed the results of a signal invocation back into the signal connection
machinery.
</para>
<para>
This method should only be called from <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations,
in the callback that implements <parameter>collect_args</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> The signal connection
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>args</parameter>&nbsp;:</term>
<listitem><simpara> The arguments of the signal
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  0.7.1
</para></refsect2>

</refsect1>



<refsect1>
<title>See Also</title>
<link linkend="TpProxy"><type>TpProxy</type></link>
</refsect1>


<refsect1><refsect2 /><refsect2 /></refsect1>
</refentry>
