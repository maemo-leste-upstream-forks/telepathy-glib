<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="telepathy-glib-proxy-subclass">
<refmeta>
<refentrytitle role="top_of_page" id="telepathy-glib-proxy-subclass.top_of_page">TpProxy subclasses and mixins</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>TpProxy subclasses and mixins</refname>
<refpurpose>Providing extra functionality for a <link linkend="TpProxy"><type>TpProxy</type></link> or
 subclass, or subclassing it</refpurpose>
</refnamediv>

<refsynopsisdiv id="telepathy-glib-proxy-subclass.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;telepathy-glib/proxy-subclass.h&gt;

<link linkend="DBusGProxy">DBusGProxy</link> *        <link linkend="tp-proxy-add-interface-by-id">tp_proxy_add_interface_by_id</link>        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> iface);
<link linkend="DBusGProxy">DBusGProxy</link> *        <link linkend="tp-proxy-borrow-interface-by-id">tp_proxy_borrow_interface_by_id</link>     (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> iface,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                <link linkend="tp-proxy-invalidate">tp_proxy_invalidate</link>                 (<link linkend="TpProxy">TpProxy</link> *self,
                                                         const <link linkend="GError">GError</link> *error);
<link linkend="void">void</link>                (<link linkend="TpProxyInterfaceAddedCb">*TpProxyInterfaceAddedCb</link>)          (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="guint">guint</link> quark,
                                                         <link linkend="DBusGProxy">DBusGProxy</link> *proxy,
                                                         <link linkend="gpointer">gpointer</link> unused);
<link linkend="void">void</link>                <link linkend="tp-proxy-or-subclass-hook-on-interface-add">tp_proxy_or_subclass_hook_on_interface_add</link>
                                                        (<link linkend="GType">GType</link> proxy_or_subclass,
                                                         <link linkend="TpProxyInterfaceAddedCb">TpProxyInterfaceAddedCb</link> callback);
<link linkend="void">void</link>                <link linkend="tp-proxy-init-known-interfaces">tp_proxy_init_known_interfaces</link>      (void);
<link linkend="void">void</link>                <link linkend="tp-proxy-subclass-add-error-mapping">tp_proxy_subclass_add_error_mapping</link> (<link linkend="GType">GType</link> proxy_subclass,
                                                         const <link linkend="gchar">gchar</link> *static_prefix,
                                                         <link linkend="GQuark">GQuark</link> domain,
                                                         <link linkend="GType">GType</link> code_enum_type);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-proxy-dbus-g-proxy-claim-for-signal-adding">tp_proxy_dbus_g_proxy_claim_for_signal_adding</link>
                                                        (<link linkend="DBusGProxy">DBusGProxy</link> *proxy);

<link linkend="void">void</link>                (<link linkend="TpProxyInvokeFunc">*TpProxyInvokeFunc</link>)                (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GError">GError</link> *error,
                                                         <link linkend="GValueArray">GValueArray</link> *args,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-proxy-pending-call-v0-new">tp_proxy_pending_call_v0_new</link>       (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> iface,
                                                         const <link linkend="gchar">gchar</link> *member,
                                                         <link linkend="DBusGProxy">DBusGProxy</link> *iface_proxy,
                                                         <link linkend="TpProxyInvokeFunc">TpProxyInvokeFunc</link> invoke_callback,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="gboolean">gboolean</link> cancel_must_raise);
<link linkend="void">void</link>                <link linkend="tp-proxy-pending-call-v0-completed">tp_proxy_pending_call_v0_completed</link>  (<link linkend="gpointer">gpointer</link> p);
<link linkend="void">void</link>                <link linkend="tp-proxy-pending-call-v0-take-pending-call">tp_proxy_pending_call_v0_take_pending_call</link>
                                                        (<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> *pc,
                                                         <link linkend="DBusGProxyCall">DBusGProxyCall</link> *pending_call);
<link linkend="void">void</link>                <link linkend="tp-proxy-pending-call-v0-take-results">tp_proxy_pending_call_v0_take_results</link>
                                                        (<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> *pc,
                                                         <link linkend="GError">GError</link> *error,
                                                         <link linkend="GValueArray">GValueArray</link> *args);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-proxy-signal-connection-v0-new">tp_proxy_signal_connection_v0_new</link>
                                                        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> iface,
                                                         const <link linkend="gchar">gchar</link> *member,
                                                         const <link linkend="GType">GType</link> *expected_types,
                                                         <link linkend="GCallback">GCallback</link> collect_args,
                                                         <link linkend="TpProxyInvokeFunc">TpProxyInvokeFunc</link> invoke_callback,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                <link linkend="tp-proxy-signal-connection-v0-take-results">tp_proxy_signal_connection_v0_take_results</link>
                                                        (<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> *sc,
                                                         <link linkend="GValueArray">GValueArray</link> *args);
</synopsis>
</refsynopsisdiv>









<refsect1 id="telepathy-glib-proxy-subclass.description" role="desc">
<title role="desc.title">Description</title>
<para>
The implementations of <link linkend="TpProxy"><type>TpProxy</type></link> subclasses and "mixin" functions need
access to the underlying dbus-glib objects used to implement the
<link linkend="TpProxy"><type>TpProxy</type></link> API.
</para>
<para>
Mixin functions to implement particular D-Bus interfaces should usually
be auto-generated, by copying tools/glib-client-gen.py from telepathy-glib.</para>
<para>
</para>
</refsect1>

<refsect1 id="telepathy-glib-proxy-subclass.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="tp-proxy-add-interface-by-id" role="function" condition="since:0.7.1">
<title>tp_proxy_add_interface_by_id ()</title>
<indexterm zone="tp-proxy-add-interface-by-id" role="0.7.1"><primary sortas="tp_proxy_add_interface_by_id">tp_proxy_add_interface_by_id</primary></indexterm><programlisting><link linkend="DBusGProxy">DBusGProxy</link> *        tp_proxy_add_interface_by_id        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> iface);</programlisting>
<para>
Declare that this proxy supports a given interface.
</para>
<para>
To use methods and signals of that interface, either call
<link linkend="tp-proxy-borrow-interface-by-id"><function>tp_proxy_borrow_interface_by_id()</function></link> to get the <link linkend="DBusGProxy"><type>DBusGProxy</type></link>, or use the
tp_cli_* wrapper functions (strongly recommended).
</para>
<para>
If the interface is the proxy's "main interface", or has already been
added, then do nothing.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> the TpProxy, which must not have become <link linkend="TpProxy-invalidated"><type>"invalidated"</type></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface</parameter>&#160;:</term>
<listitem><simpara> quark representing the interface to be added
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> either <link linkend="NULL--CAPS"><literal>NULL</literal></link> or a borrowed <link linkend="DBusGProxy"><type>DBusGProxy</type></link> corresponding to <parameter>iface</parameter>,
depending on implementation details. To reliably borrow the <link linkend="DBusGProxy"><type>DBusGProxy</type></link>, use
<link linkend="tp-proxy-borrow-interface-by-id"><function>tp_proxy_borrow_interface_by_id()</function></link>. (This method should probably have
returned void; sorry.)

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-borrow-interface-by-id" role="function" condition="since:0.7.1">
<title>tp_proxy_borrow_interface_by_id ()</title>
<indexterm zone="tp-proxy-borrow-interface-by-id" role="0.7.1"><primary sortas="tp_proxy_borrow_interface_by_id">tp_proxy_borrow_interface_by_id</primary></indexterm><programlisting><link linkend="DBusGProxy">DBusGProxy</link> *        tp_proxy_borrow_interface_by_id     (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> iface,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
<!-- --></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> the TpProxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface</parameter>&#160;:</term>
<listitem><simpara> quark representing the interface required
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> used to raise an error in the <link linkend="TP-DBUS-ERRORS--CAPS"><type>TP_DBUS_ERRORS</type></link> domain if <parameter>iface</parameter>
        is invalid, <parameter>self</parameter> has been invalidated or <parameter>self</parameter> does not implement
        <parameter>iface</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a borrowed reference to a <link linkend="DBusGProxy"><type>DBusGProxy</type></link>
for which the bus name and object path are the same as for <parameter>self</parameter>, but the
interface is as given (or <link linkend="NULL--CAPS"><literal>NULL</literal></link> if an <parameter>error</parameter> is raised).
The reference is only valid as long as <parameter>self</parameter> is.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-invalidate" role="function" condition="since:0.7.1">
<title>tp_proxy_invalidate ()</title>
<indexterm zone="tp-proxy-invalidate" role="0.7.1"><primary sortas="tp_proxy_invalidate">tp_proxy_invalidate</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_invalidate                 (<link linkend="TpProxy">TpProxy</link> *self,
                                                         const <link linkend="GError">GError</link> *error);</programlisting>
<para>
Mark <parameter>self</parameter> as having been invalidated - no further calls will work, and
if not already invalidated, the <link linkend="TpProxy--invalidated"><type>"invalidated"</type></link> signal will be emitted
with the given error.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a proxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> an error causing the invalidation
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="TpProxyInterfaceAddedCb" role="function" condition="since:0.7.1">
<title>TpProxyInterfaceAddedCb ()</title>
<indexterm zone="TpProxyInterfaceAddedCb" role="0.7.1"><primary sortas="TpProxyInterfaceAddedCb">TpProxyInterfaceAddedCb</primary></indexterm><programlisting><link linkend="void">void</link>                (*TpProxyInterfaceAddedCb)          (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="guint">guint</link> quark,
                                                         <link linkend="DBusGProxy">DBusGProxy</link> *proxy,
                                                         <link linkend="gpointer">gpointer</link> unused);</programlisting>
<para>
The signature of a <link linkend="TpProxy-interface-added"><type>"interface-added"</type></link> signal callback.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> the proxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>quark</parameter>&#160;:</term>
<listitem><simpara> a quark whose string value is the interface being added
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="DBusGProxy"><type>DBusGProxy</type></link> for the added interface
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>unused</parameter>&#160;:</term>
<listitem><simpara> unused
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-or-subclass-hook-on-interface-add" role="function" condition="since:0.7.1">
<title>tp_proxy_or_subclass_hook_on_interface_add ()</title>
<indexterm zone="tp-proxy-or-subclass-hook-on-interface-add" role="0.7.1"><primary sortas="tp_proxy_or_subclass_hook_on_interface_add">tp_proxy_or_subclass_hook_on_interface_add</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_or_subclass_hook_on_interface_add
                                                        (<link linkend="GType">GType</link> proxy_or_subclass,
                                                         <link linkend="TpProxyInterfaceAddedCb">TpProxyInterfaceAddedCb</link> callback);</programlisting>
<para>
Arrange for <parameter>callback</parameter> to be connected to <link linkend="TpProxy-interface-added"><type>"interface-added"</type></link>
during the <link linkend="TpProxy"><type>TpProxy</type></link> constructor. This is done sufficiently early that
it will see the signal for the default interface (<parameter>interface</parameter> member of
<link linkend="TpProxyClass"><type>TpProxyClass</type></link>), if any, being added. The intended use is for the callback
to call <link linkend="dbus-g-proxy-add-signal"><function>dbus_g_proxy_add_signal()</function></link> on the new <link linkend="DBusGProxy"><type>DBusGProxy</type></link>.
</para>
<para>
Since 0.7.6, to ensure correct overriding of interfaces that might be
added to telepathy-glib, before calling this function you should
call tp_proxy_init_known_interfaces, tp_connection_init_known_interfaces,
tp_channel_init_known_interfaces etc. as appropriate for the subclass.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy_or_subclass</parameter>&#160;:</term>
<listitem><simpara> The <link linkend="GType"><type>GType</type></link> of <link linkend="TpProxy"><type>TpProxy</type></link> or a subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> A signal handler for <link linkend="TpProxy-interface-added"><type>"interface-added"</type></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-init-known-interfaces" role="function" condition="since:0.7.6">
<title>tp_proxy_init_known_interfaces ()</title>
<indexterm zone="tp-proxy-init-known-interfaces" role="0.7.6"><primary sortas="tp_proxy_init_known_interfaces">tp_proxy_init_known_interfaces</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_init_known_interfaces      (void);</programlisting>
<para>
Ensure that the known interfaces for TpProxy have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
<link linkend="tp-proxy-or-subclass-hook-on-interface-add"><function>tp_proxy_or_subclass_hook_on_interface_add()</function></link>.
</para>
<para>
Functions like tp_connection_init_known_interfaces and
tp_channel_init_known_interfaces do this automatically.</para>
<para>
</para><para role="since">Since 0.7.6</para></refsect2>
<refsect2 id="tp-proxy-subclass-add-error-mapping" role="function" condition="since:0.7.1">
<title>tp_proxy_subclass_add_error_mapping ()</title>
<indexterm zone="tp-proxy-subclass-add-error-mapping" role="0.7.1"><primary sortas="tp_proxy_subclass_add_error_mapping">tp_proxy_subclass_add_error_mapping</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_subclass_add_error_mapping (<link linkend="GType">GType</link> proxy_subclass,
                                                         const <link linkend="gchar">gchar</link> *static_prefix,
                                                         <link linkend="GQuark">GQuark</link> domain,
                                                         <link linkend="GType">GType</link> code_enum_type);</programlisting>
<para>
Register a mapping from D-Bus errors received from the given proxy
subclass to <link linkend="GError"><type>GError</type></link> instances.
</para>
<para>
When a D-Bus error is received, the <link linkend="TpProxy"><type>TpProxy</type></link> code checks for error
mappings registered for the class of the proxy receiving the error,
then for all of its parent classes.
</para>
<para>
If there is an error mapping for which the D-Bus error name
starts with the mapping's <parameter>static_prefix</parameter>, the proxy will check the
corresponding <parameter>code_enum_type</parameter> for a value whose <parameter>value_nick</parameter> is
the rest of the D-Bus error name (with the leading dot removed). If there
isn't such a value, it will continue to try other error mappings.
</para>
<para>
If a suitable error mapping and code are found, the <link linkend="GError"><type>GError</type></link> that is raised
will have its error domain set to the <parameter>domain</parameter> from the error mapping,
and its error code taken from the enum represented by the <parameter>code_enum_type</parameter>.
</para>
<para>
If no suitable error mapping or code is found, the <link linkend="GError"><type>GError</type></link> will have
error domain <link linkend="TP-DBUS-ERRORS--CAPS"><literal>TP_DBUS_ERRORS</literal></link> and error code
<link linkend="TP-DBUS-ERROR-UNKNOWN-REMOTE-ERROR--CAPS"><literal>TP_DBUS_ERROR_UNKNOWN_REMOTE_ERROR</literal></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy_subclass</parameter>&#160;:</term>
<listitem><simpara> The <link linkend="GType"><type>GType</type></link> of a subclass of <link linkend="TpProxy"><type>TpProxy</type></link> (which must not be
 <link linkend="TpProxy"><type>TpProxy</type></link> itself)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>static_prefix</parameter>&#160;:</term>
<listitem><simpara> A prefix for D-Bus error names, not including the trailing
 dot (which must remain valid forever, and should usually be in static
 storage)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>domain</parameter>&#160;:</term>
<listitem><simpara> A quark representing the corresponding <link linkend="GError"><type>GError</type></link> domain
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>code_enum_type</parameter>&#160;:</term>
<listitem><simpara> The type of a subclass of <link linkend="GEnumClass"><type>GEnumClass</type></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-dbus-g-proxy-claim-for-signal-adding" role="function" condition="since:0.7.6">
<title>tp_proxy_dbus_g_proxy_claim_for_signal_adding ()</title>
<indexterm zone="tp-proxy-dbus-g-proxy-claim-for-signal-adding" role="0.7.6"><primary sortas="tp_proxy_dbus_g_proxy_claim_for_signal_adding">tp_proxy_dbus_g_proxy_claim_for_signal_adding</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_proxy_dbus_g_proxy_claim_for_signal_adding
                                                        (<link linkend="DBusGProxy">DBusGProxy</link> *proxy);</programlisting>
<para>
Attempt to "claim" a <link linkend="DBusGProxy"><type>DBusGProxy</type></link> for addition of signal signatures.
If this function has not been called on <parameter>proxy</parameter> before, <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is
returned, and the caller may safely call <link linkend="dbus-g-proxy-add-signal"><function>dbus_g_proxy_add_signal()</function></link>
on <parameter>proxy</parameter>. If this function has already been caled, <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> is
returned, and the caller may not safely call <link linkend="dbus-g-proxy-add-signal"><function>dbus_g_proxy_add_signal()</function></link>.
</para>
<para>
This is intended for use by auto-generated signal-adding functions,
to allow interfaces provided as local extensions to override those in
telepathy-glib without causing assertion failures.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="DBusGProxy"><type>DBusGProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> if it is safe to call <link linkend="dbus-g-proxy-add-signal"><function>dbus_g_proxy_add_signal()</function></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.6</para></refsect2>
<refsect2 id="TpProxyInvokeFunc" role="function" condition="since:0.7.1">
<title>TpProxyInvokeFunc ()</title>
<indexterm zone="TpProxyInvokeFunc" role="0.7.1"><primary sortas="TpProxyInvokeFunc">TpProxyInvokeFunc</primary></indexterm><programlisting><link linkend="void">void</link>                (*TpProxyInvokeFunc)                (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GError">GError</link> *error,
                                                         <link linkend="GValueArray">GValueArray</link> *args,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of a callback invoked by the <link linkend="TpProxy"><type>TpProxy</type></link> machinery after a D-Bus
method call has succeeded or failed. It is responsible for calling the
user-supplied callback.
</para>
<para>
Because parts of dbus-glib aren't reentrant, this callback may be called
from an idle handler shortly after the method call reply is received,
rather than from the callback for the reply.
</para>
<para>
At most one of <parameter>args</parameter> and <parameter>error</parameter> can be non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> (implementations may
assert this). <parameter>args</parameter> and <parameter>error</parameter> may both be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if a method with no
"out" arguments (i.e. a method that returns nothing) was called
successfully.
</para>
<para>
The <link linkend="TpProxyInvokeFunc"><type>TpProxyInvokeFunc</type></link> must call callback with <parameter>user_data</parameter>, <parameter>weak_object</parameter>,
and appropriate arguments derived from <parameter>error</parameter> and <parameter>args</parameter>. It is responsible
for freeing <parameter>error</parameter> and <parameter>args</parameter>, if their ownership has not been transferred.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link> on which the D-Bus method was invoked
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> if the method call succeeded, or a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> error if the
 method call failed
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>args</parameter>&#160;:</term>
<listitem><simpara> array of "out" arguments (return values) for the D-Bus method,
 or <link linkend="NULL--CAPS"><literal>NULL</literal></link> if an error occurred or if there were no "out" arguments
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> the callback that should be invoked, as passed to
 <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data to pass to the callback, as passed to
 <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object to pass to the callback, as passed to
 <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-pending-call-v0-new" role="function" condition="since:0.7.1">
<title>tp_proxy_pending_call_v0_new ()</title>
<indexterm zone="tp-proxy-pending-call-v0-new" role="0.7.1"><primary sortas="tp_proxy_pending_call_v0_new">tp_proxy_pending_call_v0_new</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_proxy_pending_call_v0_new       (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> iface,
                                                         const <link linkend="gchar">gchar</link> *member,
                                                         <link linkend="DBusGProxy">DBusGProxy</link> *iface_proxy,
                                                         <link linkend="TpProxyInvokeFunc">TpProxyInvokeFunc</link> invoke_callback,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="gboolean">gboolean</link> cancel_must_raise);</programlisting>
<para>
Allocate a new pending call structure. After calling this function, the
caller must start an asynchronous D-Bus call and give the resulting
DBusGProxyCall to the pending call object using
<link linkend="tp-proxy-pending-call-v0-take-pending-call"><function>tp_proxy_pending_call_v0_take_pending_call()</function></link>.
</para>
<para>
If dbus-glib gets a reply to the call before it's cancelled, the caller
must arrange for <link linkend="tp-proxy-pending-call-v0-take-results"><function>tp_proxy_pending_call_v0_take_results()</function></link> to be called
with the results (the intention is for this to be done immediately
after dbus_g_proxy_end_call in the callback supplied to dbus-glib).
</para>
<para>
When dbus-glib discards its reference to the user_data supplied in the
asynchronous D-Bus call (i.e. after the call is cancelled or a reply
arrives), tp_proxy_pending_call_v0_completed must be called (the intention
is for the <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> to be the <parameter>user_data</parameter> in the async call,
and for tp_proxy_pending_call_v0_completed to be the <link linkend="GDestroyNotify"><type>GDestroyNotify</type></link>
passed to the same async call).
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a proxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface</parameter>&#160;:</term>
<listitem><simpara> a quark whose string value is the D-Bus interface
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>member</parameter>&#160;:</term>
<listitem><simpara> the name of the method being called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface_proxy</parameter>&#160;:</term>
<listitem><simpara> the interface-specific <link linkend="DBusGProxy"><type>DBusGProxy</type></link> for <parameter>iface</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>invoke_callback</parameter>&#160;:</term>
<listitem><simpara> an implementation of <link linkend="TpProxyInvokeFunc"><type>TpProxyInvokeFunc</type></link> which will
 invoke <parameter>callback</parameter> with appropriate arguments
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> a callback to be called when the call completes
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> user-supplied destructor for the data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> if not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced by
  the signal connection - if it is destroyed, the pending call will
  automatically be cancelled
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cancel_must_raise</parameter>&#160;:</term>
<listitem><simpara> if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link>, the <parameter>invoke_callback</parameter> will be run with
 error <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link> if the call is cancelled by a call to
 <link linkend="tp-proxy-pending-call-cancel"><function>tp_proxy_pending_call_cancel()</function></link> or by destruction of the <link linkend="weak-object"><function>weak_object()</function></link>;
 if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link>, the <parameter>invoke_callback</parameter> will not be run at all in these cases
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a new pending call structure

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-pending-call-v0-completed" role="function" condition="since:0.7.1">
<title>tp_proxy_pending_call_v0_completed ()</title>
<indexterm zone="tp-proxy-pending-call-v0-completed" role="0.7.1"><primary sortas="tp_proxy_pending_call_v0_completed">tp_proxy_pending_call_v0_completed</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_pending_call_v0_completed  (<link linkend="gpointer">gpointer</link> p);</programlisting>
<para>
Indicate that dbus-glib has finished with this pending call, and therefore
either <link linkend="tp-proxy-pending-call-v0-take-results"><function>tp_proxy_pending_call_v0_take_results()</function></link> has already been called,
or it will never be called. See <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>.
</para>
<para>
The signature is chosen to match <link linkend="GDestroyNotify"><type>GDestroyNotify</type></link>.
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>p</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> allocated with <link linkend="tp-proxy-pending-call-new"><function>tp_proxy_pending_call_new()</function></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-pending-call-v0-take-pending-call" role="function" condition="since:0.7.1">
<title>tp_proxy_pending_call_v0_take_pending_call ()</title>
<indexterm zone="tp-proxy-pending-call-v0-take-pending-call" role="0.7.1"><primary sortas="tp_proxy_pending_call_v0_take_pending_call">tp_proxy_pending_call_v0_take_pending_call</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_pending_call_v0_take_pending_call
                                                        (<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> *pc,
                                                         <link linkend="DBusGProxyCall">DBusGProxyCall</link> *pending_call);</programlisting>
<para>
Set the underlying pending call to be used by this object.
See also <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>.
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>pc</parameter>&#160;:</term>
<listitem><simpara> A pending call on which this function has not yet been called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>pending_call</parameter>&#160;:</term>
<listitem><simpara> The underlying dbus-glib pending call
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-pending-call-v0-take-results" role="function" condition="since:0.7.1">
<title>tp_proxy_pending_call_v0_take_results ()</title>
<indexterm zone="tp-proxy-pending-call-v0-take-results" role="0.7.1"><primary sortas="tp_proxy_pending_call_v0_take_results">tp_proxy_pending_call_v0_take_results</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_pending_call_v0_take_results
                                                        (<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> *pc,
                                                         <link linkend="GError">GError</link> *error,
                                                         <link linkend="GValueArray">GValueArray</link> *args);</programlisting>
<para>
Set the "out" arguments (return values) from this pending call.
See also <link linkend="tp-proxy-pending-call-v0-new"><function>tp_proxy_pending_call_v0_new()</function></link>.
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>pc</parameter>&#160;:</term>
<listitem><simpara> A pending call on which this function has not yet been called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> if the call was successful, or an error (whose ownership
 is taken over by the pending call object). Because of dbus-glib
 idiosyncrasies, this must be the error produced by dbus-glib, not a copy.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>args</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> if the call failed or had no "out" arguments, or an array
 of "out" arguments (whose ownership is taken over by the pending call
 object)
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-signal-connection-v0-new" role="function" condition="since:0.7.1">
<title>tp_proxy_signal_connection_v0_new ()</title>
<indexterm zone="tp-proxy-signal-connection-v0-new" role="0.7.1"><primary sortas="tp_proxy_signal_connection_v0_new">tp_proxy_signal_connection_v0_new</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_proxy_signal_connection_v0_new
                                                        (<link linkend="TpProxy">TpProxy</link> *self,
                                                         <link linkend="GQuark">GQuark</link> iface,
                                                         const <link linkend="gchar">gchar</link> *member,
                                                         const <link linkend="GType">GType</link> *expected_types,
                                                         <link linkend="GCallback">GCallback</link> collect_args,
                                                         <link linkend="TpProxyInvokeFunc">TpProxyInvokeFunc</link> invoke_callback,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Allocate a new structure representing a signal connection, and connect to
the signal, arranging for <parameter>invoke_callback</parameter> to be called when it arrives.
</para>
<para>
This function is for use by <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations only, and
should usually only be called from code generated by
tools/glib-client-gen.py.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a proxy
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>iface</parameter>&#160;:</term>
<listitem><simpara> a quark whose string value is the D-Bus interface
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>member</parameter>&#160;:</term>
<listitem><simpara> the name of the signal to which we're connecting
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>expected_types</parameter>&#160;:</term>
<listitem><simpara> an array of expected GTypes for the arguments, terminated
 by <link linkend="G-TYPE-INVALID--CAPS"><literal>G_TYPE_INVALID</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>collect_args</parameter>&#160;:</term>
<listitem><simpara> a callback to be given to <link linkend="dbus-g-proxy-connect-signal"><function>dbus_g_proxy_connect_signal()</function></link>,
 which must marshal the arguments into a <link linkend="GValueArray"><type>GValueArray</type></link> and use them to call
 <link linkend="tp-proxy-signal-connection-v0-take-results"><function>tp_proxy_signal_connection_v0_take_results()</function></link>; this callback is not
 guaranteed to be called by future versions of telepathy-glib, which might
 be able to implement its functionality internally. If no arguments are
 expected at all (expected_types = { G_TYPE_INVALID }) then this callback
 should instead be <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>invoke_callback</parameter>&#160;:</term>
<listitem><simpara> a function which will be called with <parameter>error</parameter> = <link linkend="NULL--CAPS"><literal>NULL</literal></link>,
 which should invoke <parameter>callback</parameter> with <parameter>user_data</parameter>, <parameter>weak_object</parameter> and other
 appropriate arguments taken from <parameter>args</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> user callback to be invoked by <parameter>invoke_callback</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> user-supplied destructor for the data, which will be called
  when the signal connection is disconnected for any reason,
  or will be called before this function returns if an error occurs
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> if not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced by
  the signal connection - if it is destroyed, the signal connection will
  automatically be disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a signal connection structure, or <link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not
 have the desired interface or has become invalid

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-proxy-signal-connection-v0-take-results" role="function" condition="since:0.7.1">
<title>tp_proxy_signal_connection_v0_take_results ()</title>
<indexterm zone="tp-proxy-signal-connection-v0-take-results" role="0.7.1"><primary sortas="tp_proxy_signal_connection_v0_take_results">tp_proxy_signal_connection_v0_take_results</primary></indexterm><programlisting><link linkend="void">void</link>                tp_proxy_signal_connection_v0_take_results
                                                        (<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> *sc,
                                                         <link linkend="GValueArray">GValueArray</link> *args);</programlisting>
<para>
Feed the results of a signal invocation back into the signal connection
machinery.
</para>
<para>
This method should only be called from <link linkend="TpProxy"><type>TpProxy</type></link> subclass implementations,
in the callback that implements <parameter>collect_args</parameter>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>sc</parameter>&#160;:</term>
<listitem><simpara> The signal connection
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>args</parameter>&#160;:</term>
<listitem><simpara> The arguments of the signal
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>

</refsect1>



<refsect1 id="telepathy-glib-proxy-subclass.see-also">
<title>See Also</title>
#TpProxy
</refsect1>

</refentry>
