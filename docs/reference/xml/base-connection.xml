<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="TpBaseConnection">
<refmeta>
<refentrytitle role="top_of_page" id="TpBaseConnection.top_of_page">TpBaseConnection</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>TpBaseConnection</refname>
<refpurpose>base class for <link linkend="TpSvcConnection"><type>TpSvcConnection</type></link> implementations</refpurpose>
</refnamediv>

<refsynopsisdiv id="TpBaseConnection.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;telepathy-glib/base-connection.h&gt;

#define             <link linkend="TP-INTERNAL-CONNECTION-STATUS-NEW--CAPS">TP_INTERNAL_CONNECTION_STATUS_NEW</link>
                    <link linkend="TpBaseConnection-struct">TpBaseConnection</link>;
                    <link linkend="TpBaseConnectionClass">TpBaseConnectionClass</link>;
<link linkend="GPtrArray">GPtrArray</link> *         (<link linkend="TpBaseConnectionCreateChannelFactoriesImpl">*TpBaseConnectionCreateChannelFactoriesImpl</link>)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);
<link linkend="GPtrArray">GPtrArray</link> *         (<link linkend="TpBaseConnectionCreateChannelManagersImpl">*TpBaseConnectionCreateChannelManagersImpl</link>)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);
<link linkend="void">void</link>                (<link linkend="TpBaseConnectionCreateHandleReposImpl">*TpBaseConnectionCreateHandleReposImpl</link>)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repos[NUM_TP_HANDLE_TYPES]);
<link linkend="gchar">gchar</link> *             (<link linkend="TpBaseConnectionGetUniqueConnectionNameImpl">*TpBaseConnectionGetUniqueConnectionNameImpl</link>)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);
<link linkend="void">void</link>                (<link linkend="TpBaseConnectionProc">*TpBaseConnectionProc</link>)             (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);
<link linkend="gboolean">gboolean</link>            (<link linkend="TpBaseConnectionStartConnectingImpl">*TpBaseConnectionStartConnectingImpl</link>)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-base-connection-register">tp_base_connection_register</link>         (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         const <link linkend="gchar">gchar</link> *cm_name,
                                                         <link linkend="gchar">gchar</link> **bus_name,
                                                         <link linkend="gchar">gchar</link> **object_path,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> * <link linkend="tp-base-connection-get-handles">tp_base_connection_get_handles</link>      (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="TpHandleType">TpHandleType</link> handle_type);
<link linkend="TpHandle">TpHandle</link>            <link linkend="tp-base-connection-get-self-handle">tp_base_connection_get_self_handle</link>  (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);
<link linkend="void">void</link>                <link linkend="tp-base-connection-set-self-handle">tp_base_connection_set_self_handle</link>  (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> self_handle);
<link linkend="void">void</link>                <link linkend="tp-base-connection-change-status">tp_base_connection_change_status</link>    (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="TpConnectionStatus">TpConnectionStatus</link> status,
                                                         <link linkend="TpConnectionStatusReason">TpConnectionStatusReason</link> reason);
<link linkend="void">void</link>                <link linkend="tp-base-connection-disconnect-with-dbus-error">tp_base_connection_disconnect_with_dbus_error</link>
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         const <link linkend="gchar">gchar</link> *error_name,
                                                         <link linkend="GHashTable">GHashTable</link> *details,
                                                         <link linkend="TpConnectionStatusReason">TpConnectionStatusReason</link> reason);
<link linkend="void">void</link>                <link linkend="tp-base-connection-finish-shutdown">tp_base_connection_finish_shutdown</link>  (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);
<link linkend="void">void</link>                <link linkend="tp-base-connection-add-interfaces">tp_base_connection_add_interfaces</link>   (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         const <link linkend="gchar">gchar</link> **interfaces);
<link linkend="void">void</link>                <link linkend="tp-base-connection-dbus-request-handles">tp_base_connection_dbus_request_handles</link>
                                                        (<link linkend="TpSvcConnection">TpSvcConnection</link> *iface,
                                                         <link linkend="guint">guint</link> handle_type,
                                                         const <link linkend="gchar">gchar</link> **names,
                                                         <link linkend="DBusGMethodInvocation">DBusGMethodInvocation</link> *context);
#define             <link linkend="TP-BASE-CONNECTION-ERROR-IF-NOT-CONNECTED--CAPS">TP_BASE_CONNECTION_ERROR_IF_NOT_CONNECTED</link>(conn, context)
<link linkend="void">void</link>                <link linkend="tp-base-connection-register-with-contacts-mixin">tp_base_connection_register_with_contacts_mixin</link>
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);

                    <link linkend="TpChannelManagerIter">TpChannelManagerIter</link>;
<link linkend="void">void</link>                <link linkend="tp-base-connection-channel-manager-iter-init">tp_base_connection_channel_manager_iter_init</link>
                                                        (<link linkend="TpChannelManagerIter">TpChannelManagerIter</link> *iter,
                                                         <link linkend="TpBaseConnection">TpBaseConnection</link> *self);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-base-connection-channel-manager-iter-next">tp_base_connection_channel_manager_iter_next</link>
                                                        (<link linkend="TpChannelManagerIter">TpChannelManagerIter</link> *iter,
                                                         <link linkend="TpChannelManager">TpChannelManager</link> **manager_out);
</synopsis>
</refsynopsisdiv>

<refsect1 id="TpBaseConnection.object-hierarchy" role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<synopsis>
  <link linkend="GObject">GObject</link>
   +----TpBaseConnection
</synopsis>
</refsect1>



<refsect1 id="TpBaseConnection.implemented-interfaces" role="impl_interfaces">
<title role="impl_interfaces.title">Implemented Interfaces</title>
<para>
TpBaseConnection implements
 <link linkend="TpSvcConnection">TpSvcConnection</link>,  <link linkend="TpSvcDBusProperties">TpSvcDBusProperties</link> and  <link linkend="TpSvcConnectionInterfaceRequests">TpSvcConnectionInterfaceRequests</link>.</para>
</refsect1>


<refsect1 id="TpBaseConnection.properties" role="properties">
<title role="properties.title">Properties</title>
<synopsis>
  &quot;<link linkend="TpBaseConnection--protocol">protocol</link>&quot;                 <link linkend="gchar">gchar</link>*                : Read / Write / Construct Only
  &quot;<link linkend="TpBaseConnection--self-handle">self-handle</link>&quot;              <link linkend="guint">guint</link>                 : Read / Write
</synopsis>
</refsect1>

<refsect1 id="TpBaseConnection.signals" role="signal_proto">
<title role="signal_proto.title">Signals</title>
<synopsis>
  &quot;<link linkend="TpBaseConnection-shutdown-finished">shutdown-finished</link>&quot;                              : Run Last / Has Details
</synopsis>
</refsect1>


<refsect1 id="TpBaseConnection.description" role="desc">
<title role="desc.title">Description</title>
<para>
This base class makes it easier to write <link linkend="TpSvcConnection"><type>TpSvcConnection</type></link> implementations
by managing connection status, channel factories and handle tracking.
A subclass should often not need to implement any of the Connection
methods itself.
</para>
<para>
However, methods may be reimplemented if needed: for instance, Gabble
overrides RequestHandles so it can validate MUC rooms, which must be done
asynchronously.</para>
<para>
</para>
</refsect1>

<refsect1 id="TpBaseConnection.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="TP-INTERNAL-CONNECTION-STATUS-NEW--CAPS" role="macro">
<title>TP_INTERNAL_CONNECTION_STATUS_NEW</title>
<indexterm zone="TP-INTERNAL-CONNECTION-STATUS-NEW--CAPS"><primary sortas="TP_INTERNAL_CONNECTION_STATUS_NEW">TP_INTERNAL_CONNECTION_STATUS_NEW</primary></indexterm><programlisting>#   define TP_INTERNAL_CONNECTION_STATUS_NEW ((TpConnectionStatus)(-1))
</programlisting>
<para>
A special value for <link linkend="TpConnectionStatus"><type>TpConnectionStatus</type></link>, used within GLib connection
managers to indicate that the connection is disconnected because
connection has never been attempted (as distinct from disconnected
after connection has started, either by user request or an error).
</para>
<para>
Must never be visible on the D-Bus - <link linkend="TP-CONNECTION-STATUS-DISCONNECTED--CAPS"><literal>TP_CONNECTION_STATUS_DISCONNECTED</literal></link>
is sent instead.</para>
<para>
</para></refsect2>
<refsect2 id="TpBaseConnection-struct" role="struct">
<title>TpBaseConnection</title>
<indexterm zone="TpBaseConnection-struct"><primary sortas="TpBaseConnection">TpBaseConnection</primary></indexterm><programlisting>typedef struct {
    GObject parent;

    gchar *bus_name;
    gchar *object_path;

    TpConnectionStatus status;

    TpHandle self_handle;
} TpBaseConnection;
</programlisting>
<para>
Data structure representing a generic <link linkend="TpSvcConnection"><type>TpSvcConnection</type></link> implementation.
</para>
<para>
In addition to the fields documented here, there are four gpointer fields
which must currently be <link linkend="NULL--CAPS"><literal>NULL</literal></link> (a meaning may be defined for these in a
future version of telepathy-glib), and a pointer to opaque private data.</para>
<para>
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="GObject">GObject</link>&#160;<structfield>parent</structfield>;</term>
<listitem><simpara> Fields shared by the superclass.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gchar">gchar</link>&#160;*<structfield>bus_name</structfield>;</term>
<listitem><simpara> A D-Bus well-known bus name, owned by the connection manager
 process and associated with this connection. Set by
 tp_base_connection_register; should be considered read-only by subclasses.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gchar">gchar</link>&#160;*<structfield>object_path</structfield>;</term>
<listitem><simpara> The object-path of this connection. Set by
 tp_base_connection_register; should be considered read-only by subclasses.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpConnectionStatus">TpConnectionStatus</link>&#160;<structfield>status</structfield>;</term>
<listitem><simpara> Connection status - may either be a valid TpConnectionStatus or
 TP_INTERNAL_CONNECTION_STATUS_NEW. Should be considered read-only by
 subclasses: use <link linkend="tp-base-connection-change-status"><function>tp_base_connection_change_status()</function></link> to set it.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpHandle">TpHandle</link>&#160;<structfield>self_handle</structfield>;</term>
<listitem><simpara> The handle of type <link linkend="TP-HANDLE-TYPE-CONTACT--CAPS"><literal>TP_HANDLE_TYPE_CONTACT</literal></link> representing the
 local user. Must be set nonzero by the subclass before moving to state
 CONNECTED. Since 0.7.15, setting this property directly is
 deprecated, in favour of <link linkend="tp-base-connection-set-self-handle"><function>tp_base_connection_set_self_handle()</function></link>; if this
 property is set directly, the connection must ensure it holds a reference
 to the handle. Changing this property directly having moved to state
 CONNECTED is very strongly discouraged, as this will prevent the
 SelfHandleChanged signal being emitted.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpBaseConnectionClass" role="struct">
<title>TpBaseConnectionClass</title>
<indexterm zone="TpBaseConnectionClass"><primary sortas="TpBaseConnectionClass">TpBaseConnectionClass</primary></indexterm><programlisting>typedef struct {
    GObjectClass parent_class;

    TpBaseConnectionCreateHandleReposImpl create_handle_repos;

    TpBaseConnectionCreateChannelFactoriesImpl create_channel_factories;

    TpBaseConnectionGetUniqueConnectionNameImpl get_unique_connection_name;

    TpBaseConnectionProc connecting;
    TpBaseConnectionProc connected;
    TpBaseConnectionProc disconnected;

    TpBaseConnectionProc shut_down;

    TpBaseConnectionStartConnectingImpl start_connecting;

    const gchar **interfaces_always_present;

    TpBaseConnectionCreateChannelManagersImpl create_channel_managers;
} TpBaseConnectionClass;
</programlisting>
<para>
The class of a <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link>. Many members are virtual methods etc.
to be filled in in the subclass' class_init function.
</para>
<para>
In addition to the fields documented here, there are three gpointer fields
which must currently be <link linkend="NULL--CAPS"><literal>NULL</literal></link> (a meaning may be defined for these in a
future version of telepathy-glib), and a pointer to opaque private data.</para>
<para>
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="GObjectClass">GObjectClass</link>&#160;<structfield>parent_class</structfield>;</term>
<listitem><simpara> The superclass' structure
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpBaseConnectionCreateHandleReposImpl">TpBaseConnectionCreateHandleReposImpl</link>&#160;<structfield>create_handle_repos</structfield>;</term>
<listitem><simpara> Fill in suitable handle repositories in the
 given array for all those handle types this Connection supports.
 Must be set by subclasses to a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> value; the function must create
 at least a CONTACT handle repository (failing to do so will cause a crash).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpBaseConnectionCreateChannelFactoriesImpl">TpBaseConnectionCreateChannelFactoriesImpl</link>&#160;<structfield>create_channel_factories</structfield>;</term>
<listitem><simpara> Create an array of channel factories for this
 Connection. At least one of this or <parameter>create_channel_managers</parameter> must be set by
 subclasses to a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> value; in new code, setting this to <link linkend="NULL--CAPS"><literal>NULL</literal></link> and
 using channel managers exclusively is recommended.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpBaseConnectionGetUniqueConnectionNameImpl">TpBaseConnectionGetUniqueConnectionNameImpl</link>&#160;<structfield>get_unique_connection_name</structfield>;</term>
<listitem><simpara> Construct a unique name for this connection
 (for example using the protocol's format for usernames). If <link linkend="NULL--CAPS"><literal>NULL</literal></link> (the
 default), a unique name will be generated. Subclasses should usually
 override this to get more obvious names, to aid debugging and prevent
 multiple connections to the same account.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpBaseConnectionProc">TpBaseConnectionProc</link>&#160;<structfield>connecting</structfield>;</term>
<listitem><simpara> If set by subclasses, will be called just after the state
 changes to CONNECTING. May be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if nothing special needs to happen.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpBaseConnectionProc">TpBaseConnectionProc</link>&#160;<structfield>connected</structfield>;</term>
<listitem><simpara> If set by subclasses, will be called just after the state
 changes to CONNECTED. May be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if nothing special needs to happen.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpBaseConnectionProc">TpBaseConnectionProc</link>&#160;<structfield>disconnected</structfield>;</term>
<listitem><simpara> If set by subclasses, will be called just after the state
 changes to DISCONNECTED. May be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if nothing special needs to happen.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpBaseConnectionProc">TpBaseConnectionProc</link>&#160;<structfield>shut_down</structfield>;</term>
<listitem><simpara> Called after <link linkend="disconnected"><function>disconnected()</function></link> is called, to clean up the
 connection. Must start the shutdown process for the underlying
 network connection, and arrange for <link linkend="tp-base-connection-finish-shutdown"><function>tp_base_connection_finish_shutdown()</function></link>
 to be called after the underlying connection has been closed. May not
 be left as <link linkend="NULL--CAPS"><literal>NULL</literal></link>.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpBaseConnectionStartConnectingImpl">TpBaseConnectionStartConnectingImpl</link>&#160;<structfield>start_connecting</structfield>;</term>
<listitem><simpara> Asynchronously start connecting - called to implement
 the Connect D-Bus method. See <link linkend="TpBaseConnectionStartConnectingImpl"><type>TpBaseConnectionStartConnectingImpl</type></link> for
 details. May not be left as <link linkend="NULL--CAPS"><literal>NULL</literal></link>.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const&#160;<link linkend="gchar">gchar</link>&#160;**<structfield>interfaces_always_present</structfield>;</term>
<listitem><simpara> A strv of extra D-Bus interfaces which are
 always implemented by instances of this class, which may be filled in
 by subclasses. The default is to list no additional interfaces.
 Individual instances may detect which additional interfaces they support
 and signal them before going to state CONNECTED by calling
 <link linkend="tp-base-connection-add-interfaces"><function>tp_base_connection_add_interfaces()</function></link>.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="TpBaseConnectionCreateChannelManagersImpl">TpBaseConnectionCreateChannelManagersImpl</link>&#160;<structfield>create_channel_managers</structfield>;</term>
<listitem><simpara> Create an array of channel managers for this
 Connection. At least one of this or <parameter>create_channel_factories</parameter> must be set
 by subclasses to a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> value.
 Since: 0.7.15
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpBaseConnectionCreateChannelFactoriesImpl" role="function">
<title>TpBaseConnectionCreateChannelFactoriesImpl ()</title>
<indexterm zone="TpBaseConnectionCreateChannelFactoriesImpl"><primary sortas="TpBaseConnectionCreateChannelFactoriesImpl">TpBaseConnectionCreateChannelFactoriesImpl</primary></indexterm><programlisting><link linkend="GPtrArray">GPtrArray</link> *         (*TpBaseConnectionCreateChannelFactoriesImpl)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);</programlisting>
<para>
Signature of an implementation of the create_channel_factories method
of <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> The implementation, a subclass of TpBaseConnection
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a GPtrArray of objects implementing <link linkend="TpChannelFactoryIface"><type>TpChannelFactoryIface</type></link>
which, between them, implement all channel types this Connection
supports.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="TpBaseConnectionCreateChannelManagersImpl" role="function">
<title>TpBaseConnectionCreateChannelManagersImpl ()</title>
<indexterm zone="TpBaseConnectionCreateChannelManagersImpl"><primary sortas="TpBaseConnectionCreateChannelManagersImpl">TpBaseConnectionCreateChannelManagersImpl</primary></indexterm><programlisting><link linkend="GPtrArray">GPtrArray</link> *         (*TpBaseConnectionCreateChannelManagersImpl)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);</programlisting>
<para>
Signature of an implementation of the create_channel_managers method
of <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> The implementation, a subclass of TpBaseConnection
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a GPtrArray of objects implementing <link linkend="TpChannelManager"><type>TpChannelManager</type></link>
which, between them, implement all channel types this Connection
supports.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="TpBaseConnectionCreateHandleReposImpl" role="function">
<title>TpBaseConnectionCreateHandleReposImpl ()</title>
<indexterm zone="TpBaseConnectionCreateHandleReposImpl"><primary sortas="TpBaseConnectionCreateHandleReposImpl">TpBaseConnectionCreateHandleReposImpl</primary></indexterm><programlisting><link linkend="void">void</link>                (*TpBaseConnectionCreateHandleReposImpl)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repos[NUM_TP_HANDLE_TYPES]);</programlisting>
<para>
Signature of an implementation of the create_handle_repos method
of <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> The connection object
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>repos</parameter>&#160;:</term>
<listitem><simpara> An array of pointers to be filled in; the implementation
        may assume all are initially NULL.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="TpBaseConnectionGetUniqueConnectionNameImpl" role="function">
<title>TpBaseConnectionGetUniqueConnectionNameImpl ()</title>
<indexterm zone="TpBaseConnectionGetUniqueConnectionNameImpl"><primary sortas="TpBaseConnectionGetUniqueConnectionNameImpl">TpBaseConnectionGetUniqueConnectionNameImpl</primary></indexterm><programlisting><link linkend="gchar">gchar</link> *             (*TpBaseConnectionGetUniqueConnectionNameImpl)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);</programlisting>
<para>
Signature of the <parameter>get_unique_connection_name</parameter> virtual method
on <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> The implementation, a subclass of TpBaseConnection
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a name for this connection which will be unique within this
connection manager process, as a string which the caller must free
with <link linkend="g-free"><type>g_free</type></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="TpBaseConnectionProc" role="function">
<title>TpBaseConnectionProc ()</title>
<indexterm zone="TpBaseConnectionProc"><primary sortas="TpBaseConnectionProc">TpBaseConnectionProc</primary></indexterm><programlisting><link linkend="void">void</link>                (*TpBaseConnectionProc)             (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);</programlisting>
<para>
Signature of a virtual method on <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link> that takes no
additional parameters and returns nothing.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> The connection object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="TpBaseConnectionStartConnectingImpl" role="function">
<title>TpBaseConnectionStartConnectingImpl ()</title>
<indexterm zone="TpBaseConnectionStartConnectingImpl"><primary sortas="TpBaseConnectionStartConnectingImpl">TpBaseConnectionStartConnectingImpl</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            (*TpBaseConnectionStartConnectingImpl)
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Signature of an implementation of the start_connecting method
of <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link>.
</para>
<para>
On entry, the implementation may assume that it is in state NEW.
</para>
<para>
If <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned, the Connect D-Bus method succeeds; the
implementation must either have already set the status to CONNECTED by
calling <link linkend="tp-base-connection-change-status"><function>tp_base_connection_change_status()</function></link>, or have arranged for a
status change to either state DISCONNECTED or CONNECTED to be signalled by
calling <link linkend="tp-base-connection-change-status"><function>tp_base_connection_change_status()</function></link> at some later time.
If the status is still NEW after returning <link linkend="TRUE--CAPS"><literal>TRUE</literal></link>, <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link> will
automatically change it to CONNECTING for reason REQUESTED.
</para>
<para>
If <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> is returned, the error will be raised from Connect as an
exception. If the status is not DISCONNECTED after <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> is returned,
<link linkend="TpBaseConnection"><type>TpBaseConnection</type></link> will automatically change it to DISCONNECTED
with a reason appropriate to the error; NetworkError results in
NETWORK_ERROR, PermissionDenied results in AUTHENTICATION_FAILED, and all
other errors currently result in NONE_SPECIFIED.
</para>
<para>
All except the simplest connection managers are expected to implement this
asynchronously, returning <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> in most cases and changing the status
to CONNECTED or DISCONNECTED later.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> The connection object
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> Set to the error if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> if failure has already occurred, else <link linkend="TRUE--CAPS"><literal>TRUE</literal></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-base-connection-register" role="function">
<title>tp_base_connection_register ()</title>
<indexterm zone="tp-base-connection-register"><primary sortas="tp_base_connection_register">tp_base_connection_register</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_base_connection_register         (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         const <link linkend="gchar">gchar</link> *cm_name,
                                                         <link linkend="gchar">gchar</link> **bus_name,
                                                         <link linkend="gchar">gchar</link> **object_path,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Make the connection object appear on the bus, returning the bus
name and object path used. If <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned, the connection owns the
bus name, and will release it when destroyed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> A connection
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cm_name</parameter>&#160;:</term>
<listitem><simpara> The name of the connection manager in the Telepathy protocol
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>bus_name</parameter>&#160;:</term>
<listitem><simpara> Used to return the bus name corresponding to the connection
 if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned; must not be <link linkend="NULL--CAPS"><literal>NULL</literal></link>. To be freed by the caller.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>object_path</parameter>&#160;:</term>
<listitem><simpara> Used to return the object path of the connection if
 <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned; must not be <link linkend="NULL--CAPS"><literal>NULL</literal></link>. To be freed by the caller.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> Used to return an error if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> is returned; may be <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> on success, <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> on error.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-base-connection-get-handles" role="function">
<title>tp_base_connection_get_handles ()</title>
<indexterm zone="tp-base-connection-get-handles"><primary sortas="tp_base_connection_get_handles">tp_base_connection_get_handles</primary></indexterm><programlisting><link linkend="TpHandleRepoIface">TpHandleRepoIface</link> * tp_base_connection_get_handles      (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="TpHandleType">TpHandleType</link> handle_type);</programlisting>
<para>
<!----></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> A connection
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle_type</parameter>&#160;:</term>
<listitem><simpara> The handle type
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the handle repository corresponding to the given handle type,
or <link linkend="NULL--CAPS"><type>NULL</type></link> if it's unsupported or invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-base-connection-get-self-handle" role="function" condition="since:0.7.15">
<title>tp_base_connection_get_self_handle ()</title>
<indexterm zone="tp-base-connection-get-self-handle" role="0.7.15"><primary sortas="tp_base_connection_get_self_handle">tp_base_connection_get_self_handle</primary></indexterm><programlisting><link linkend="TpHandle">TpHandle</link>            tp_base_connection_get_self_handle  (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);</programlisting>
<para>
Returns the <link linkend="TpBaseConnection--self-handle"><type>"self-handle"</type></link> property, which is guaranteed not
to be 0 once the connection has moved to the CONNECTED state.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> A connection
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the current self handle of the connection.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.15</para></refsect2>
<refsect2 id="tp-base-connection-set-self-handle" role="function" condition="since:0.7.15">
<title>tp_base_connection_set_self_handle ()</title>
<indexterm zone="tp-base-connection-set-self-handle" role="0.7.15"><primary sortas="tp_base_connection_set_self_handle">tp_base_connection_set_self_handle</primary></indexterm><programlisting><link linkend="void">void</link>                tp_base_connection_set_self_handle  (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> self_handle);</programlisting>
<para>
Sets the <link linkend="TpBaseConnection--self-handle"><type>"self-handle"</type></link> property.  self_handle may not be 0
once the connection has moved to the CONNECTED state.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> A connection
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>self_handle</parameter>&#160;:</term>
<listitem><simpara> The new self handle for the connection.
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.15</para></refsect2>
<refsect2 id="tp-base-connection-change-status" role="function">
<title>tp_base_connection_change_status ()</title>
<indexterm zone="tp-base-connection-change-status"><primary sortas="tp_base_connection_change_status">tp_base_connection_change_status</primary></indexterm><programlisting><link linkend="void">void</link>                tp_base_connection_change_status    (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         <link linkend="TpConnectionStatus">TpConnectionStatus</link> status,
                                                         <link linkend="TpConnectionStatusReason">TpConnectionStatusReason</link> reason);</programlisting>
<para>
Change the status of the connection. The allowed state transitions are:
</para>
<para>
<itemizedlist>
<listitem>NEW -> CONNECTING</listitem>
<listitem>CONNECTING -> CONNECTED</listitem>
<listitem>NEW -> CONNECTED (equivalent to both of the above one after the
other - see below)</listitem>
<listitem>(anything except DISCONNECTED) -> DISCONNECTED</listitem>
</itemizedlist>
</para>
<para>
Before the transition to CONNECTED, the implementation must have discovered
the handle for the local user, obtained a reference to that handle and
stored it in the <parameter>self_handle</parameter> member of <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link>.
</para>
<para>
Changing from NEW to CONNECTED is implemented by doing the transition from
NEW to CONNECTING, followed by the transition from CONNECTING to CONNECTED;
it's exactly equivalent to calling tp_base_connection_change_status for
those two transitions one after the other.
</para>
<para>
Any other valid transition does the following, in this order:
</para>
<para>
<itemizedlist>
<listitem>Update the <parameter>status</parameter> member of <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link></listitem>
<listitem>If the new state is DISCONNECTED, call the close_all_channels
callback on all channel factories</listitem>
<listitem>Emit the D-Bus StatusChanged signal</listitem>
<listitem>Call the subclass' status change callback</listitem>
<listitem>Call the channel factories' status change callbacks</listitem>
<listitem>If the new state is DISCONNECTED, call the subclass'
<parameter>shut_down</parameter> callback</listitem>
</itemizedlist>
</para>
<para>
Changed in 0.7.35: the <parameter>self_handle</parameter> member of <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link> was
previously set to 0 at this stage. It now remains non-zero until the object
is disposed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> The connection
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status</parameter>&#160;:</term>
<listitem><simpara> The new status
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>reason</parameter>&#160;:</term>
<listitem><simpara> The reason for the status change
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-base-connection-disconnect-with-dbus-error" role="function" condition="since:0.7.24">
<title>tp_base_connection_disconnect_with_dbus_error ()</title>
<indexterm zone="tp-base-connection-disconnect-with-dbus-error" role="0.7.24"><primary sortas="tp_base_connection_disconnect_with_dbus_error">tp_base_connection_disconnect_with_dbus_error</primary></indexterm><programlisting><link linkend="void">void</link>                tp_base_connection_disconnect_with_dbus_error
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         const <link linkend="gchar">gchar</link> *error_name,
                                                         <link linkend="GHashTable">GHashTable</link> *details,
                                                         <link linkend="TpConnectionStatusReason">TpConnectionStatusReason</link> reason);</programlisting>
<para>
Change the status of the connection to <link linkend="TP-CONNECTION-STATUS-DISCONNECTED--CAPS"><literal>TP_CONNECTION_STATUS_DISCONNECTED</literal></link>,
as if by a call to <link linkend="tp-base-connection-change-status"><function>tp_base_connection_change_status()</function></link>. Before doing so,
emit the ConnectionError D-Bus signal to give more details of the error.
</para>
<para>
<parameter>details</parameter> may contain, among other entries, the well-known key
"debug-message", whose value should have type G_TYPE_STRING.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> The connection
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error_name</parameter>&#160;:</term>
<listitem><simpara> The D-Bus error with which the connection changed status to
             Disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>details</parameter>&#160;:</term>
<listitem><simpara> Further details of the error, as a hash table where the keys
          are strings as defined in the Telepathy specification, and the
          values are GValues. <link linkend="NULL--CAPS"><literal>NULL</literal></link> is allowed, and treated as empty.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>reason</parameter>&#160;:</term>
<listitem><simpara> The reason code to use in the StatusChanged signal
         (a less specific, non-extensible version of <parameter>error_name</parameter>)
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.24</para></refsect2>
<refsect2 id="tp-base-connection-finish-shutdown" role="function">
<title>tp_base_connection_finish_shutdown ()</title>
<indexterm zone="tp-base-connection-finish-shutdown"><primary sortas="tp_base_connection_finish_shutdown">tp_base_connection_finish_shutdown</primary></indexterm><programlisting><link linkend="void">void</link>                tp_base_connection_finish_shutdown  (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);</programlisting>
<para>
Tell the connection manager that this Connection has been disconnected,
has emitted StatusChanged and is ready to be removed from D-Bus.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> The connection
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-base-connection-add-interfaces" role="function">
<title>tp_base_connection_add_interfaces ()</title>
<indexterm zone="tp-base-connection-add-interfaces"><primary sortas="tp_base_connection_add_interfaces">tp_base_connection_add_interfaces</primary></indexterm><programlisting><link linkend="void">void</link>                tp_base_connection_add_interfaces   (<link linkend="TpBaseConnection">TpBaseConnection</link> *self,
                                                         const <link linkend="gchar">gchar</link> **interfaces);</programlisting>
<para>
Add some interfaces to the list supported by this Connection. If you're
going to call this function at all, you must do so before moving to state
CONNECTED (or DISCONNECTED); if you don't call it, only the set of
interfaces always present (<parameter>interfaces_always_present</parameter> in
<link linkend="TpBaseConnectionClass"><type>TpBaseConnectionClass</type></link>) will be supported.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> A TpBaseConnection in state <link linkend="TP-INTERNAL-CONNECTION-STATUS-NEW--CAPS"><type>TP_INTERNAL_CONNECTION_STATUS_NEW</type></link>
 or <link linkend="TP-CONNECTION-STATUS-CONNECTING--CAPS"><type>TP_CONNECTION_STATUS_CONNECTING</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interfaces</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="NULL--CAPS"><literal>NULL</literal></link>-terminated array of D-Bus interface names, which
 must remain valid at least until the connection enters state
 <link linkend="TP-CONNECTION-STATUS-DISCONNECTED--CAPS"><type>TP_CONNECTION_STATUS_DISCONNECTED</type></link> (in practice, you should either
 use static strings, or use strdup'd strings and free them in the dispose
 callback).
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-base-connection-dbus-request-handles" role="function">
<title>tp_base_connection_dbus_request_handles ()</title>
<indexterm zone="tp-base-connection-dbus-request-handles"><primary sortas="tp_base_connection_dbus_request_handles">tp_base_connection_dbus_request_handles</primary></indexterm><programlisting><link linkend="void">void</link>                tp_base_connection_dbus_request_handles
                                                        (<link linkend="TpSvcConnection">TpSvcConnection</link> *iface,
                                                         <link linkend="guint">guint</link> handle_type,
                                                         const <link linkend="gchar">gchar</link> **names,
                                                         <link linkend="DBusGMethodInvocation">DBusGMethodInvocation</link> *context);</programlisting>
<para>
Implements D-Bus method RequestHandles on interface
org.freedesktop.Telepathy.Connection. Exported so subclasses can
use it as a basis for their own implementations (for instance,
at the time of writing Gabble's GabbleConnection does its own processing
for room handles, in order to validate them asynchronously, but delegates
to this implementation for all other types).</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>iface</parameter>&#160;:</term>
<listitem><simpara> A pointer to <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link>, cast to a pointer to
 <link linkend="TpSvcConnection"><type>TpSvcConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle_type</parameter>&#160;:</term>
<listitem><simpara> The handle type (<link linkend="TpHandleType"><type>TpHandleType</type></link>) as a guint
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>names</parameter>&#160;:</term>
<listitem><simpara> A strv of handle names
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context</parameter>&#160;:</term>
<listitem><simpara> The dbus-glib method invocation context
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="TP-BASE-CONNECTION-ERROR-IF-NOT-CONNECTED--CAPS" role="macro">
<title>TP_BASE_CONNECTION_ERROR_IF_NOT_CONNECTED()</title>
<indexterm zone="TP-BASE-CONNECTION-ERROR-IF-NOT-CONNECTED--CAPS"><primary sortas="TP_BASE_CONNECTION_ERROR_IF_NOT_CONNECTED">TP_BASE_CONNECTION_ERROR_IF_NOT_CONNECTED</primary></indexterm><programlisting>#define             TP_BASE_CONNECTION_ERROR_IF_NOT_CONNECTED(conn, context)</programlisting>
<para>
If <parameter>conn</parameter> is not in state <link linkend="TP-CONNECTION-STATUS-CONNECTED--CAPS"><type>TP_CONNECTION_STATUS_CONNECTED</type></link>, complete the
D-Bus method invocation <parameter>context</parameter> by raising the Telepathy error
<link linkend="TP-ERROR-DISCONNECTED--CAPS"><type>TP_ERROR_DISCONNECTED</type></link>, and return from the current function (which
must be void). For use in D-Bus method implementations.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&#160;:</term>
<listitem><simpara> A TpBaseConnection
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context</parameter>&#160;:</term>
<listitem><simpara> A DBusGMethodInvocation
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-base-connection-register-with-contacts-mixin" role="function">
<title>tp_base_connection_register_with_contacts_mixin ()</title>
<indexterm zone="tp-base-connection-register-with-contacts-mixin"><primary sortas="tp_base_connection_register_with_contacts_mixin">tp_base_connection_register_with_contacts_mixin</primary></indexterm><programlisting><link linkend="void">void</link>                tp_base_connection_register_with_contacts_mixin
                                                        (<link linkend="TpBaseConnection">TpBaseConnection</link> *self);</programlisting>
<para>
Register the Connection interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> An instance of the <link linkend="TpBaseConnections"><type>TpBaseConnections</type></link> that uses the Contacts
mixin
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelManagerIter" role="struct" condition="since:0.7.15">
<title>TpChannelManagerIter</title>
<indexterm zone="TpChannelManagerIter" role="0.7.15"><primary sortas="TpChannelManagerIter">TpChannelManagerIter</primary></indexterm><programlisting>typedef struct {
} TpChannelManagerIter;
</programlisting>
<para>
An iterator over the <link linkend="TpChannelManager"><type>TpChannelManager</type></link> objects known to a <link linkend="TpBaseConnection"><type>TpBaseConnection</type></link>.
It has no public fields.</para>
<para>
</para><variablelist role="struct">
</variablelist><para role="since">Since 0.7.15</para></refsect2>
<refsect2 id="tp-base-connection-channel-manager-iter-init" role="function" condition="since:0.7.15">
<title>tp_base_connection_channel_manager_iter_init ()</title>
<indexterm zone="tp-base-connection-channel-manager-iter-init" role="0.7.15"><primary sortas="tp_base_connection_channel_manager_iter_init">tp_base_connection_channel_manager_iter_init</primary></indexterm><programlisting><link linkend="void">void</link>                tp_base_connection_channel_manager_iter_init
                                                        (<link linkend="TpChannelManagerIter">TpChannelManagerIter</link> *iter,
                                                         <link linkend="TpBaseConnection">TpBaseConnection</link> *self);</programlisting>
<para>
Initializes an iterator over the <link linkend="TpChannelManager"><type>TpChannelManager</type></link> objects known to
<parameter>self</parameter>.  It is intended to be used as followed:
</para>
<para>
<informalexample><programlisting>
TpChannelManagerIter iter;
TpChannelManager *manager;

tp_base_connection_channel_manager_iter_init (&amp;iter, base_conn);
while (tp_base_connection_channel_manager_iter_next (&amp;iter, &amp;manager))
  {
    ...do something with manager...
  }
</programlisting></informalexample></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>iter</parameter>&#160;:</term>
<listitem><simpara> an uninitialized <link linkend="TpChannelManagerIter"><type>TpChannelManagerIter</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a connection
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.15</para></refsect2>
<refsect2 id="tp-base-connection-channel-manager-iter-next" role="function" condition="since:0.7.15">
<title>tp_base_connection_channel_manager_iter_next ()</title>
<indexterm zone="tp-base-connection-channel-manager-iter-next" role="0.7.15"><primary sortas="tp_base_connection_channel_manager_iter_next">tp_base_connection_channel_manager_iter_next</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_base_connection_channel_manager_iter_next
                                                        (<link linkend="TpChannelManagerIter">TpChannelManagerIter</link> *iter,
                                                         <link linkend="TpChannelManager">TpChannelManager</link> **manager_out);</programlisting>
<para>
Advances <parameter>iter</parameter>, and retrieves the <link linkend="TpChannelManager"><type>TpChannelManager</type></link> it now points to.  If
there are no more channel managers, <parameter>manager_out</parameter> is not set and <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> is
returned.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>iter</parameter>&#160;:</term>
<listitem><simpara> an initialized <link linkend="TpChannelManagerIter"><type>TpChannelManagerIter</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>manager_out</parameter>&#160;:</term>
<listitem><simpara> a location to store the channel manager, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> if there are no more channel managers; else <link linkend="TRUE--CAPS"><literal>TRUE</literal></link>.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.15</para></refsect2>

</refsect1>
<refsect1 id="TpBaseConnection.property-details" role="property_details">
<title role="property_details.title">Property Details</title>
<refsect2 id="TpBaseConnection--protocol" role="property"><title>The <literal>&quot;protocol&quot;</literal> property</title>
<indexterm zone="TpBaseConnection--protocol"><primary sortas="TpBaseConnection:protocol">TpBaseConnection:protocol</primary></indexterm><programlisting>  &quot;protocol&quot;                 <link linkend="gchar">gchar</link>*                : Read / Write / Construct Only</programlisting>
<para>
Identifier used in the Telepathy protocol when this connection's protocol
name is required.</para>
<para>
</para><para>Default value: NULL</para>
</refsect2>
<refsect2 id="TpBaseConnection--self-handle" role="property"><title>The <literal>&quot;self-handle&quot;</literal> property</title>
<indexterm zone="TpBaseConnection--self-handle" role="0.7.15"><primary sortas="TpBaseConnection:self-handle">TpBaseConnection:self-handle</primary></indexterm><programlisting>  &quot;self-handle&quot;              <link linkend="guint">guint</link>                 : Read / Write</programlisting>
<para>
The handle of type <link linkend="TP-HANDLE-TYPE-CONTACT--CAPS"><literal>TP_HANDLE_TYPE_CONTACT</literal></link> representing the local user.
Must be set nonzero by the subclass before moving to state CONNECTED.</para>
<para>
</para><para>Default value: 0</para>
<para>Since 0.7.15</para>
</refsect2>
</refsect1>

<refsect1 id="TpBaseConnection.signal-details" role="signals">
<title role="signals.title">Signal Details</title>
<refsect2 id="TpBaseConnection-shutdown-finished" role="signal"><title>The <literal>&quot;shutdown-finished&quot;</literal> signal</title>
<indexterm zone="TpBaseConnection-shutdown-finished"><primary sortas="TpBaseConnection::shutdown-finished">TpBaseConnection::shutdown-finished</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="TpBaseConnection">TpBaseConnection</link> *arg0,
                                                        <link linkend="gpointer">gpointer</link>          user_data)      : Run Last / Has Details</programlisting>
<para>
Emitted by <link linkend="tp-base-connection-finish-shutdown"><function>tp_base_connection_finish_shutdown()</function></link> when the underlying
network connection has been closed; <link linkend="TpBaseConnectionManager"><type>TpBaseConnectionManager</type></link> listens
for this signal and removes connections from its table of active
connections when it is received.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2>
</refsect1>


<refsect1 id="TpBaseConnection.see-also">
<title>See Also</title>
#TpBaseConnectionManager, <link linkend="TpSvcConnection"><type>TpSvcConnection</type></link>
</refsect1>

</refentry>
