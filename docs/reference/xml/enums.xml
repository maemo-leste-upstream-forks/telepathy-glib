<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="telepathy-glib-enums">
<refmeta>
<refentrytitle role="top_of_page" id="telepathy-glib-enums.top_of_page">Telepathy protocol enumerations</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>Telepathy protocol enumerations</refname>
<refpurpose>Enumerated types and bitfields from the Telepathy spec</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv id="telepathy-glib-enums.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;telepathy-glib/enums.h&gt;

enum                <link linkend="TpHandleType">TpHandleType</link>;
#define             <link linkend="NUM-TP-HANDLE-TYPES:CAPS">NUM_TP_HANDLE_TYPES</link>
enum                <link linkend="TpConnMgrParamFlags">TpConnMgrParamFlags</link>;
enum                <link linkend="TpConnectionStatus">TpConnectionStatus</link>;
#define             <link linkend="NUM-TP-CONNECTION-STATUSES:CAPS">NUM_TP_CONNECTION_STATUSES</link>
enum                <link linkend="TpConnectionStatusReason">TpConnectionStatusReason</link>;
#define             <link linkend="NUM-TP-CONNECTION-STATUS-REASONS:CAPS">NUM_TP_CONNECTION_STATUS_REASONS</link>
enum                <link linkend="TpConnectionAliasFlags">TpConnectionAliasFlags</link>;
enum                <link linkend="TpConnectionCapabilityFlags">TpConnectionCapabilityFlags</link>;
enum                <link linkend="TpConnectionPresenceType">TpConnectionPresenceType</link>;
#define             <link linkend="NUM-TP-CONNECTION-PRESENCE-TYPES:CAPS">NUM_TP_CONNECTION_PRESENCE_TYPES</link>
enum                <link linkend="TpDTMFEvent">TpDTMFEvent</link>;
#define             <link linkend="NUM-TP-DTMF-EVENTS:CAPS">NUM_TP_DTMF_EVENTS</link>
enum                <link linkend="TpMediaStreamType">TpMediaStreamType</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-TYPES:CAPS">NUM_TP_MEDIA_STREAM_TYPES</link>
enum                <link linkend="TpMediaStreamState">TpMediaStreamState</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-STATES:CAPS">NUM_TP_MEDIA_STREAM_STATES</link>
enum                <link linkend="TpMediaStreamDirection">TpMediaStreamDirection</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-DIRECTIONS:CAPS">NUM_TP_MEDIA_STREAM_DIRECTIONS</link>
enum                <link linkend="TpMediaStreamPendingSend">TpMediaStreamPendingSend</link>;
enum                <link linkend="TpChannelMediaCapabilities">TpChannelMediaCapabilities</link>;
enum                <link linkend="TpChannelTextSendError">TpChannelTextSendError</link>;
#define             <link linkend="NUM-TP-CHANNEL-TEXT-SEND-ERRORS:CAPS">NUM_TP_CHANNEL_TEXT_SEND_ERRORS</link>
enum                <link linkend="TpChannelTextMessageType">TpChannelTextMessageType</link>;
#define             <link linkend="NUM-TP-CHANNEL-TEXT-MESSAGE-TYPES:CAPS">NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES</link>
enum                <link linkend="TpChannelTextMessageFlags">TpChannelTextMessageFlags</link>;
enum                <link linkend="TpChannelChatState">TpChannelChatState</link>;
#define             <link linkend="NUM-TP-CHANNEL-CHAT-STATES:CAPS">NUM_TP_CHANNEL_CHAT_STATES</link>
enum                <link linkend="TpChannelGroupFlags">TpChannelGroupFlags</link>;
enum                <link linkend="TpChannelGroupChangeReason">TpChannelGroupChangeReason</link>;
#define             <link linkend="NUM-TP-CHANNEL-GROUP-CHANGE-REASONS:CAPS">NUM_TP_CHANNEL_GROUP_CHANGE_REASONS</link>
enum                <link linkend="TpChannelPasswordFlags">TpChannelPasswordFlags</link>;
enum                <link linkend="TpMediaStreamError">TpMediaStreamError</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-ERRORS:CAPS">NUM_TP_MEDIA_STREAM_ERRORS</link>
enum                <link linkend="TpMediaStreamBaseProto">TpMediaStreamBaseProto</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-BASE-PROTOS:CAPS">NUM_TP_MEDIA_STREAM_BASE_PROTOS</link>
enum                <link linkend="TpMediaStreamTransportType">TpMediaStreamTransportType</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-TRANSPORT-TYPES:CAPS">NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES</link>
enum                <link linkend="TpPropertyFlags">TpPropertyFlags</link>;
#define             <link linkend="NUM-TP-SOCKET-ACCESS-CONTROLS:CAPS">NUM_TP_SOCKET_ACCESS_CONTROLS</link>
enum                <link linkend="TpSocketAccessControl">TpSocketAccessControl</link>;
#define             <link linkend="NUM-TP-SOCKET-ADDRESS-TYPES:CAPS">NUM_TP_SOCKET_ADDRESS_TYPES</link>
enum                <link linkend="TpSocketAddressType">TpSocketAddressType</link>;
#define             <link linkend="NUM-TP-TUBE-STATES:CAPS">NUM_TP_TUBE_STATES</link>
enum                <link linkend="TpTubeState">TpTubeState</link>;
#define             <link linkend="NUM-TP-TUBE-TYPES:CAPS">NUM_TP_TUBE_TYPES</link>
enum                <link linkend="TpTubeType">TpTubeType</link>;
enum                <link linkend="TpChannelCallStateFlags">TpChannelCallStateFlags</link>;
#define             <link linkend="NUM-TP-LOCAL-HOLD-STATES:CAPS">NUM_TP_LOCAL_HOLD_STATES</link>
enum                <link linkend="TpLocalHoldState">TpLocalHoldState</link>;
#define             <link linkend="NUM-TP-LOCAL-HOLD-STATE-REASONS:CAPS">NUM_TP_LOCAL_HOLD_STATE_REASONS</link>
enum                <link linkend="TpLocalHoldStateReason">TpLocalHoldStateReason</link>;
</synopsis>
</refsynopsisdiv>









<refsect1 id="telepathy-glib-enums.description" role="desc">
<title role="desc.title">Description</title>
<para>
This header exposes the constants from the Telepathy specification as
C enums. It is automatically generated from the specification.
</para>
<para>
The names used in the specification (e.g.
Connection_Status_Connected) are converted to upper-case and given a
TP_ prefix, e.g. TP_CONNECTION_STATUS_CONNECTED.
</para>
<para>
Each enum also has a constant for the number of members, named like
NUM_TP_CONNECTION_STATUSES. The pluralization is currently hard-coded
in the conversion scripts, but should move into the specification
in future.
</para>
<para>
Constants LAST_TP_CONNECTION_STATUS, etc. are also provided. These are
deprecated and will be removed in a future release.</para>
<para>

</para>
</refsect1>

<refsect1 id="telepathy-glib-enums.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="TpHandleType" role="enum">
<title>enum TpHandleType</title>
<indexterm zone="TpHandleType"><primary>TpHandleType</primary></indexterm><programlisting>typedef enum {
    TP_HANDLE_TYPE_NONE = 0,
    TP_HANDLE_TYPE_CONTACT = 1,
    TP_HANDLE_TYPE_ROOM = 2,
    TP_HANDLE_TYPE_LIST = 3,
    TP_HANDLE_TYPE_GROUP = 4,
} TpHandleType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-HANDLE-TYPE-NONE:CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_NONE</literal></term>
<listitem><simpara> <![CDATA[           A "null" handle type used to indicate the absence of a handle.           When a handle type and a handle appear as a pair, if the handle           type is zero, the handle must also be zero.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-HANDLE-TYPE-CONTACT:CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_CONTACT</literal></term>
<listitem><simpara> <![CDATA[           A contact         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-HANDLE-TYPE-ROOM:CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_ROOM</literal></term>
<listitem><simpara> <![CDATA[           A chat room         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-HANDLE-TYPE-LIST:CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_LIST</literal></term>
<listitem><simpara> <![CDATA[           A server-generated contact list (see Channel.Interface.Group)         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-HANDLE-TYPE-GROUP:CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_GROUP</literal></term>
<listitem><simpara> <![CDATA[           A user-defined contact list (see Channel.Interface.Group)         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-HANDLE-TYPES:CAPS" role="macro">
<title>NUM_TP_HANDLE_TYPES</title>
<indexterm zone="NUM-TP-HANDLE-TYPES:CAPS"><primary>NUM_TP_HANDLE_TYPES</primary></indexterm><programlisting>#define             NUM_TP_HANDLE_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpHandleType"><type>TpHandleType</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpConnMgrParamFlags" role="enum">
<title>enum TpConnMgrParamFlags</title>
<indexterm zone="TpConnMgrParamFlags"><primary>TpConnMgrParamFlags</primary></indexterm><programlisting>typedef enum {
    TP_CONN_MGR_PARAM_FLAG_REQUIRED = 1,
    TP_CONN_MGR_PARAM_FLAG_REGISTER = 2,
    TP_CONN_MGR_PARAM_FLAG_HAS_DEFAULT = 4,
    TP_CONN_MGR_PARAM_FLAG_SECRET = 8,
} TpConnMgrParamFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CONN-MGR-PARAM-FLAG-REQUIRED:CAPS" role="constant">
<term><literal>TP_CONN_MGR_PARAM_FLAG_REQUIRED</literal></term>
<listitem><simpara> <![CDATA[           This parameter is required for connecting to the server.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONN-MGR-PARAM-FLAG-REGISTER:CAPS" role="constant">
<term><literal>TP_CONN_MGR_PARAM_FLAG_REGISTER</literal></term>
<listitem><simpara> <![CDATA[           This parameter is required for registering an account on the           server.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONN-MGR-PARAM-FLAG-HAS-DEFAULT:CAPS" role="constant">
<term><literal>TP_CONN_MGR_PARAM_FLAG_HAS_DEFAULT</literal></term>
<listitem><simpara> <![CDATA[           This parameter has a default value, which is returned in           GetParameters; not providing this parameter is equivalent to           providing the default.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONN-MGR-PARAM-FLAG-SECRET:CAPS" role="constant">
<term><literal>TP_CONN_MGR_PARAM_FLAG_SECRET</literal></term>
<listitem><simpara> <![CDATA[           This parameter should be considered private or secret; for             instance, clients should store it in a "password safe" like             gnome-keyring or kwallet, omit it from debug logs, and use a             text input widget that hides the value of the parameter.            (Clients that support older connection managers may also treat             any parameter whose name contains "password" as though it had this             flag.)         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpConnectionStatus" role="enum">
<title>enum TpConnectionStatus</title>
<indexterm zone="TpConnectionStatus"><primary>TpConnectionStatus</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_STATUS_CONNECTED = 0,
    TP_CONNECTION_STATUS_CONNECTING = 1,
    TP_CONNECTION_STATUS_DISCONNECTED = 2,
} TpConnectionStatus;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-STATUS-CONNECTED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_CONNECTED</literal></term>
<listitem><simpara> <![CDATA[             The connection is alive and all methods are available.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-CONNECTING:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_CONNECTING</literal></term>
<listitem><simpara> <![CDATA[             The connection has not yet been established, or has been             severed and reconnection is being attempted. Some methods may fail             until the connection has been established.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-DISCONNECTED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_DISCONNECTED</literal></term>
<listitem><simpara> <![CDATA[             The connection has been severed and no method calls are             valid. The object may be removed from the bus at any time.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CONNECTION-STATUSES:CAPS" role="macro">
<title>NUM_TP_CONNECTION_STATUSES</title>
<indexterm zone="NUM-TP-CONNECTION-STATUSES:CAPS"><primary>NUM_TP_CONNECTION_STATUSES</primary></indexterm><programlisting>#define             NUM_TP_CONNECTION_STATUSES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpConnectionStatus"><type>TpConnectionStatus</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpConnectionStatusReason" role="enum">
<title>enum TpConnectionStatusReason</title>
<indexterm zone="TpConnectionStatusReason"><primary>TpConnectionStatusReason</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED = 0,
    TP_CONNECTION_STATUS_REASON_REQUESTED = 1,
    TP_CONNECTION_STATUS_REASON_NETWORK_ERROR = 2,
    TP_CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED = 3,
    TP_CONNECTION_STATUS_REASON_ENCRYPTION_ERROR = 4,
    TP_CONNECTION_STATUS_REASON_NAME_IN_USE = 5,
    TP_CONNECTION_STATUS_REASON_CERT_NOT_PROVIDED = 6,
    TP_CONNECTION_STATUS_REASON_CERT_UNTRUSTED = 7,
    TP_CONNECTION_STATUS_REASON_CERT_EXPIRED = 8,
    TP_CONNECTION_STATUS_REASON_CERT_NOT_ACTIVATED = 9,
    TP_CONNECTION_STATUS_REASON_CERT_HOSTNAME_MISMATCH = 10,
    TP_CONNECTION_STATUS_REASON_CERT_FINGERPRINT_MISMATCH = 11,
    TP_CONNECTION_STATUS_REASON_CERT_SELF_SIGNED = 12,
    TP_CONNECTION_STATUS_REASON_CERT_OTHER_ERROR = 13,
} TpConnectionStatusReason;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-STATUS-REASON-NONE-SPECIFIED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED</literal></term>
<listitem><simpara> <![CDATA[             There is no reason set for this state change.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-REQUESTED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_REQUESTED</literal></term>
<listitem><simpara> <![CDATA[             The change is in response to a user request.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-NETWORK-ERROR:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_NETWORK_ERROR</literal></term>
<listitem><simpara> <![CDATA[             There was an error sending or receiving on the network socket.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-AUTHENTICATION-FAILED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED</literal></term>
<listitem><simpara> <![CDATA[             The username or password was invalid.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-ENCRYPTION-ERROR:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_ENCRYPTION_ERROR</literal></term>
<listitem><simpara> <![CDATA[             There was an error negotiating SSL on this connection, or             encryption was unavailable and require-encryption was set when the             connection was created.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-NAME-IN-USE:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_NAME_IN_USE</literal></term>
<listitem><simpara> <![CDATA[             Someone is already connected to the server using the name             you are trying to connect with.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-NOT-PROVIDED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_NOT_PROVIDED</literal></term>
<listitem><simpara> <![CDATA[             The server did not provide a SSL certificate.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-UNTRUSTED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_UNTRUSTED</literal></term>
<listitem><simpara> <![CDATA[             The server's SSL certificate could not be trusted.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-EXPIRED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_EXPIRED</literal></term>
<listitem><simpara> <![CDATA[             The server's SSL certificate has expired.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-NOT-ACTIVATED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_NOT_ACTIVATED</literal></term>
<listitem><simpara> <![CDATA[             The server's SSL certificate is not yet valid.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-HOSTNAME-MISMATCH:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_HOSTNAME_MISMATCH</literal></term>
<listitem><simpara> <![CDATA[             The server's SSL certificate did not match its hostname.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-FINGERPRINT-MISMATCH:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_FINGERPRINT_MISMATCH</literal></term>
<listitem><simpara> <![CDATA[             The server's SSL certificate does not have the expected             fingerprint.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-SELF-SIGNED:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_SELF_SIGNED</literal></term>
<listitem><simpara> <![CDATA[             The server's SSL certificate is self-signed.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-OTHER-ERROR:CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_OTHER_ERROR</literal></term>
<listitem><simpara> <![CDATA[             There was some other error validating the server's SSL certificate.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CONNECTION-STATUS-REASONS:CAPS" role="macro">
<title>NUM_TP_CONNECTION_STATUS_REASONS</title>
<indexterm zone="NUM-TP-CONNECTION-STATUS-REASONS:CAPS"><primary>NUM_TP_CONNECTION_STATUS_REASONS</primary></indexterm><programlisting>#define             NUM_TP_CONNECTION_STATUS_REASONS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpConnectionStatusReason"><type>TpConnectionStatusReason</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpConnectionAliasFlags" role="enum">
<title>enum TpConnectionAliasFlags</title>
<indexterm zone="TpConnectionAliasFlags"><primary>TpConnectionAliasFlags</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_ALIAS_FLAG_USER_SET = 1,
} TpConnectionAliasFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-ALIAS-FLAG-USER-SET:CAPS" role="constant">
<term><literal>TP_CONNECTION_ALIAS_FLAG_USER_SET</literal></term>
<listitem><simpara> <![CDATA[           The aliases of contacts on this connection may be changed by the             user of the service, not just by the contacts themselves. This is             the case on Jabber, for instance.           It is possible that aliases can be changed by the contacts too -             which alias takes precedence is not defined by this             specification, and depends on the server and/or connection manager             implementation.           This flag only applies to the aliases of "globally valid" contact             handles. At this time, clients should not expect to be able to             change the aliases corresponding to any channel-specific             handles. If this becomes possible in future, a new flag will             be defined.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpConnectionCapabilityFlags" role="enum">
<title>enum TpConnectionCapabilityFlags</title>
<indexterm zone="TpConnectionCapabilityFlags"><primary>TpConnectionCapabilityFlags</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_CAPABILITY_FLAG_CREATE = 1,
    TP_CONNECTION_CAPABILITY_FLAG_INVITE = 2,
} TpConnectionCapabilityFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-CAPABILITY-FLAG-CREATE:CAPS" role="constant">
<term><literal>TP_CONNECTION_CAPABILITY_FLAG_CREATE</literal></term>
<listitem><simpara> <![CDATA[           The given channel type and handle can be given to RequestChannel to           create a new channel of this type.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-CAPABILITY-FLAG-INVITE:CAPS" role="constant">
<term><literal>TP_CONNECTION_CAPABILITY_FLAG_INVITE</literal></term>
<listitem><simpara> <![CDATA[           The given contact can be invited to an existing channel of this type.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpConnectionPresenceType" role="enum">
<title>enum TpConnectionPresenceType</title>
<indexterm zone="TpConnectionPresenceType"><primary>TpConnectionPresenceType</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_PRESENCE_TYPE_UNSET = 0,
    TP_CONNECTION_PRESENCE_TYPE_OFFLINE = 1,
    TP_CONNECTION_PRESENCE_TYPE_AVAILABLE = 2,
    TP_CONNECTION_PRESENCE_TYPE_AWAY = 3,
    TP_CONNECTION_PRESENCE_TYPE_EXTENDED_AWAY = 4,
    TP_CONNECTION_PRESENCE_TYPE_HIDDEN = 5,
    TP_CONNECTION_PRESENCE_TYPE_BUSY = 6,
    TP_CONNECTION_PRESENCE_TYPE_UNKNOWN = 7,
    TP_CONNECTION_PRESENCE_TYPE_ERROR = 8,
} TpConnectionPresenceType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-UNSET:CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_UNSET</literal></term>
<listitem><simpara> <![CDATA[           An invalid presence type used as a null value. This value MUST NOT           appear in the result of GetStatuses, or in the Statuses property           of the SimplePresence interface.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-OFFLINE:CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_OFFLINE</literal></term>
<listitem><simpara> <![CDATA[           Offline         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-AVAILABLE:CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_AVAILABLE</literal></term>
<listitem><simpara> <![CDATA[           Available         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-AWAY:CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_AWAY</literal></term>
<listitem><simpara> <![CDATA[           Away         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-EXTENDED-AWAY:CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_EXTENDED_AWAY</literal></term>
<listitem><simpara> <![CDATA[           Away for an extended time         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-HIDDEN:CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_HIDDEN</literal></term>
<listitem><simpara> <![CDATA[           Hidden (invisible)         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-BUSY:CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_BUSY</literal></term>
<listitem><simpara> <![CDATA[           Busy, Do Not Disturb.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-UNKNOWN:CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_UNKNOWN</literal></term>
<listitem><simpara> <![CDATA[           Unknown, unable to determine presence for this contact, for example           if the protocol only allows presence of subscribed contacts.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-ERROR:CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_ERROR</literal></term>
<listitem><simpara> <![CDATA[           Error, an error occurred while trying to determine presence.  The           message, if set, is an error from the server.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CONNECTION-PRESENCE-TYPES:CAPS" role="macro">
<title>NUM_TP_CONNECTION_PRESENCE_TYPES</title>
<indexterm zone="NUM-TP-CONNECTION-PRESENCE-TYPES:CAPS"><primary>NUM_TP_CONNECTION_PRESENCE_TYPES</primary></indexterm><programlisting>#define             NUM_TP_CONNECTION_PRESENCE_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpConnectionPresenceType"><type>TpConnectionPresenceType</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpDTMFEvent" role="enum">
<title>enum TpDTMFEvent</title>
<indexterm zone="TpDTMFEvent"><primary>TpDTMFEvent</primary></indexterm><programlisting>typedef enum {
    TP_DTMF_EVENT_DIGIT_0 = 0,
    TP_DTMF_EVENT_DIGIT_1 = 1,
    TP_DTMF_EVENT_DIGIT_2 = 2,
    TP_DTMF_EVENT_DIGIT_3 = 3,
    TP_DTMF_EVENT_DIGIT_4 = 4,
    TP_DTMF_EVENT_DIGIT_5 = 5,
    TP_DTMF_EVENT_DIGIT_6 = 6,
    TP_DTMF_EVENT_DIGIT_7 = 7,
    TP_DTMF_EVENT_DIGIT_8 = 8,
    TP_DTMF_EVENT_DIGIT_9 = 9,
    TP_DTMF_EVENT_ASTERISK = 10,
    TP_DTMF_EVENT_HASH = 11,
    TP_DTMF_EVENT_LETTER_A = 12,
    TP_DTMF_EVENT_LETTER_B = 13,
    TP_DTMF_EVENT_LETTER_C = 14,
    TP_DTMF_EVENT_LETTER_D = 15,
} TpDTMFEvent;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-DTMF-EVENT-DIGIT-0:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_0</literal></term>
<listitem><simpara> <![CDATA[0]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-1:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_1</literal></term>
<listitem><simpara> <![CDATA[1]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-2:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_2</literal></term>
<listitem><simpara> <![CDATA[2]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-3:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_3</literal></term>
<listitem><simpara> <![CDATA[3]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-4:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_4</literal></term>
<listitem><simpara> <![CDATA[4]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-5:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_5</literal></term>
<listitem><simpara> <![CDATA[5]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-6:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_6</literal></term>
<listitem><simpara> <![CDATA[6]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-7:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_7</literal></term>
<listitem><simpara> <![CDATA[7]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-8:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_8</literal></term>
<listitem><simpara> <![CDATA[8]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-9:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_9</literal></term>
<listitem><simpara> <![CDATA[9]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-ASTERISK:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_ASTERISK</literal></term>
<listitem><simpara> <![CDATA[*]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-HASH:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_HASH</literal></term>
<listitem><simpara> <![CDATA[#]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-LETTER-A:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_LETTER_A</literal></term>
<listitem><simpara> <![CDATA[A]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-LETTER-B:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_LETTER_B</literal></term>
<listitem><simpara> <![CDATA[B]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-LETTER-C:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_LETTER_C</literal></term>
<listitem><simpara> <![CDATA[C]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-LETTER-D:CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_LETTER_D</literal></term>
<listitem><simpara> <![CDATA[D]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-DTMF-EVENTS:CAPS" role="macro">
<title>NUM_TP_DTMF_EVENTS</title>
<indexterm zone="NUM-TP-DTMF-EVENTS:CAPS"><primary>NUM_TP_DTMF_EVENTS</primary></indexterm><programlisting>#define             NUM_TP_DTMF_EVENTS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpDTMFEvent"><type>TpDTMFEvent</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpMediaStreamType" role="enum">
<title>enum TpMediaStreamType</title>
<indexterm zone="TpMediaStreamType"><primary>TpMediaStreamType</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_TYPE_AUDIO = 0,
    TP_MEDIA_STREAM_TYPE_VIDEO = 1,
} TpMediaStreamType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-TYPE-AUDIO:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TYPE_AUDIO</literal></term>
<listitem><simpara> <![CDATA[An audio stream]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-TYPE-VIDEO:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TYPE_VIDEO</literal></term>
<listitem><simpara> <![CDATA[A video stream]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-TYPES:CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_TYPES</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-TYPES:CAPS"><primary>NUM_TP_MEDIA_STREAM_TYPES</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamType"><type>TpMediaStreamType</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpMediaStreamState" role="enum">
<title>enum TpMediaStreamState</title>
<indexterm zone="TpMediaStreamState"><primary>TpMediaStreamState</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_STATE_DISCONNECTED = 0,
    TP_MEDIA_STREAM_STATE_CONNECTING = 1,
    TP_MEDIA_STREAM_STATE_CONNECTED = 2,
} TpMediaStreamState;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-STATE-DISCONNECTED:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_STATE_DISCONNECTED</literal></term>
<listitem><simpara> <![CDATA[The stream is disconnected.]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-STATE-CONNECTING:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_STATE_CONNECTING</literal></term>
<listitem><simpara> <![CDATA[The stream is trying to connect.]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-STATE-CONNECTED:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_STATE_CONNECTED</literal></term>
<listitem><simpara> <![CDATA[The stream is connected.]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-STATES:CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_STATES</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-STATES:CAPS"><primary>NUM_TP_MEDIA_STREAM_STATES</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamState"><type>TpMediaStreamState</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpMediaStreamDirection" role="enum">
<title>enum TpMediaStreamDirection</title>
<indexterm zone="TpMediaStreamDirection"><primary>TpMediaStreamDirection</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_DIRECTION_NONE = 0,
    TP_MEDIA_STREAM_DIRECTION_SEND = 1,
    TP_MEDIA_STREAM_DIRECTION_RECEIVE = 2,
    TP_MEDIA_STREAM_DIRECTION_BIDIRECTIONAL = 3,
} TpMediaStreamDirection;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-DIRECTION-NONE:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_DIRECTION_NONE</literal></term>
<listitem><simpara> <![CDATA[Media are not being sent or received]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-DIRECTION-SEND:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_DIRECTION_SEND</literal></term>
<listitem><simpara> <![CDATA[Media are being sent, but not received]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-DIRECTION-RECEIVE:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_DIRECTION_RECEIVE</literal></term>
<listitem><simpara> <![CDATA[Media are being received, but not sent]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-DIRECTION-BIDIRECTIONAL:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_DIRECTION_BIDIRECTIONAL</literal></term>
<listitem><simpara> <![CDATA[Media are being sent and received]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-DIRECTIONS:CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_DIRECTIONS</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-DIRECTIONS:CAPS"><primary>NUM_TP_MEDIA_STREAM_DIRECTIONS</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_DIRECTIONS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamDirection"><type>TpMediaStreamDirection</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpMediaStreamPendingSend" role="enum">
<title>enum TpMediaStreamPendingSend</title>
<indexterm zone="TpMediaStreamPendingSend"><primary>TpMediaStreamPendingSend</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_PENDING_LOCAL_SEND = 1,
    TP_MEDIA_STREAM_PENDING_REMOTE_SEND = 2,
} TpMediaStreamPendingSend;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-PENDING-LOCAL-SEND:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_PENDING_LOCAL_SEND</literal></term>
<listitem><simpara> <![CDATA[             The local user has been asked to send media by the remote user.             Call RequestStreamDirection to indicate whether or not this is             acceptable.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-PENDING-REMOTE-SEND:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_PENDING_REMOTE_SEND</literal></term>
<listitem><simpara> <![CDATA[             The remote user has been asked to send media by the local user.             The StreamDirectionChanged signal will be emitted when the remote             user accepts or rejects this change.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelMediaCapabilities" role="enum">
<title>enum TpChannelMediaCapabilities</title>
<indexterm zone="TpChannelMediaCapabilities"><primary>TpChannelMediaCapabilities</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_MEDIA_CAPABILITY_AUDIO = 1,
    TP_CHANNEL_MEDIA_CAPABILITY_VIDEO = 2,
    TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_STUN = 4,
    TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_GTALK_P2P = 8,
} TpChannelMediaCapabilities;
</programlisting>
<para>
<![CDATA[         The channel-type-specific capability flags used for         Channel.Type.StreamedMedia in the Connection.Interface.Capabilities         interface.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-AUDIO:CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_AUDIO</literal></term>
<listitem><simpara> <![CDATA[           The handle is capable of using audio streams within a media channel.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-VIDEO:CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_VIDEO</literal></term>
<listitem><simpara> <![CDATA[           The handle is capable of using video streams within a media channel.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-NAT-TRAVERSAL-STUN:CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_STUN</literal></term>
<listitem><simpara> <![CDATA[           The handle is capable of performing STUN to traverse NATs.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-NAT-TRAVERSAL-GTALK-P2P:CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_GTALK_P2P</literal></term>
<listitem><simpara> <![CDATA[           The handle is capable of establishing Google Talk peer-to-peer           connections (as implemented in libjingle 0.3) to traverse NATs.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelTextSendError" role="enum">
<title>enum TpChannelTextSendError</title>
<indexterm zone="TpChannelTextSendError"><primary>TpChannelTextSendError</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_TEXT_SEND_ERROR_UNKNOWN = 0,
    TP_CHANNEL_TEXT_SEND_ERROR_OFFLINE = 1,
    TP_CHANNEL_TEXT_SEND_ERROR_INVALID_CONTACT = 2,
    TP_CHANNEL_TEXT_SEND_ERROR_PERMISSION_DENIED = 3,
    TP_CHANNEL_TEXT_SEND_ERROR_TOO_LONG = 4,
    TP_CHANNEL_TEXT_SEND_ERROR_NOT_IMPLEMENTED = 5,
} TpChannelTextSendError;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-UNKNOWN:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_UNKNOWN</literal></term>
<listitem><simpara> <![CDATA[         An unknown error occurred         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-OFFLINE:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_OFFLINE</literal></term>
<listitem><simpara> <![CDATA[         The requested contact was offline         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-INVALID-CONTACT:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_INVALID_CONTACT</literal></term>
<listitem><simpara> <![CDATA[         The requested contact is not valid         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-PERMISSION-DENIED:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_PERMISSION_DENIED</literal></term>
<listitem><simpara> <![CDATA[         The user does not have permission to speak on this channel         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-TOO-LONG:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_TOO_LONG</literal></term>
<listitem><simpara> <![CDATA[         The outgoing message was too long and was rejected by the server         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-NOT-IMPLEMENTED:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_NOT_IMPLEMENTED</literal></term>
<listitem><simpara> <![CDATA[         The channel doesn't support sending text messages to the requested         contact         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CHANNEL-TEXT-SEND-ERRORS:CAPS" role="macro">
<title>NUM_TP_CHANNEL_TEXT_SEND_ERRORS</title>
<indexterm zone="NUM-TP-CHANNEL-TEXT-SEND-ERRORS:CAPS"><primary>NUM_TP_CHANNEL_TEXT_SEND_ERRORS</primary></indexterm><programlisting>#define             NUM_TP_CHANNEL_TEXT_SEND_ERRORS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpChannelTextSendError"><type>TpChannelTextSendError</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpChannelTextMessageType" role="enum">
<title>enum TpChannelTextMessageType</title>
<indexterm zone="TpChannelTextMessageType"><primary>TpChannelTextMessageType</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_TEXT_MESSAGE_TYPE_NORMAL = 0,
    TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION = 1,
    TP_CHANNEL_TEXT_MESSAGE_TYPE_NOTICE = 2,
    TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY = 3,
    TP_CHANNEL_TEXT_MESSAGE_TYPE_DELIVERY_REPORT = 4,
} TpChannelTextMessageType;
</programlisting>
<para>
<![CDATA[         The type of message.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-NORMAL:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_NORMAL</literal></term>
<listitem><simpara> <![CDATA[         An ordinary chat message. Unknown types SHOULD be treated like this.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-ACTION:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION</literal></term>
<listitem><simpara> <![CDATA[         An action which might be presented to the user as         "* <sender> <action>", such as an IRC CTCP         ACTION (typically selected by the "/me" command). For example, the         text of the message might be "drinks more coffee".         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-NOTICE:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_NOTICE</literal></term>
<listitem><simpara> <![CDATA[         A one-off or automated message not necessarily expecting a reply         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-AUTO-REPLY:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY</literal></term>
<listitem><simpara> <![CDATA[         An automatically-generated reply message.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-DELIVERY-REPORT:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_DELIVERY_REPORT</literal></term>
<listitem><simpara> <![CDATA[           This message type MUST NOT appear unless the channel supports the           DeliveryReporting interface. The message MUST be as defined by           the DeliveryReporting interface.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CHANNEL-TEXT-MESSAGE-TYPES:CAPS" role="macro">
<title>NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES</title>
<indexterm zone="NUM-TP-CHANNEL-TEXT-MESSAGE-TYPES:CAPS"><primary>NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES</primary></indexterm><programlisting>#define             NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpChannelTextMessageType"><type>TpChannelTextMessageType</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpChannelTextMessageFlags" role="enum">
<title>enum TpChannelTextMessageFlags</title>
<indexterm zone="TpChannelTextMessageFlags"><primary>TpChannelTextMessageFlags</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_TEXT_MESSAGE_FLAG_TRUNCATED = 1,
    TP_CHANNEL_TEXT_MESSAGE_FLAG_NON_TEXT_CONTENT = 2,
    TP_CHANNEL_TEXT_MESSAGE_FLAG_SCROLLBACK = 4,
    TP_CHANNEL_TEXT_MESSAGE_FLAG_RESCUED = 8,
} TpChannelTextMessageFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-FLAG-TRUNCATED:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_FLAG_TRUNCATED</literal></term>
<listitem><simpara> <![CDATA[         The incoming message was truncated to a shorter length by the         server or the connection manager.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-FLAG-NON-TEXT-CONTENT:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_FLAG_NON_TEXT_CONTENT</literal></term>
<listitem><simpara> <![CDATA[           The incoming message contained non-text content which cannot be             represented by this interface, but has been signalled             in the Messages interface.            Connection managers SHOULD only set this flag if the non-text             content appears to be relatively significant (exactly how             significant is up to the implementor). The intention is that             if this flag is set, clients using this interface SHOULD inform             the user that part of the message was not understood.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-FLAG-SCROLLBACK:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_FLAG_SCROLLBACK</literal></term>
<listitem><simpara> <![CDATA[           The incoming message was part of a replay of message history.                         In XMPP multi-user chat, a few past messages are replayed               when you join a chatroom. A sufficiently capable IRC connection               manager could also set this flag on historical messages when               connected to a proxy like bip or irssi-proxy. The existence               of this flag allows loggers and UIs to use better heuristics               when eliminating duplicates (a simple implementation made               possible by this flag would be to avoid logging scrollback               at all).                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-FLAG-RESCUED:CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_FLAG_RESCUED</literal></term>
<listitem><simpara> <![CDATA[           The incoming message has been seen in a previous channel during             the lifetime of the Connection, but had not been acknowledged             when that channel closed, causing an identical channel (the             channel in which the message now appears) to open.                         This means that a logger (which should already have seen the               message in the previous channel) is able to recognise and ignore               these replayed messages.                    ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelChatState" role="enum">
<title>enum TpChannelChatState</title>
<indexterm zone="TpChannelChatState"><primary>TpChannelChatState</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_CHAT_STATE_GONE = 0,
    TP_CHANNEL_CHAT_STATE_INACTIVE = 1,
    TP_CHANNEL_CHAT_STATE_ACTIVE = 2,
    TP_CHANNEL_CHAT_STATE_PAUSED = 3,
    TP_CHANNEL_CHAT_STATE_COMPOSING = 4,
} TpChannelChatState;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-CHAT-STATE-GONE:CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_GONE</literal></term>
<listitem><simpara> <![CDATA[         The contact has effectively ceased participating in the chat.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CHAT-STATE-INACTIVE:CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_INACTIVE</literal></term>
<listitem><simpara> <![CDATA[         The contact has not been active for some time.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CHAT-STATE-ACTIVE:CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_ACTIVE</literal></term>
<listitem><simpara> <![CDATA[         The contact is actively participating in the chat.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CHAT-STATE-PAUSED:CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_PAUSED</literal></term>
<listitem><simpara> <![CDATA[         The contact has paused composing a message.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CHAT-STATE-COMPOSING:CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_COMPOSING</literal></term>
<listitem><simpara> <![CDATA[         The contact is composing a message to be sent to the chat.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CHANNEL-CHAT-STATES:CAPS" role="macro">
<title>NUM_TP_CHANNEL_CHAT_STATES</title>
<indexterm zone="NUM-TP-CHANNEL-CHAT-STATES:CAPS"><primary>NUM_TP_CHANNEL_CHAT_STATES</primary></indexterm><programlisting>#define             NUM_TP_CHANNEL_CHAT_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpChannelChatState"><type>TpChannelChatState</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpChannelGroupFlags" role="enum">
<title>enum TpChannelGroupFlags</title>
<indexterm zone="TpChannelGroupFlags"><primary>TpChannelGroupFlags</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_GROUP_FLAG_CAN_ADD = 1,
    TP_CHANNEL_GROUP_FLAG_CAN_REMOVE = 2,
    TP_CHANNEL_GROUP_FLAG_CAN_RESCIND = 4,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_ADD = 8,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_REMOVE = 16,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT = 32,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_REJECT = 64,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_RESCIND = 128,
    TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES = 256,
    TP_CHANNEL_GROUP_FLAG_ONLY_ONE_GROUP = 512,
    TP_CHANNEL_GROUP_FLAG_HANDLE_OWNERS_NOT_AVAILABLE = 1024,
    TP_CHANNEL_GROUP_FLAG_PROPERTIES = 2048,
} TpChannelGroupFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-GROUP-FLAG-CAN-ADD:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_CAN_ADD</literal></term>
<listitem><simpara> <![CDATA[             The AddMembers method can be used to add or invite members who are             not already in the local pending list (which is always valid).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-CAN-REMOVE:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_CAN_REMOVE</literal></term>
<listitem><simpara> <![CDATA[             The RemoveMembers method can be used to remove channel members             (removing those on the pending local list is always valid).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-CAN-RESCIND:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_CAN_RESCIND</literal></term>
<listitem><simpara> <![CDATA[             The RemoveMembers method can be used on people on the remote             pending list.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-ADD:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_ADD</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling AddMembers on             contacts who are not currently pending members.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-REMOVE:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_REMOVE</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling RemoveMembers on             contacts who are currently channel members.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-ACCEPT:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling AddMembers on             contacts who are locally pending.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-REJECT:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_REJECT</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling RemoveMembers on             contacts who are locally pending.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-RESCIND:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_RESCIND</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling RemoveMembers on             contacts who are remote pending.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-CHANNEL-SPECIFIC-HANDLES:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES</literal></term>
<listitem><simpara> <![CDATA[                        The members of this group have handles which are specific to             this channel, and are not valid as general-purpose handles on             the connection. Depending on the channel, it may be possible to             call GetHandleOwners to find the owners of these handles, which             should be done if you wish to eg subscribe to the contact's             presence.                                    Connection managers must ensure that any given handle is not             simultaneously a general-purpose handle and a channel-specific             handle.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-ONLY-ONE-GROUP:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_ONLY_ONE_GROUP</literal></term>
<listitem><simpara> <![CDATA[             Placing a contact in multiple groups of this type is not allowed             and will raise NotAvailable (on services where contacts may only             be in one user-defined group, user-defined groups will have             this flag).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-HANDLE-OWNERS-NOT-AVAILABLE:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_HANDLE_OWNERS_NOT_AVAILABLE</literal></term>
<listitem><simpara> <![CDATA[           In rooms with channel specific handles (ie Channel_Specific_Handles           flag is set), this flag indicates that no handle owners are           available, apart from the owner of the SelfHandle.                         This used to be an important optimization to avoid repeated             GetHandleOwners calls, before we introduced the HandleOwner             property and HandleOwnerChanged signal.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-PROPERTIES:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_PROPERTIES</literal></term>
<listitem><simpara> <![CDATA[           This flag indicates that all the properties introduced in           specification 0.17.6 are fully supported.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelGroupChangeReason" role="enum">
<title>enum TpChannelGroupChangeReason</title>
<indexterm zone="TpChannelGroupChangeReason"><primary>TpChannelGroupChangeReason</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_GROUP_CHANGE_REASON_NONE = 0,
    TP_CHANNEL_GROUP_CHANGE_REASON_OFFLINE = 1,
    TP_CHANNEL_GROUP_CHANGE_REASON_KICKED = 2,
    TP_CHANNEL_GROUP_CHANGE_REASON_BUSY = 3,
    TP_CHANNEL_GROUP_CHANGE_REASON_INVITED = 4,
    TP_CHANNEL_GROUP_CHANGE_REASON_BANNED = 5,
    TP_CHANNEL_GROUP_CHANGE_REASON_ERROR = 6,
    TP_CHANNEL_GROUP_CHANGE_REASON_INVALID_CONTACT = 7,
    TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER = 8,
    TP_CHANNEL_GROUP_CHANGE_REASON_RENAMED = 9,
    TP_CHANNEL_GROUP_CHANGE_REASON_PERMISSION_DENIED = 10,
    TP_CHANNEL_GROUP_CHANGE_REASON_SEPARATED = 11,
} TpChannelGroupChangeReason;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-NONE:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_NONE</literal></term>
<listitem><simpara> <![CDATA[             No reason was provided for this change.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-OFFLINE:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_OFFLINE</literal></term>
<listitem><simpara> <![CDATA[             The change is due to a user going offline. Also used when             user is already offline, but this wasn't known previously.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-KICKED:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_KICKED</literal></term>
<listitem><simpara> <![CDATA[             The change is due to a kick operation.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-BUSY:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_BUSY</literal></term>
<listitem><simpara> <![CDATA[             The change is due to a busy indication.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-INVITED:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_INVITED</literal></term>
<listitem><simpara> <![CDATA[             The change is due to an invitation.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-BANNED:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_BANNED</literal></term>
<listitem><simpara> <![CDATA[             The change is due to a kick+ban operation.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-ERROR:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_ERROR</literal></term>
<listitem><simpara> <![CDATA[             The change is due to an error occurring.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-INVALID-CONTACT:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_INVALID_CONTACT</literal></term>
<listitem><simpara> <![CDATA[             The change is because the requested contact does not exist.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-NO-ANSWER:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER</literal></term>
<listitem><simpara> <![CDATA[             The change is because the requested contact did not respond.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-RENAMED:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_RENAMED</literal></term>
<listitem><simpara> <![CDATA[           The change is because a contact's unique identifier changed.           There must be exactly one handle in the removed set and exactly           one handle in one of the added sets. The Renamed signal on the           Renaming interface will have been emitted for the same handles,           shortly before this MembersChanged signal is emitted.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-PERMISSION-DENIED:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_PERMISSION_DENIED</literal></term>
<listitem><simpara> <![CDATA[             The change is because there was no permission to contact the             requested handle.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-SEPARATED:CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_SEPARATED</literal></term>
<listitem><simpara> <![CDATA[           If members are removed with this reason code, the change is             because the group has split into unconnected parts which can only             communicate within themselves (e.g. netsplits on IRC use this             reason code).                                   If members are added with this reason code, the change is because             unconnected parts of the group have rejoined. If this channel             carries messages (e.g. Text or Tubes channels) applications must             assume that the contacts being added are likely to have missed some             messages as a result of the separation, and that the contacts             in the group are likely to have missed some messages from the             contacts being added.                      Note that from the added contacts' perspective, they have been             in the group all along, and the contacts we indicate to be in             the group (including the local user) have just rejoined             the group with reason Separated. Application protocols in Tubes             should be prepared to cope with this situation.                    ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CHANNEL-GROUP-CHANGE-REASONS:CAPS" role="macro">
<title>NUM_TP_CHANNEL_GROUP_CHANGE_REASONS</title>
<indexterm zone="NUM-TP-CHANNEL-GROUP-CHANGE-REASONS:CAPS"><primary>NUM_TP_CHANNEL_GROUP_CHANGE_REASONS</primary></indexterm><programlisting>#define             NUM_TP_CHANNEL_GROUP_CHANGE_REASONS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpChannelGroupChangeReason"><type>TpChannelGroupChangeReason</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpChannelPasswordFlags" role="enum">
<title>enum TpChannelPasswordFlags</title>
<indexterm zone="TpChannelPasswordFlags"><primary>TpChannelPasswordFlags</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_PASSWORD_FLAG_PROVIDE = 8,
} TpChannelPasswordFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-PASSWORD-FLAG-PROVIDE:CAPS" role="constant">
<term><literal>TP_CHANNEL_PASSWORD_FLAG_PROVIDE</literal></term>
<listitem><simpara> <![CDATA[           The ProvidePassword method must be called now for the user to join           the channel         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpMediaStreamError" role="enum">
<title>enum TpMediaStreamError</title>
<indexterm zone="TpMediaStreamError"><primary>TpMediaStreamError</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_ERROR_UNKNOWN = 0,
    TP_MEDIA_STREAM_ERROR_EOS = 1,
} TpMediaStreamError;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-ERROR-UNKNOWN:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_UNKNOWN</literal></term>
<listitem><simpara> <![CDATA[         An unknown error occured.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-ERROR-EOS:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_EOS</literal></term>
<listitem><simpara> <![CDATA[         The end of the stream was reached.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-ERRORS:CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_ERRORS</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-ERRORS:CAPS"><primary>NUM_TP_MEDIA_STREAM_ERRORS</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_ERRORS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamError"><type>TpMediaStreamError</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpMediaStreamBaseProto" role="enum">
<title>enum TpMediaStreamBaseProto</title>
<indexterm zone="TpMediaStreamBaseProto"><primary>TpMediaStreamBaseProto</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_BASE_PROTO_UDP = 0,
    TP_MEDIA_STREAM_BASE_PROTO_TCP = 1,
} TpMediaStreamBaseProto;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-BASE-PROTO-UDP:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_BASE_PROTO_UDP</literal></term>
<listitem><simpara> <![CDATA[UDP (User Datagram Protocol)]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-BASE-PROTO-TCP:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_BASE_PROTO_TCP</literal></term>
<listitem><simpara> <![CDATA[TCP (Transmission Control Protocol)]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-BASE-PROTOS:CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_BASE_PROTOS</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-BASE-PROTOS:CAPS"><primary>NUM_TP_MEDIA_STREAM_BASE_PROTOS</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_BASE_PROTOS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamBaseProto"><type>TpMediaStreamBaseProto</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpMediaStreamTransportType" role="enum">
<title>enum TpMediaStreamTransportType</title>
<indexterm zone="TpMediaStreamTransportType"><primary>TpMediaStreamTransportType</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_TRANSPORT_TYPE_LOCAL = 0,
    TP_MEDIA_STREAM_TRANSPORT_TYPE_DERIVED = 1,
    TP_MEDIA_STREAM_TRANSPORT_TYPE_RELAY = 2,
} TpMediaStreamTransportType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-TRANSPORT-TYPE-LOCAL:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TRANSPORT_TYPE_LOCAL</literal></term>
<listitem><simpara> <![CDATA[           A local address         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-TRANSPORT-TYPE-DERIVED:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TRANSPORT_TYPE_DERIVED</literal></term>
<listitem><simpara> <![CDATA[           An external address derived by a method such as STUN         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-TRANSPORT-TYPE-RELAY:CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TRANSPORT_TYPE_RELAY</literal></term>
<listitem><simpara> <![CDATA[           An external stream relay         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-TRANSPORT-TYPES:CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-TRANSPORT-TYPES:CAPS"><primary>NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamTransportType"><type>TpMediaStreamTransportType</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpPropertyFlags" role="enum">
<title>enum TpPropertyFlags</title>
<indexterm zone="TpPropertyFlags"><primary>TpPropertyFlags</primary></indexterm><programlisting>typedef enum {
    TP_PROPERTY_FLAG_READ = 1,
    TP_PROPERTY_FLAG_WRITE = 2,
} TpPropertyFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-PROPERTY-FLAG-READ:CAPS" role="constant">
<term><literal>TP_PROPERTY_FLAG_READ</literal></term>
<listitem><simpara> <![CDATA[The property can be read]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-PROPERTY-FLAG-WRITE:CAPS" role="constant">
<term><literal>TP_PROPERTY_FLAG_WRITE</literal></term>
<listitem><simpara> <![CDATA[The property can be written]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-SOCKET-ACCESS-CONTROLS:CAPS" role="macro">
<title>NUM_TP_SOCKET_ACCESS_CONTROLS</title>
<indexterm zone="NUM-TP-SOCKET-ACCESS-CONTROLS:CAPS"><primary>NUM_TP_SOCKET_ACCESS_CONTROLS</primary></indexterm><programlisting>#define             NUM_TP_SOCKET_ACCESS_CONTROLS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpSocketAccessControl"><type>TpSocketAccessControl</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpSocketAccessControl" role="enum">
<title>enum TpSocketAccessControl</title>
<indexterm zone="TpSocketAccessControl"><primary>TpSocketAccessControl</primary></indexterm><programlisting>typedef enum {
    TP_SOCKET_ACCESS_CONTROL_LOCALHOST = 0,
    TP_SOCKET_ACCESS_CONTROL_PORT = 1,
    TP_SOCKET_ACCESS_CONTROL_NETMASK = 2,
    TP_SOCKET_ACCESS_CONTROL_CREDENTIALS = 3,
} TpSocketAccessControl;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-SOCKET-ACCESS-CONTROL-LOCALHOST:CAPS" role="constant">
<term><literal>TP_SOCKET_ACCESS_CONTROL_LOCALHOST</literal></term>
<listitem><simpara> <![CDATA[           The IP or Unix socket can be accessed by any local user (e.g.           a Unix socket that accepts all local connections, or an IP socket           listening on 127.0.0.1 (or ::1) or rejecting connections not from           that address). The associated variant must be ignored.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ACCESS-CONTROL-PORT:CAPS" role="constant">
<term><literal>TP_SOCKET_ACCESS_CONTROL_PORT</literal></term>
<listitem><simpara> <![CDATA[           May only be used on IP sockets. The associated variant must contain           a struct Socket_Address_IPv4 (or Socket_Address_IPv6)           containing the string form of an IP address of the appropriate           version, and a port number. The socket can only be accessed if the           connecting process has that address and port number; all other           connections will be rejected.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ACCESS-CONTROL-NETMASK:CAPS" role="constant">
<term><literal>TP_SOCKET_ACCESS_CONTROL_NETMASK</literal></term>
<listitem><simpara> <![CDATA[           May only be used on IP sockets. The associated variant must contain           a struct Socket_Netmask_IPv4 (or Socket_Netmask_IPv6) with           signature (sy), containing the string form of an           IP address of the appropriate version, and a prefix length "n".           The socket can only be accessed if the first n bits of the           connecting address match the first n bits of the given address.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ACCESS-CONTROL-CREDENTIALS:CAPS" role="constant">
<term><literal>TP_SOCKET_ACCESS_CONTROL_CREDENTIALS</literal></term>
<listitem><simpara> <![CDATA[           The connecting process must send a single zero (NUL) byte when             it first connects, which is not considered to be part of the data             stream. If the operating system uses sendmsg() with SCM_CREDS or             SCM_CREDENTIALS to pass credentials over sockets, the connecting             process must do so if possible; if not, it must still send the             byte.            The listening process will disconnect the connection unless it             can determine by OS-specific means that the connecting process             has the same user ID as the listening process.            The associated variant must be ignored.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-SOCKET-ADDRESS-TYPES:CAPS" role="macro">
<title>NUM_TP_SOCKET_ADDRESS_TYPES</title>
<indexterm zone="NUM-TP-SOCKET-ADDRESS-TYPES:CAPS"><primary>NUM_TP_SOCKET_ADDRESS_TYPES</primary></indexterm><programlisting>#define             NUM_TP_SOCKET_ADDRESS_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpSocketAddressType"><type>TpSocketAddressType</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpSocketAddressType" role="enum">
<title>enum TpSocketAddressType</title>
<indexterm zone="TpSocketAddressType"><primary>TpSocketAddressType</primary></indexterm><programlisting>typedef enum {
    TP_SOCKET_ADDRESS_TYPE_UNIX = 0,
    TP_SOCKET_ADDRESS_TYPE_ABSTRACT_UNIX = 1,
    TP_SOCKET_ADDRESS_TYPE_IPV4 = 2,
    TP_SOCKET_ADDRESS_TYPE_IPV6 = 3,
} TpSocketAddressType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-SOCKET-ADDRESS-TYPE-UNIX:CAPS" role="constant">
<term><literal>TP_SOCKET_ADDRESS_TYPE_UNIX</literal></term>
<listitem><simpara> <![CDATA[           A Unix socket. The variant contains a byte-array, signature 'ay',           containing the path of the socket.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ADDRESS-TYPE-ABSTRACT-UNIX:CAPS" role="constant">
<term><literal>TP_SOCKET_ADDRESS_TYPE_ABSTRACT_UNIX</literal></term>
<listitem><simpara> <![CDATA[           An abstract Unix socket. The variant contains a byte-array,           signature 'ay', containing the path of the socket including the           leading null byte.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ADDRESS-TYPE-IPV4:CAPS" role="constant">
<term><literal>TP_SOCKET_ADDRESS_TYPE_IPV4</literal></term>
<listitem><simpara> <![CDATA[           An IPv4 socket. The variant contains a Socket_Address_IPv4,           i.e. a structure with signature (sq)           in which the string is an IPv4 dotted-quad address literal           (and must not be a DNS name), while the 16-bit unsigned integer is           the port number.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ADDRESS-TYPE-IPV6:CAPS" role="constant">
<term><literal>TP_SOCKET_ADDRESS_TYPE_IPV6</literal></term>
<listitem><simpara> <![CDATA[           An IPv6 socket. The variant contains a Socket_Address_IPv6,           i.e. a structure with signature (sq)           in which the string is an IPv6 address literal as specified in           RFC2373 (and must not be a DNS name), while the 16-bit unsigned           integer is the port number.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-TUBE-STATES:CAPS" role="macro">
<title>NUM_TP_TUBE_STATES</title>
<indexterm zone="NUM-TP-TUBE-STATES:CAPS"><primary>NUM_TP_TUBE_STATES</primary></indexterm><programlisting>#define             NUM_TP_TUBE_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpTubeState"><type>TpTubeState</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpTubeState" role="enum">
<title>enum TpTubeState</title>
<indexterm zone="TpTubeState"><primary>TpTubeState</primary></indexterm><programlisting>typedef enum {
    TP_TUBE_STATE_LOCAL_PENDING = 0,
    TP_TUBE_STATE_REMOTE_PENDING = 1,
    TP_TUBE_STATE_OPEN = 2,
} TpTubeState;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-TUBE-STATE-LOCAL-PENDING:CAPS" role="constant">
<term><literal>TP_TUBE_STATE_LOCAL_PENDING</literal></term>
<listitem><simpara> <![CDATA[           The tube is waiting to be accepted/closed locally.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-TUBE-STATE-REMOTE-PENDING:CAPS" role="constant">
<term><literal>TP_TUBE_STATE_REMOTE_PENDING</literal></term>
<listitem><simpara> <![CDATA[           The tube is waiting to be accepted/closed remotely.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-TUBE-STATE-OPEN:CAPS" role="constant">
<term><literal>TP_TUBE_STATE_OPEN</literal></term>
<listitem><simpara> <![CDATA[           The tube is open for traffic.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-TUBE-TYPES:CAPS" role="macro">
<title>NUM_TP_TUBE_TYPES</title>
<indexterm zone="NUM-TP-TUBE-TYPES:CAPS"><primary>NUM_TP_TUBE_TYPES</primary></indexterm><programlisting>#define             NUM_TP_TUBE_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpTubeType"><type>TpTubeType</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpTubeType" role="enum">
<title>enum TpTubeType</title>
<indexterm zone="TpTubeType"><primary>TpTubeType</primary></indexterm><programlisting>typedef enum {
    TP_TUBE_TYPE_DBUS = 0,
    TP_TUBE_TYPE_STREAM = 1,
} TpTubeType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-TUBE-TYPE-DBUS:CAPS" role="constant">
<term><literal>TP_TUBE_TYPE_DBUS</literal></term>
<listitem><simpara> <![CDATA[           An ordered reliable transport, for transporting D-Bus             traffic.            For each D-Bus tube, the connection manager listens on a D-Bus             server address, as detailed in the D-Bus specification. On this             address, it emulates a bus upon which each tube participant appears             as an endpoint.            The objects and interfaces which are expected to exist on the             emulated bus depend on the well-known name; typically, either the             participant who initiated the tube is expected to export the same             objects/interfaces that would be exported by a service of that name             on a bus, or all participants are expected to export those             objects/interfaces.            In a multi-user context (Handle_Type_Room) the tube behaves             like the D-Bus bus daemon, so participants can send each other             private messages, or can send broadcast messages which are             received by everyone in the tube (including themselves).             Each participant has a D-Bus unique name; connection managers             must prevent participants from sending messages with the wrong             sender unique name, and should attempt to avoid participants             receiving messages not intended for them.            In a 1-1 context (Handle_Type_Contact) the tube behaves like             a peer-to-peer D-Bus connection - arbitrary D-Bus messages with             any sender and/or destination can be sent by each participant,             and each participant receives all messages sent by the other             participant.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-TUBE-TYPE-STREAM:CAPS" role="constant">
<term><literal>TP_TUBE_TYPE_STREAM</literal></term>
<listitem><simpara> <![CDATA[           A transport for ordered, reliable data transfer, similar to             SOCK_STREAM sockets.            When accepting a Stream Unix tube, a new listening local socket is             created. Each time the client connects to this socket, the             connection manager of the initiator of the tube opens a new             connection to its local socket. Both sides can then use this pair             of sockets to communicate together.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelCallStateFlags" role="enum">
<title>enum TpChannelCallStateFlags</title>
<indexterm zone="TpChannelCallStateFlags"><primary>TpChannelCallStateFlags</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_CALL_STATE_RINGING = 1,
    TP_CHANNEL_CALL_STATE_QUEUED = 2,
    TP_CHANNEL_CALL_STATE_HELD = 4,
    TP_CHANNEL_CALL_STATE_FORWARDED = 8,
} TpChannelCallStateFlags;
</programlisting>
<para>
<![CDATA[         A set of flags representing call states.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-CALL-STATE-RINGING:CAPS" role="constant">
<term><literal>TP_CHANNEL_CALL_STATE_RINGING</literal></term>
<listitem><simpara> <![CDATA[           The contact has been alerted about the call but has not responded           (e.g. 180 Ringing in SIP).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CALL-STATE-QUEUED:CAPS" role="constant">
<term><literal>TP_CHANNEL_CALL_STATE_QUEUED</literal></term>
<listitem><simpara> <![CDATA[           The contact is temporarily unavailable, and the call has been placed           in a queue (e.g. 182 Queued in SIP, or call-waiting in telephony).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CALL-STATE-HELD:CAPS" role="constant">
<term><literal>TP_CHANNEL_CALL_STATE_HELD</literal></term>
<listitem><simpara> <![CDATA[           The contact has placed the call on hold, and will not receive           media from the local user or any other participants until they           unhold the call again.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CALL-STATE-FORWARDED:CAPS" role="constant">
<term><literal>TP_CHANNEL_CALL_STATE_FORWARDED</literal></term>
<listitem><simpara> <![CDATA[           The initiator of the call originally called a contact other than the           current recipient of the call, but the call was then forwarded or           diverted.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-LOCAL-HOLD-STATES:CAPS" role="macro">
<title>NUM_TP_LOCAL_HOLD_STATES</title>
<indexterm zone="NUM-TP-LOCAL-HOLD-STATES:CAPS"><primary>NUM_TP_LOCAL_HOLD_STATES</primary></indexterm><programlisting>#define             NUM_TP_LOCAL_HOLD_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpLocalHoldState"><type>TpLocalHoldState</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpLocalHoldState" role="enum">
<title>enum TpLocalHoldState</title>
<indexterm zone="TpLocalHoldState"><primary>TpLocalHoldState</primary></indexterm><programlisting>typedef enum {
    TP_LOCAL_HOLD_STATE_UNHELD = 0,
    TP_LOCAL_HOLD_STATE_HELD = 1,
    TP_LOCAL_HOLD_STATE_PENDING_HOLD = 2,
    TP_LOCAL_HOLD_STATE_PENDING_UNHOLD = 3,
} TpLocalHoldState;
</programlisting>
<para>
<![CDATA[         The hold state of a channel.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-LOCAL-HOLD-STATE-UNHELD:CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_UNHELD</literal></term>
<listitem><simpara> <![CDATA[           All streams are unheld (the call is active). New channels SHOULD           have this hold state.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-HELD:CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_HELD</literal></term>
<listitem><simpara> <![CDATA[           All streams are held (the call is on hold)         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-PENDING-HOLD:CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_PENDING_HOLD</literal></term>
<listitem><simpara> <![CDATA[           The connection manager is attempting to move to state Held, but           has not yet completed that operation. It is unspecified whether           any, all or none of the streams making up the channel are on hold.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-PENDING-UNHOLD:CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_PENDING_UNHOLD</literal></term>
<listitem><simpara> <![CDATA[           The connection manager is attempting to move to state Held, but           has not yet completed that operation. It is unspecified whether           any, all or none of the streams making up the channel are on hold.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-LOCAL-HOLD-STATE-REASONS:CAPS" role="macro">
<title>NUM_TP_LOCAL_HOLD_STATE_REASONS</title>
<indexterm zone="NUM-TP-LOCAL-HOLD-STATE-REASONS:CAPS"><primary>NUM_TP_LOCAL_HOLD_STATE_REASONS</primary></indexterm><programlisting>#define             NUM_TP_LOCAL_HOLD_STATE_REASONS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpLocalHoldStateReason"><type>TpLocalHoldStateReason</type></link>.</para>
<para>

</para></refsect2>
<refsect2 id="TpLocalHoldStateReason" role="enum">
<title>enum TpLocalHoldStateReason</title>
<indexterm zone="TpLocalHoldStateReason"><primary>TpLocalHoldStateReason</primary></indexterm><programlisting>typedef enum {
    TP_LOCAL_HOLD_STATE_REASON_NONE = 0,
    TP_LOCAL_HOLD_STATE_REASON_REQUESTED = 1,
    TP_LOCAL_HOLD_STATE_REASON_RESOURCE_NOT_AVAILABLE = 2,
} TpLocalHoldStateReason;
</programlisting>
<para>
<![CDATA[         The reason for a change to the Local_Hold_State. Clients MUST         treat unknown values as equivalent to Local_Hold_State_Reason_None.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>

</para><variablelist role="enum">
<varlistentry id="TP-LOCAL-HOLD-STATE-REASON-NONE:CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_REASON_NONE</literal></term>
<listitem><simpara> <![CDATA[           The reason cannot be described by any of the predefined values           (connection managers SHOULD avoid this reason, but clients MUST           handle it gracefully)         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-REASON-REQUESTED:CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_REASON_REQUESTED</literal></term>
<listitem><simpara> <![CDATA[           The change is in response to a user request         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-REASON-RESOURCE-NOT-AVAILABLE:CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_REASON_RESOURCE_NOT_AVAILABLE</literal></term>
<listitem><simpara> <![CDATA[           The change is because some resource was not available         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>

</refsect1>




</refentry>
