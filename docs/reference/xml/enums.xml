<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="telepathy-glib-enums">
<refmeta>
<refentrytitle role="top_of_page" id="telepathy-glib-enums.top_of_page">Telepathy protocol enumerations</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>Telepathy protocol enumerations</refname>
<refpurpose>Enumerated types and bitfields from the Telepathy spec</refpurpose>
</refnamediv>

<refsynopsisdiv id="telepathy-glib-enums.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;telepathy-glib/enums.h&gt;

enum                <link linkend="TpHandleType">TpHandleType</link>;
#define             <link linkend="NUM-TP-HANDLE-TYPES--CAPS">NUM_TP_HANDLE_TYPES</link>
enum                <link linkend="TpConnMgrParamFlags">TpConnMgrParamFlags</link>;
enum                <link linkend="TpConnectionStatus">TpConnectionStatus</link>;
#define             <link linkend="NUM-TP-CONNECTION-STATUSES--CAPS">NUM_TP_CONNECTION_STATUSES</link>
enum                <link linkend="TpConnectionStatusReason">TpConnectionStatusReason</link>;
#define             <link linkend="NUM-TP-CONNECTION-STATUS-REASONS--CAPS">NUM_TP_CONNECTION_STATUS_REASONS</link>
enum                <link linkend="TpConnectionAliasFlags">TpConnectionAliasFlags</link>;
enum                <link linkend="TpConnectionCapabilityFlags">TpConnectionCapabilityFlags</link>;
enum                <link linkend="TpConnectionPresenceType">TpConnectionPresenceType</link>;
#define             <link linkend="NUM-TP-CONNECTION-PRESENCE-TYPES--CAPS">NUM_TP_CONNECTION_PRESENCE_TYPES</link>
enum                <link linkend="TpDTMFEvent">TpDTMFEvent</link>;
#define             <link linkend="NUM-TP-DTMF-EVENTS--CAPS">NUM_TP_DTMF_EVENTS</link>
enum                <link linkend="TpMediaStreamType">TpMediaStreamType</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-TYPES--CAPS">NUM_TP_MEDIA_STREAM_TYPES</link>
enum                <link linkend="TpMediaStreamState">TpMediaStreamState</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-STATES--CAPS">NUM_TP_MEDIA_STREAM_STATES</link>
enum                <link linkend="TpMediaStreamDirection">TpMediaStreamDirection</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-DIRECTIONS--CAPS">NUM_TP_MEDIA_STREAM_DIRECTIONS</link>
enum                <link linkend="TpMediaStreamPendingSend">TpMediaStreamPendingSend</link>;
enum                <link linkend="TpChannelMediaCapabilities">TpChannelMediaCapabilities</link>;
enum                <link linkend="TpChannelTextSendError">TpChannelTextSendError</link>;
#define             <link linkend="NUM-TP-CHANNEL-TEXT-SEND-ERRORS--CAPS">NUM_TP_CHANNEL_TEXT_SEND_ERRORS</link>
enum                <link linkend="TpChannelTextMessageType">TpChannelTextMessageType</link>;
#define             <link linkend="NUM-TP-CHANNEL-TEXT-MESSAGE-TYPES--CAPS">NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES</link>
enum                <link linkend="TpChannelTextMessageFlags">TpChannelTextMessageFlags</link>;
enum                <link linkend="TpChannelChatState">TpChannelChatState</link>;
#define             <link linkend="NUM-TP-CHANNEL-CHAT-STATES--CAPS">NUM_TP_CHANNEL_CHAT_STATES</link>
enum                <link linkend="TpChannelGroupFlags">TpChannelGroupFlags</link>;
enum                <link linkend="TpChannelGroupChangeReason">TpChannelGroupChangeReason</link>;
#define             <link linkend="NUM-TP-CHANNEL-GROUP-CHANGE-REASONS--CAPS">NUM_TP_CHANNEL_GROUP_CHANGE_REASONS</link>
enum                <link linkend="TpChannelPasswordFlags">TpChannelPasswordFlags</link>;
enum                <link linkend="TpDeliveryReportingSupportFlags">TpDeliveryReportingSupportFlags</link>;
enum                <link linkend="TpDeliveryStatus">TpDeliveryStatus</link>;
#define             <link linkend="NUM-TP-DELIVERY-STATUSES--CAPS">NUM_TP_DELIVERY_STATUSES</link>
enum                <link linkend="TpMediaStreamError">TpMediaStreamError</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-ERRORS--CAPS">NUM_TP_MEDIA_STREAM_ERRORS</link>
enum                <link linkend="TpMediaStreamBaseProto">TpMediaStreamBaseProto</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-BASE-PROTOS--CAPS">NUM_TP_MEDIA_STREAM_BASE_PROTOS</link>
enum                <link linkend="TpMediaStreamTransportType">TpMediaStreamTransportType</link>;
#define             <link linkend="NUM-TP-MEDIA-STREAM-TRANSPORT-TYPES--CAPS">NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES</link>
enum                <link linkend="TpPropertyFlags">TpPropertyFlags</link>;
enum                <link linkend="TpMessagePartSupportFlags">TpMessagePartSupportFlags</link>;
enum                <link linkend="TpMessageSendingFlags">TpMessageSendingFlags</link>;
#define             <link linkend="NUM-TP-SOCKET-ACCESS-CONTROLS--CAPS">NUM_TP_SOCKET_ACCESS_CONTROLS</link>
enum                <link linkend="TpSocketAccessControl">TpSocketAccessControl</link>;
#define             <link linkend="NUM-TP-SOCKET-ADDRESS-TYPES--CAPS">NUM_TP_SOCKET_ADDRESS_TYPES</link>
enum                <link linkend="TpSocketAddressType">TpSocketAddressType</link>;
#define             <link linkend="NUM-TP-TUBE-STATES--CAPS">NUM_TP_TUBE_STATES</link>
enum                <link linkend="TpTubeState">TpTubeState</link>;
#define             <link linkend="NUM-TP-TUBE-TYPES--CAPS">NUM_TP_TUBE_TYPES</link>
enum                <link linkend="TpTubeType">TpTubeType</link>;
enum                <link linkend="TpChannelCallStateFlags">TpChannelCallStateFlags</link>;
#define             <link linkend="NUM-TP-LOCAL-HOLD-STATES--CAPS">NUM_TP_LOCAL_HOLD_STATES</link>
enum                <link linkend="TpLocalHoldState">TpLocalHoldState</link>;
#define             <link linkend="NUM-TP-LOCAL-HOLD-STATE-REASONS--CAPS">NUM_TP_LOCAL_HOLD_STATE_REASONS</link>
enum                <link linkend="TpLocalHoldStateReason">TpLocalHoldStateReason</link>;
enum                <link linkend="TpRichPresenceAccessControlType">TpRichPresenceAccessControlType</link>;
#define             <link linkend="NUM-TP-RICH-PRESENCE-ACCESS-CONTROL-TYPES--CAPS">NUM_TP_RICH_PRESENCE_ACCESS_CONTROL_TYPES</link>
enum                <link linkend="TpFileHashType">TpFileHashType</link>;
#define             <link linkend="NUM-TP-FILE-HASH-TYPES--CAPS">NUM_TP_FILE_HASH_TYPES</link>
enum                <link linkend="TpFileTransferState">TpFileTransferState</link>;
#define             <link linkend="NUM-TP-FILE-TRANSFER-STATES--CAPS">NUM_TP_FILE_TRANSFER_STATES</link>
enum                <link linkend="TpFileTransferStateChangeReason">TpFileTransferStateChangeReason</link>;
#define             <link linkend="NUM-TP-FILE-TRANSFER-STATE-CHANGE-REASONS--CAPS">NUM_TP_FILE_TRANSFER_STATE_CHANGE_REASONS</link>
enum                <link linkend="TpTubeChannelState">TpTubeChannelState</link>;
#define             <link linkend="NUM-TP-TUBE-CHANNEL-STATES--CAPS">NUM_TP_TUBE_CHANNEL_STATES</link>
enum                <link linkend="TpDebugLevel">TpDebugLevel</link>;
#define             <link linkend="NUM-TP-DEBUG-LEVELS--CAPS">NUM_TP_DEBUG_LEVELS</link>
</synopsis>
</refsynopsisdiv>









<refsect1 id="telepathy-glib-enums.description" role="desc">
<title role="desc.title">Description</title>
<para>
This header exposes the constants from the Telepathy specification as
C enums. It is automatically generated from the specification.
</para>
<para>
The names used in the specification (e.g.
Connection_Status_Connected) are converted to upper-case and given a
TP_ prefix, e.g. TP_CONNECTION_STATUS_CONNECTED.
</para>
<para>
Each enum also has a constant for the number of members, named like
NUM_TP_CONNECTION_STATUSES. The pluralization is currently hard-coded
in the conversion scripts, but should move into the specification
in future.
</para>
<para>
Constants LAST_TP_CONNECTION_STATUS, etc. are also provided. These are
deprecated and will be removed in a future release.</para>
<para>
</para>
</refsect1>

<refsect1 id="telepathy-glib-enums.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="TpHandleType" role="enum">
<title>enum TpHandleType</title>
<indexterm zone="TpHandleType"><primary sortas="TpHandleType">TpHandleType</primary></indexterm><programlisting>typedef enum {
    TP_HANDLE_TYPE_NONE = 0,
    TP_HANDLE_TYPE_CONTACT = 1,
    TP_HANDLE_TYPE_ROOM = 2,
    TP_HANDLE_TYPE_LIST = 3,
    TP_HANDLE_TYPE_GROUP = 4,
} TpHandleType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-HANDLE-TYPE-NONE--CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_NONE</literal></term>
<listitem><simpara> <![CDATA[           A "null" handle type used to indicate the absence of a handle.           When a handle type and a handle appear as a pair, if the handle           type is zero, the handle must also be zero.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-HANDLE-TYPE-CONTACT--CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_CONTACT</literal></term>
<listitem><simpara> <![CDATA[           A contact         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-HANDLE-TYPE-ROOM--CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_ROOM</literal></term>
<listitem><simpara> <![CDATA[           A chat room         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-HANDLE-TYPE-LIST--CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_LIST</literal></term>
<listitem><simpara> <![CDATA[           A server-generated contact list (see Channel.Interface.Group)         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-HANDLE-TYPE-GROUP--CAPS" role="constant">
<term><literal>TP_HANDLE_TYPE_GROUP</literal></term>
<listitem><simpara> <![CDATA[           A user-defined contact list (see Channel.Interface.Group)         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-HANDLE-TYPES--CAPS" role="macro">
<title>NUM_TP_HANDLE_TYPES</title>
<indexterm zone="NUM-TP-HANDLE-TYPES--CAPS"><primary sortas="NUM_TP_HANDLE_TYPES">NUM_TP_HANDLE_TYPES</primary></indexterm><programlisting>#define             NUM_TP_HANDLE_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpHandleType"><type>TpHandleType</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpConnMgrParamFlags" role="enum">
<title>enum TpConnMgrParamFlags</title>
<indexterm zone="TpConnMgrParamFlags"><primary sortas="TpConnMgrParamFlags">TpConnMgrParamFlags</primary></indexterm><programlisting>typedef enum {
    TP_CONN_MGR_PARAM_FLAG_REQUIRED = 1,
    TP_CONN_MGR_PARAM_FLAG_REGISTER = 2,
    TP_CONN_MGR_PARAM_FLAG_HAS_DEFAULT = 4,
    TP_CONN_MGR_PARAM_FLAG_SECRET = 8,
    TP_CONN_MGR_PARAM_FLAG_DBUS_PROPERTY = 16,
} TpConnMgrParamFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CONN-MGR-PARAM-FLAG-REQUIRED--CAPS" role="constant">
<term><literal>TP_CONN_MGR_PARAM_FLAG_REQUIRED</literal></term>
<listitem><simpara> <![CDATA[           This parameter is required for connecting to the server.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONN-MGR-PARAM-FLAG-REGISTER--CAPS" role="constant">
<term><literal>TP_CONN_MGR_PARAM_FLAG_REGISTER</literal></term>
<listitem><simpara> <![CDATA[           This parameter is required for registering an account on the           server.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONN-MGR-PARAM-FLAG-HAS-DEFAULT--CAPS" role="constant">
<term><literal>TP_CONN_MGR_PARAM_FLAG_HAS_DEFAULT</literal></term>
<listitem><simpara> <![CDATA[           This parameter has a default value, which is returned in           GetParameters; not providing this parameter is equivalent to           providing the default.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONN-MGR-PARAM-FLAG-SECRET--CAPS" role="constant">
<term><literal>TP_CONN_MGR_PARAM_FLAG_SECRET</literal></term>
<listitem><simpara> <![CDATA[           This parameter should be considered private or secret; for             instance, clients should store it in a "password safe" like             gnome-keyring or kwallet, omit it from debug logs, and use a             text input widget that hides the value of the parameter.            (Clients that support older connection managers may also treat             any parameter whose name contains "password" as though it had this             flag.)         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONN-MGR-PARAM-FLAG-DBUS-PROPERTY--CAPS" role="constant">
<term><literal>TP_CONN_MGR_PARAM_FLAG_DBUS_PROPERTY</literal></term>
<listitem><simpara> <![CDATA[           This parameter is also a D-Bus property on the resulting Connection; a           parameter named com.example.Duck.Macaroni with this flag           corresponds to the Macaroni property on the           com.example.Duck interface.  Its value can be queried           and possibly changed on an existing Connection using methods on the           org.freedesktop.DBus.Properties interface.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpConnectionStatus" role="enum">
<title>enum TpConnectionStatus</title>
<indexterm zone="TpConnectionStatus"><primary sortas="TpConnectionStatus">TpConnectionStatus</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_STATUS_CONNECTED = 0,
    TP_CONNECTION_STATUS_CONNECTING = 1,
    TP_CONNECTION_STATUS_DISCONNECTED = 2,
} TpConnectionStatus;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-STATUS-CONNECTED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_CONNECTED</literal></term>
<listitem><simpara> <![CDATA[             The connection is alive and all methods are available.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-CONNECTING--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_CONNECTING</literal></term>
<listitem><simpara> <![CDATA[             The connection has not yet been established, or has been             severed and reconnection is being attempted. Some methods may fail             until the connection has been established.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-DISCONNECTED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_DISCONNECTED</literal></term>
<listitem><simpara> <![CDATA[             The connection has been severed and no method calls are             valid. The object may be removed from the bus at any time.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CONNECTION-STATUSES--CAPS" role="macro">
<title>NUM_TP_CONNECTION_STATUSES</title>
<indexterm zone="NUM-TP-CONNECTION-STATUSES--CAPS"><primary sortas="NUM_TP_CONNECTION_STATUSES">NUM_TP_CONNECTION_STATUSES</primary></indexterm><programlisting>#define             NUM_TP_CONNECTION_STATUSES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpConnectionStatus"><type>TpConnectionStatus</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpConnectionStatusReason" role="enum">
<title>enum TpConnectionStatusReason</title>
<indexterm zone="TpConnectionStatusReason"><primary sortas="TpConnectionStatusReason">TpConnectionStatusReason</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED = 0,
    TP_CONNECTION_STATUS_REASON_REQUESTED = 1,
    TP_CONNECTION_STATUS_REASON_NETWORK_ERROR = 2,
    TP_CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED = 3,
    TP_CONNECTION_STATUS_REASON_ENCRYPTION_ERROR = 4,
    TP_CONNECTION_STATUS_REASON_NAME_IN_USE = 5,
    TP_CONNECTION_STATUS_REASON_CERT_NOT_PROVIDED = 6,
    TP_CONNECTION_STATUS_REASON_CERT_UNTRUSTED = 7,
    TP_CONNECTION_STATUS_REASON_CERT_EXPIRED = 8,
    TP_CONNECTION_STATUS_REASON_CERT_NOT_ACTIVATED = 9,
    TP_CONNECTION_STATUS_REASON_CERT_HOSTNAME_MISMATCH = 10,
    TP_CONNECTION_STATUS_REASON_CERT_FINGERPRINT_MISMATCH = 11,
    TP_CONNECTION_STATUS_REASON_CERT_SELF_SIGNED = 12,
    TP_CONNECTION_STATUS_REASON_CERT_OTHER_ERROR = 13,
} TpConnectionStatusReason;
</programlisting>
<para>
<![CDATA[         A reason why the status of the connection changed. Apart from           Requested, the values of this enumeration only make sense as           reasons why the status changed to Disconnected.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-STATUS-REASON-NONE-SPECIFIED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED</literal></term>
<listitem><simpara> <![CDATA[           There is no reason set for this state change. Unknown status             reasons SHOULD be treated like this reason.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Disconnected.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-REQUESTED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_REQUESTED</literal></term>
<listitem><simpara> <![CDATA[           The change is in response to a user request. Changes to the             Connecting or Connected status SHOULD always indicate this reason;             changes to the Disconnected status SHOULD indicate this reason             if and only if the disconnection was requested by the user.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cancelled.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-NETWORK-ERROR--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_NETWORK_ERROR</literal></term>
<listitem><simpara> <![CDATA[           There was an error sending or receiving on the network socket.            When the status changes from Connecting to Disconnected for this             reason, the equivalent D-Bus error is either             org.freedesktop.Telepathy.Error.NetworkError,             org.freedesktop.Telepathy.Error.ConnectionRefused,             org.freedesktop.Telepathy.Error.ConnectionFailed             or some more specific error.            When the status changes from Connected to Disconnected for this             reason, the equivalent D-Bus error is either             org.freedesktop.Telepathy.Error.NetworkError,             org.freedesktop.Telepathy.Error.ConnectionLost             or some more specific error.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-AUTHENTICATION-FAILED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED</literal></term>
<listitem><simpara> <![CDATA[           The username or password was invalid.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.AuthenticationFailed.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-ENCRYPTION-ERROR--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_ENCRYPTION_ERROR</literal></term>
<listitem><simpara> <![CDATA[           There was an error negotiating SSL on this connection, or             encryption was unavailable and require-encryption was set when the             connection was created.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.EncryptionNotAvailable             if encryption was not available at all, or             org.freedesktop.Telepathy.Error.EncryptionError             if encryption failed.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-NAME-IN-USE--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_NAME_IN_USE</literal></term>
<listitem><simpara> <![CDATA[           In general, this reason indicates that the requested account             name or other identification could not be used due to conflict             with another connection. It can be divided into three cases:                         If the status change is from Connecting to Disconnected               and the 'register' parameter to RequestConnection was present               and true, the requested account could not be created on the               server because it already exists.               The equivalent D-Bus error is               org.freedesktop.Telepathy.Error.RegistrationExists.                           If the status change is from Connecting to Disconnected               but the 'register' parameter is absent or false, the connection               manager could not connect to the specified account because               a connection to that account already exists.               The equivalent D-Bus error is               org.freedesktop.Telepathy.Error.AlreadyConnected.                                 In some protocols, like XMPP (when connecting with the same                 JID and resource as an existing connection), the existing                 connection "wins" and the new one fails to connect.                                          If the status change is from Connected to Disconnected,               the existing connection was automatically disconnected because               a new connection to the same account (perhaps from a different               client or location) was established.               The equivalent D-Bus error is               org.freedesktop.Telepathy.Error.ConnectionReplaced.                                 In some protocols, like MSNP (when connecting twice with the                 same Passport), the new connection "wins" and the                 existing one is automatically disconnected.                                                ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-NOT-PROVIDED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_NOT_PROVIDED</literal></term>
<listitem><simpara> <![CDATA[           The server did not provide a SSL certificate.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.NotProvided.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-UNTRUSTED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_UNTRUSTED</literal></term>
<listitem><simpara> <![CDATA[           The server's SSL certificate is signed by an untrusted certifying             authority. This error SHOULD NOT be used to represent a self-signed             certificate: use the more specific Cert_Self_Signed reason for             that.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.Untrusted.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-EXPIRED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_EXPIRED</literal></term>
<listitem><simpara> <![CDATA[           The server's SSL certificate has expired.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.Expired.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-NOT-ACTIVATED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_NOT_ACTIVATED</literal></term>
<listitem><simpara> <![CDATA[           The server's SSL certificate is not yet valid.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.NotActivated.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-HOSTNAME-MISMATCH--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_HOSTNAME_MISMATCH</literal></term>
<listitem><simpara> <![CDATA[           The server's SSL certificate did not match its hostname.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.HostnameMismatch.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-FINGERPRINT-MISMATCH--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_FINGERPRINT_MISMATCH</literal></term>
<listitem><simpara> <![CDATA[           The server's SSL certificate does not have the expected             fingerprint.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.FingerprintMismatch.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-SELF-SIGNED--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_SELF_SIGNED</literal></term>
<listitem><simpara> <![CDATA[           The server's SSL certificate is self-signed.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.HostnameMismatch.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-STATUS-REASON-CERT-OTHER-ERROR--CAPS" role="constant">
<term><literal>TP_CONNECTION_STATUS_REASON_CERT_OTHER_ERROR</literal></term>
<listitem><simpara> <![CDATA[           There was some other error validating the server's SSL             certificate.            When disconnected for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cert.Invalid.                    ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CONNECTION-STATUS-REASONS--CAPS" role="macro">
<title>NUM_TP_CONNECTION_STATUS_REASONS</title>
<indexterm zone="NUM-TP-CONNECTION-STATUS-REASONS--CAPS"><primary sortas="NUM_TP_CONNECTION_STATUS_REASONS">NUM_TP_CONNECTION_STATUS_REASONS</primary></indexterm><programlisting>#define             NUM_TP_CONNECTION_STATUS_REASONS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpConnectionStatusReason"><type>TpConnectionStatusReason</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpConnectionAliasFlags" role="enum">
<title>enum TpConnectionAliasFlags</title>
<indexterm zone="TpConnectionAliasFlags"><primary sortas="TpConnectionAliasFlags">TpConnectionAliasFlags</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_ALIAS_FLAG_USER_SET = 1,
} TpConnectionAliasFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-ALIAS-FLAG-USER-SET--CAPS" role="constant">
<term><literal>TP_CONNECTION_ALIAS_FLAG_USER_SET</literal></term>
<listitem><simpara> <![CDATA[           The aliases of contacts on this connection may be changed by the             user of the service, not just by the contacts themselves. This is             the case on Jabber, for instance.           It is possible that aliases can be changed by the contacts too -             which alias takes precedence is not defined by this             specification, and depends on the server and/or connection manager             implementation.           This flag only applies to the aliases of "globally valid" contact             handles. At this time, clients should not expect to be able to             change the aliases corresponding to any channel-specific             handles. If this becomes possible in future, a new flag will             be defined.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpConnectionCapabilityFlags" role="enum">
<title>enum TpConnectionCapabilityFlags</title>
<indexterm zone="TpConnectionCapabilityFlags"><primary sortas="TpConnectionCapabilityFlags">TpConnectionCapabilityFlags</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_CAPABILITY_FLAG_CREATE = 1,
    TP_CONNECTION_CAPABILITY_FLAG_INVITE = 2,
} TpConnectionCapabilityFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-CAPABILITY-FLAG-CREATE--CAPS" role="constant">
<term><literal>TP_CONNECTION_CAPABILITY_FLAG_CREATE</literal></term>
<listitem><simpara> <![CDATA[           The given channel type and handle can be given to RequestChannel           to create a new channel of this type.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-CAPABILITY-FLAG-INVITE--CAPS" role="constant">
<term><literal>TP_CONNECTION_CAPABILITY_FLAG_INVITE</literal></term>
<listitem><simpara> <![CDATA[           The given contact can be invited to an existing channel of this type.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpConnectionPresenceType" role="enum">
<title>enum TpConnectionPresenceType</title>
<indexterm zone="TpConnectionPresenceType"><primary sortas="TpConnectionPresenceType">TpConnectionPresenceType</primary></indexterm><programlisting>typedef enum {
    TP_CONNECTION_PRESENCE_TYPE_UNSET = 0,
    TP_CONNECTION_PRESENCE_TYPE_OFFLINE = 1,
    TP_CONNECTION_PRESENCE_TYPE_AVAILABLE = 2,
    TP_CONNECTION_PRESENCE_TYPE_AWAY = 3,
    TP_CONNECTION_PRESENCE_TYPE_EXTENDED_AWAY = 4,
    TP_CONNECTION_PRESENCE_TYPE_HIDDEN = 5,
    TP_CONNECTION_PRESENCE_TYPE_BUSY = 6,
    TP_CONNECTION_PRESENCE_TYPE_UNKNOWN = 7,
    TP_CONNECTION_PRESENCE_TYPE_ERROR = 8,
} TpConnectionPresenceType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-UNSET--CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_UNSET</literal></term>
<listitem><simpara> <![CDATA[           An invalid presence type used as a null value. This value MUST NOT           appear in the Statuses property,           or in the result of GetStatuses           on the deprecated Presence           interface.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-OFFLINE--CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_OFFLINE</literal></term>
<listitem><simpara> <![CDATA[           Offline         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-AVAILABLE--CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_AVAILABLE</literal></term>
<listitem><simpara> <![CDATA[           Available         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-AWAY--CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_AWAY</literal></term>
<listitem><simpara> <![CDATA[           Away         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-EXTENDED-AWAY--CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_EXTENDED_AWAY</literal></term>
<listitem><simpara> <![CDATA[           Away for an extended time         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-HIDDEN--CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_HIDDEN</literal></term>
<listitem><simpara> <![CDATA[           Hidden (invisible)         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-BUSY--CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_BUSY</literal></term>
<listitem><simpara> <![CDATA[           Busy, Do Not Disturb.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-UNKNOWN--CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_UNKNOWN</literal></term>
<listitem><simpara> <![CDATA[           Unknown, unable to determine presence for this contact, for example           if the protocol only allows presence of subscribed contacts.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CONNECTION-PRESENCE-TYPE-ERROR--CAPS" role="constant">
<term><literal>TP_CONNECTION_PRESENCE_TYPE_ERROR</literal></term>
<listitem><simpara> <![CDATA[           Error, an error occurred while trying to determine presence.  The           message, if set, is an error from the server.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CONNECTION-PRESENCE-TYPES--CAPS" role="macro">
<title>NUM_TP_CONNECTION_PRESENCE_TYPES</title>
<indexterm zone="NUM-TP-CONNECTION-PRESENCE-TYPES--CAPS"><primary sortas="NUM_TP_CONNECTION_PRESENCE_TYPES">NUM_TP_CONNECTION_PRESENCE_TYPES</primary></indexterm><programlisting>#define             NUM_TP_CONNECTION_PRESENCE_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpConnectionPresenceType"><type>TpConnectionPresenceType</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpDTMFEvent" role="enum">
<title>enum TpDTMFEvent</title>
<indexterm zone="TpDTMFEvent"><primary sortas="TpDTMFEvent">TpDTMFEvent</primary></indexterm><programlisting>typedef enum {
    TP_DTMF_EVENT_DIGIT_0 = 0,
    TP_DTMF_EVENT_DIGIT_1 = 1,
    TP_DTMF_EVENT_DIGIT_2 = 2,
    TP_DTMF_EVENT_DIGIT_3 = 3,
    TP_DTMF_EVENT_DIGIT_4 = 4,
    TP_DTMF_EVENT_DIGIT_5 = 5,
    TP_DTMF_EVENT_DIGIT_6 = 6,
    TP_DTMF_EVENT_DIGIT_7 = 7,
    TP_DTMF_EVENT_DIGIT_8 = 8,
    TP_DTMF_EVENT_DIGIT_9 = 9,
    TP_DTMF_EVENT_ASTERISK = 10,
    TP_DTMF_EVENT_HASH = 11,
    TP_DTMF_EVENT_LETTER_A = 12,
    TP_DTMF_EVENT_LETTER_B = 13,
    TP_DTMF_EVENT_LETTER_C = 14,
    TP_DTMF_EVENT_LETTER_D = 15,
} TpDTMFEvent;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-DTMF-EVENT-DIGIT-0--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_0</literal></term>
<listitem><simpara> <![CDATA[0]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-1--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_1</literal></term>
<listitem><simpara> <![CDATA[1]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-2--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_2</literal></term>
<listitem><simpara> <![CDATA[2]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-3--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_3</literal></term>
<listitem><simpara> <![CDATA[3]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-4--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_4</literal></term>
<listitem><simpara> <![CDATA[4]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-5--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_5</literal></term>
<listitem><simpara> <![CDATA[5]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-6--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_6</literal></term>
<listitem><simpara> <![CDATA[6]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-7--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_7</literal></term>
<listitem><simpara> <![CDATA[7]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-8--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_8</literal></term>
<listitem><simpara> <![CDATA[8]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-DIGIT-9--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_DIGIT_9</literal></term>
<listitem><simpara> <![CDATA[9]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-ASTERISK--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_ASTERISK</literal></term>
<listitem><simpara> <![CDATA[*]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-HASH--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_HASH</literal></term>
<listitem><simpara> <![CDATA[#]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-LETTER-A--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_LETTER_A</literal></term>
<listitem><simpara> <![CDATA[A]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-LETTER-B--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_LETTER_B</literal></term>
<listitem><simpara> <![CDATA[B]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-LETTER-C--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_LETTER_C</literal></term>
<listitem><simpara> <![CDATA[C]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DTMF-EVENT-LETTER-D--CAPS" role="constant">
<term><literal>TP_DTMF_EVENT_LETTER_D</literal></term>
<listitem><simpara> <![CDATA[D]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-DTMF-EVENTS--CAPS" role="macro">
<title>NUM_TP_DTMF_EVENTS</title>
<indexterm zone="NUM-TP-DTMF-EVENTS--CAPS"><primary sortas="NUM_TP_DTMF_EVENTS">NUM_TP_DTMF_EVENTS</primary></indexterm><programlisting>#define             NUM_TP_DTMF_EVENTS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpDTMFEvent"><type>TpDTMFEvent</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpMediaStreamType" role="enum">
<title>enum TpMediaStreamType</title>
<indexterm zone="TpMediaStreamType"><primary sortas="TpMediaStreamType">TpMediaStreamType</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_TYPE_AUDIO = 0,
    TP_MEDIA_STREAM_TYPE_VIDEO = 1,
} TpMediaStreamType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-TYPE-AUDIO--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TYPE_AUDIO</literal></term>
<listitem><simpara> <![CDATA[An audio stream]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-TYPE-VIDEO--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TYPE_VIDEO</literal></term>
<listitem><simpara> <![CDATA[A video stream]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-TYPES--CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_TYPES</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-TYPES--CAPS"><primary sortas="NUM_TP_MEDIA_STREAM_TYPES">NUM_TP_MEDIA_STREAM_TYPES</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamType"><type>TpMediaStreamType</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpMediaStreamState" role="enum">
<title>enum TpMediaStreamState</title>
<indexterm zone="TpMediaStreamState"><primary sortas="TpMediaStreamState">TpMediaStreamState</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_STATE_DISCONNECTED = 0,
    TP_MEDIA_STREAM_STATE_CONNECTING = 1,
    TP_MEDIA_STREAM_STATE_CONNECTED = 2,
} TpMediaStreamState;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-STATE-DISCONNECTED--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_STATE_DISCONNECTED</literal></term>
<listitem><simpara> <![CDATA[The stream is disconnected.]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-STATE-CONNECTING--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_STATE_CONNECTING</literal></term>
<listitem><simpara> <![CDATA[The stream is trying to connect.]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-STATE-CONNECTED--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_STATE_CONNECTED</literal></term>
<listitem><simpara> <![CDATA[The stream is connected.]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-STATES--CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_STATES</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-STATES--CAPS"><primary sortas="NUM_TP_MEDIA_STREAM_STATES">NUM_TP_MEDIA_STREAM_STATES</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamState"><type>TpMediaStreamState</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpMediaStreamDirection" role="enum">
<title>enum TpMediaStreamDirection</title>
<indexterm zone="TpMediaStreamDirection"><primary sortas="TpMediaStreamDirection">TpMediaStreamDirection</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_DIRECTION_NONE = 0,
    TP_MEDIA_STREAM_DIRECTION_SEND = 1,
    TP_MEDIA_STREAM_DIRECTION_RECEIVE = 2,
    TP_MEDIA_STREAM_DIRECTION_BIDIRECTIONAL = 3,
} TpMediaStreamDirection;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-DIRECTION-NONE--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_DIRECTION_NONE</literal></term>
<listitem><simpara> <![CDATA[Media are not being sent or received]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-DIRECTION-SEND--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_DIRECTION_SEND</literal></term>
<listitem><simpara> <![CDATA[Media are being sent, but not received]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-DIRECTION-RECEIVE--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_DIRECTION_RECEIVE</literal></term>
<listitem><simpara> <![CDATA[Media are being received, but not sent]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-DIRECTION-BIDIRECTIONAL--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_DIRECTION_BIDIRECTIONAL</literal></term>
<listitem><simpara> <![CDATA[Media are being sent and received]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-DIRECTIONS--CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_DIRECTIONS</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-DIRECTIONS--CAPS"><primary sortas="NUM_TP_MEDIA_STREAM_DIRECTIONS">NUM_TP_MEDIA_STREAM_DIRECTIONS</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_DIRECTIONS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamDirection"><type>TpMediaStreamDirection</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpMediaStreamPendingSend" role="enum">
<title>enum TpMediaStreamPendingSend</title>
<indexterm zone="TpMediaStreamPendingSend"><primary sortas="TpMediaStreamPendingSend">TpMediaStreamPendingSend</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_PENDING_LOCAL_SEND = 1,
    TP_MEDIA_STREAM_PENDING_REMOTE_SEND = 2,
} TpMediaStreamPendingSend;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-PENDING-LOCAL-SEND--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_PENDING_LOCAL_SEND</literal></term>
<listitem><simpara> <![CDATA[             The local user has been asked to send media by the remote user.             Call RequestStreamDirection to             indicate whether or not this is acceptable.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-PENDING-REMOTE-SEND--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_PENDING_REMOTE_SEND</literal></term>
<listitem><simpara> <![CDATA[             The remote user has been asked to send media by the local user.             The StreamDirectionChanged signal             will be emitted when the remote user accepts or rejects this             change.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelMediaCapabilities" role="enum">
<title>enum TpChannelMediaCapabilities</title>
<indexterm zone="TpChannelMediaCapabilities"><primary sortas="TpChannelMediaCapabilities">TpChannelMediaCapabilities</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_MEDIA_CAPABILITY_AUDIO = 1,
    TP_CHANNEL_MEDIA_CAPABILITY_VIDEO = 2,
    TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_STUN = 4,
    TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_GTALK_P2P = 8,
    TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_ICE_UDP = 16,
    TP_CHANNEL_MEDIA_CAPABILITY_IMMUTABLE_STREAMS = 32,
} TpChannelMediaCapabilities;
</programlisting>
<para>
<![CDATA[         The channel-type-specific capability flags used for         Channel.Type.StreamedMedia in the Connection.Interface.Capabilities         interface. See the InitialAudio         property for details of the mechanisms that will replace this.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-AUDIO--CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_AUDIO</literal></term>
<listitem><simpara> <![CDATA[           The handle is capable of using audio streams within a media channel.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-VIDEO--CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_VIDEO</literal></term>
<listitem><simpara> <![CDATA[           The handle is capable of using video streams within a media channel.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-NAT-TRAVERSAL-STUN--CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_STUN</literal></term>
<listitem><simpara> <![CDATA[           The handle is capable of performing STUN to traverse NATs.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-NAT-TRAVERSAL-GTALK-P2P--CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_GTALK_P2P</literal></term>
<listitem><simpara> <![CDATA[           The handle is capable of establishing Google Talk peer-to-peer           connections (as implemented in libjingle 0.3) to traverse NATs.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-NAT-TRAVERSAL-ICE-UDP--CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_ICE_UDP</literal></term>
<listitem><simpara> <![CDATA[           The handle is capable of establishing ICE UDP peer-to-peer           connections (as defined by the IETF MMUSIC working group) to traverse           NATs.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-MEDIA-CAPABILITY-IMMUTABLE-STREAMS--CAPS" role="constant">
<term><literal>TP_CHANNEL_MEDIA_CAPABILITY_IMMUTABLE_STREAMS</literal></term>
<listitem><simpara> <![CDATA[           Channels whose target handle is this contact will have           ImmutableStreams = True.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelTextSendError" role="enum">
<title>enum TpChannelTextSendError</title>
<indexterm zone="TpChannelTextSendError"><primary sortas="TpChannelTextSendError">TpChannelTextSendError</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_TEXT_SEND_ERROR_UNKNOWN = 0,
    TP_CHANNEL_TEXT_SEND_ERROR_OFFLINE = 1,
    TP_CHANNEL_TEXT_SEND_ERROR_INVALID_CONTACT = 2,
    TP_CHANNEL_TEXT_SEND_ERROR_PERMISSION_DENIED = 3,
    TP_CHANNEL_TEXT_SEND_ERROR_TOO_LONG = 4,
    TP_CHANNEL_TEXT_SEND_ERROR_NOT_IMPLEMENTED = 5,
} TpChannelTextSendError;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-UNKNOWN--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_UNKNOWN</literal></term>
<listitem><simpara> <![CDATA[         An unknown error occurred         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-OFFLINE--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_OFFLINE</literal></term>
<listitem><simpara> <![CDATA[         The requested contact was offline         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-INVALID-CONTACT--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_INVALID_CONTACT</literal></term>
<listitem><simpara> <![CDATA[         The requested contact is not valid         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-PERMISSION-DENIED--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_PERMISSION_DENIED</literal></term>
<listitem><simpara> <![CDATA[         The user does not have permission to speak on this channel         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-TOO-LONG--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_TOO_LONG</literal></term>
<listitem><simpara> <![CDATA[         The outgoing message was too long and was rejected by the server         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-SEND-ERROR-NOT-IMPLEMENTED--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_SEND_ERROR_NOT_IMPLEMENTED</literal></term>
<listitem><simpara> <![CDATA[         The channel doesn't support sending text messages to the requested         contact         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CHANNEL-TEXT-SEND-ERRORS--CAPS" role="macro">
<title>NUM_TP_CHANNEL_TEXT_SEND_ERRORS</title>
<indexterm zone="NUM-TP-CHANNEL-TEXT-SEND-ERRORS--CAPS"><primary sortas="NUM_TP_CHANNEL_TEXT_SEND_ERRORS">NUM_TP_CHANNEL_TEXT_SEND_ERRORS</primary></indexterm><programlisting>#define             NUM_TP_CHANNEL_TEXT_SEND_ERRORS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpChannelTextSendError"><type>TpChannelTextSendError</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpChannelTextMessageType" role="enum">
<title>enum TpChannelTextMessageType</title>
<indexterm zone="TpChannelTextMessageType"><primary sortas="TpChannelTextMessageType">TpChannelTextMessageType</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_TEXT_MESSAGE_TYPE_NORMAL = 0,
    TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION = 1,
    TP_CHANNEL_TEXT_MESSAGE_TYPE_NOTICE = 2,
    TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY = 3,
    TP_CHANNEL_TEXT_MESSAGE_TYPE_DELIVERY_REPORT = 4,
} TpChannelTextMessageType;
</programlisting>
<para>
<![CDATA[         The type of message.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-NORMAL--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_NORMAL</literal></term>
<listitem><simpara> <![CDATA[         An ordinary chat message. Unknown types SHOULD be treated like this.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-ACTION--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION</literal></term>
<listitem><simpara> <![CDATA[         An action which might be presented to the user as         "* <sender> <action>", such as an IRC CTCP         ACTION (typically selected by the "/me" command). For example, the         text of the message might be "drinks more coffee".         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-NOTICE--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_NOTICE</literal></term>
<listitem><simpara> <![CDATA[         A one-off or automated message not necessarily expecting a reply         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-AUTO-REPLY--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY</literal></term>
<listitem><simpara> <![CDATA[         An automatically-generated reply message.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-TYPE-DELIVERY-REPORT--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_TYPE_DELIVERY_REPORT</literal></term>
<listitem><simpara> <![CDATA[           This message type MUST NOT appear unless the channel supports the           DeliveryReporting interface. The message MUST be as defined by           the DeliveryReporting interface.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CHANNEL-TEXT-MESSAGE-TYPES--CAPS" role="macro">
<title>NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES</title>
<indexterm zone="NUM-TP-CHANNEL-TEXT-MESSAGE-TYPES--CAPS"><primary sortas="NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES">NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES</primary></indexterm><programlisting>#define             NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpChannelTextMessageType"><type>TpChannelTextMessageType</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpChannelTextMessageFlags" role="enum">
<title>enum TpChannelTextMessageFlags</title>
<indexterm zone="TpChannelTextMessageFlags"><primary sortas="TpChannelTextMessageFlags">TpChannelTextMessageFlags</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_TEXT_MESSAGE_FLAG_TRUNCATED = 1,
    TP_CHANNEL_TEXT_MESSAGE_FLAG_NON_TEXT_CONTENT = 2,
    TP_CHANNEL_TEXT_MESSAGE_FLAG_SCROLLBACK = 4,
    TP_CHANNEL_TEXT_MESSAGE_FLAG_RESCUED = 8,
} TpChannelTextMessageFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-FLAG-TRUNCATED--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_FLAG_TRUNCATED</literal></term>
<listitem><simpara> <![CDATA[         The incoming message was truncated to a shorter length by the         server or the connection manager.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-FLAG-NON-TEXT-CONTENT--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_FLAG_NON_TEXT_CONTENT</literal></term>
<listitem><simpara> <![CDATA[           The incoming message contained non-text content which cannot be             represented by this interface, but has been signalled             in the Messages             interface.            Connection managers SHOULD only set this flag if the non-text             content appears to be relatively significant (exactly how             significant is up to the implementor). The intention is that             if this flag is set, clients using this interface SHOULD inform             the user that part of the message was not understood.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-FLAG-SCROLLBACK--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_FLAG_SCROLLBACK</literal></term>
<listitem><simpara> <![CDATA[           The incoming message was part of a replay of message history.                         In XMPP multi-user chat, a few past messages are replayed               when you join a chatroom. A sufficiently capable IRC connection               manager could also set this flag on historical messages when               connected to a proxy like bip or irssi-proxy. The existence               of this flag allows loggers and UIs to use better heuristics               when eliminating duplicates (a simple implementation made               possible by this flag would be to avoid logging scrollback               at all).                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-TEXT-MESSAGE-FLAG-RESCUED--CAPS" role="constant">
<term><literal>TP_CHANNEL_TEXT_MESSAGE_FLAG_RESCUED</literal></term>
<listitem><simpara> <![CDATA[           The incoming message has been seen in a previous channel during             the lifetime of the Connection, but             had not been acknowledged             when that channel closed, causing an identical channel (the             channel in which the message now appears) to open.                         This means that a logger (which should already have seen the               message in the previous channel) is able to recognise and ignore               these replayed messages.                    ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelChatState" role="enum">
<title>enum TpChannelChatState</title>
<indexterm zone="TpChannelChatState"><primary sortas="TpChannelChatState">TpChannelChatState</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_CHAT_STATE_GONE = 0,
    TP_CHANNEL_CHAT_STATE_INACTIVE = 1,
    TP_CHANNEL_CHAT_STATE_ACTIVE = 2,
    TP_CHANNEL_CHAT_STATE_PAUSED = 3,
    TP_CHANNEL_CHAT_STATE_COMPOSING = 4,
} TpChannelChatState;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-CHAT-STATE-GONE--CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_GONE</literal></term>
<listitem><simpara> <![CDATA[         The contact has effectively ceased participating in the chat.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CHAT-STATE-INACTIVE--CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_INACTIVE</literal></term>
<listitem><simpara> <![CDATA[         The contact has not been active for some time.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CHAT-STATE-ACTIVE--CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_ACTIVE</literal></term>
<listitem><simpara> <![CDATA[         The contact is actively participating in the chat.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CHAT-STATE-PAUSED--CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_PAUSED</literal></term>
<listitem><simpara> <![CDATA[         The contact has paused composing a message.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CHAT-STATE-COMPOSING--CAPS" role="constant">
<term><literal>TP_CHANNEL_CHAT_STATE_COMPOSING</literal></term>
<listitem><simpara> <![CDATA[         The contact is composing a message to be sent to the chat.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CHANNEL-CHAT-STATES--CAPS" role="macro">
<title>NUM_TP_CHANNEL_CHAT_STATES</title>
<indexterm zone="NUM-TP-CHANNEL-CHAT-STATES--CAPS"><primary sortas="NUM_TP_CHANNEL_CHAT_STATES">NUM_TP_CHANNEL_CHAT_STATES</primary></indexterm><programlisting>#define             NUM_TP_CHANNEL_CHAT_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpChannelChatState"><type>TpChannelChatState</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpChannelGroupFlags" role="enum">
<title>enum TpChannelGroupFlags</title>
<indexterm zone="TpChannelGroupFlags"><primary sortas="TpChannelGroupFlags">TpChannelGroupFlags</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_GROUP_FLAG_CAN_ADD = 1,
    TP_CHANNEL_GROUP_FLAG_CAN_REMOVE = 2,
    TP_CHANNEL_GROUP_FLAG_CAN_RESCIND = 4,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_ADD = 8,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_REMOVE = 16,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT = 32,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_REJECT = 64,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_RESCIND = 128,
    TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES = 256,
    TP_CHANNEL_GROUP_FLAG_ONLY_ONE_GROUP = 512,
    TP_CHANNEL_GROUP_FLAG_HANDLE_OWNERS_NOT_AVAILABLE = 1024,
    TP_CHANNEL_GROUP_FLAG_PROPERTIES = 2048,
    TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED = 4096,
    TP_CHANNEL_GROUP_FLAG_MESSAGE_DEPART = 8192,
} TpChannelGroupFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-GROUP-FLAG-CAN-ADD--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_CAN_ADD</literal></term>
<listitem><simpara> <![CDATA[             The AddMembers method can be used to             add or invite members who are             not already in the local pending list (which is always valid).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-CAN-REMOVE--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_CAN_REMOVE</literal></term>
<listitem><simpara> <![CDATA[             The RemoveMembers method can be used             to remove channel members             (removing those on the pending local list is always valid).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-CAN-RESCIND--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_CAN_RESCIND</literal></term>
<listitem><simpara> <![CDATA[             The RemoveMembers method can be used             on people on the remote             pending list.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-ADD--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_ADD</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling             AddMembers on             contacts who are not currently pending members.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-REMOVE--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_REMOVE</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling             RemoveMembers on             contacts who are currently channel members.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-ACCEPT--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling             AddMembers on             contacts who are locally pending.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-REJECT--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_REJECT</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling             RemoveMembers on             contacts who are locally pending.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-RESCIND--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_RESCIND</literal></term>
<listitem><simpara> <![CDATA[             A message may be sent to the server when calling             RemoveMembers on             contacts who are remote pending.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-CHANNEL-SPECIFIC-HANDLES--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES</literal></term>
<listitem><simpara> <![CDATA[                        The members of this group have handles which are specific to             this channel, and are not valid as general-purpose handles on             the connection. Depending on the channel, it may be possible to             check the HandleOwners property or             call GetHandleOwners to find the             owners of these handles, which should be done if you wish to (e.g.)             subscribe to the contact's presence.                                    Connection managers must ensure that any given handle is not             simultaneously a general-purpose handle and a channel-specific             handle.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-ONLY-ONE-GROUP--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_ONLY_ONE_GROUP</literal></term>
<listitem><simpara> <![CDATA[             Placing a contact in multiple groups of this type is not allowed             and will raise NotAvailable (on services where contacts may only             be in one user-defined group, user-defined groups will have             this flag).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-HANDLE-OWNERS-NOT-AVAILABLE--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_HANDLE_OWNERS_NOT_AVAILABLE</literal></term>
<listitem><simpara> <![CDATA[           In rooms with channel specific handles (ie Channel_Specific_Handles           flag is set), this flag indicates that no handle owners are           available, apart from the owner of the           SelfHandle.                         This used to be an important optimization to avoid repeated             GetHandleOwners calls, before we introduced the             HandleOwners property and             HandleOwnersChanged signal.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-PROPERTIES--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_PROPERTIES</literal></term>
<listitem><simpara> <![CDATA[           This flag indicates that all the properties introduced in           specification 0.17.6 are fully supported.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MEMBERS-CHANGED-DETAILED--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED</literal></term>
<listitem><simpara> <![CDATA[           Indicates that MembersChangedDetailed           will be emitted for changes to this group's members in addition to           MembersChanged.           Clients can then connect to the former and ignore emission of the           latter. This flag's state MUST NOT change over the lifetime of a           channel.                         If it were allowed to change, client bindings would have to always             connect to MembersChanged just in case the flag ever went away (and             generally be unnecessarily complicated), which would mostly negate             the point of having this flag in the first place.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-FLAG-MESSAGE-DEPART--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_FLAG_MESSAGE_DEPART</literal></term>
<listitem><simpara> <![CDATA[           A message may be sent to the server when calling           RemoveMembers on           the SelfHandle.                         This would be set for XMPP Multi-User Chat or IRC channels,             but not for a typical implementation of streamed media calls.                    ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelGroupChangeReason" role="enum">
<title>enum TpChannelGroupChangeReason</title>
<indexterm zone="TpChannelGroupChangeReason"><primary sortas="TpChannelGroupChangeReason">TpChannelGroupChangeReason</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_GROUP_CHANGE_REASON_NONE = 0,
    TP_CHANNEL_GROUP_CHANGE_REASON_OFFLINE = 1,
    TP_CHANNEL_GROUP_CHANGE_REASON_KICKED = 2,
    TP_CHANNEL_GROUP_CHANGE_REASON_BUSY = 3,
    TP_CHANNEL_GROUP_CHANGE_REASON_INVITED = 4,
    TP_CHANNEL_GROUP_CHANGE_REASON_BANNED = 5,
    TP_CHANNEL_GROUP_CHANGE_REASON_ERROR = 6,
    TP_CHANNEL_GROUP_CHANGE_REASON_INVALID_CONTACT = 7,
    TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER = 8,
    TP_CHANNEL_GROUP_CHANGE_REASON_RENAMED = 9,
    TP_CHANNEL_GROUP_CHANGE_REASON_PERMISSION_DENIED = 10,
    TP_CHANNEL_GROUP_CHANGE_REASON_SEPARATED = 11,
} TpChannelGroupChangeReason;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-NONE--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_NONE</literal></term>
<listitem><simpara> <![CDATA[           No reason was provided for this change.            In particular, this reason SHOULD be used when representing             users joining a named chatroom in the usual way, users leaving             a chatroom by their own request, and normal termination of a             StreamedMedia call by the remote user.            If the SelfHandle is removed from             a group for this reason and the actor is not the SelfHandle, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Terminated.            If the SelfHandle is removed from a group for this reason and             the actor is also the SelfHandle, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Cancelled.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-OFFLINE--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_OFFLINE</literal></term>
<listitem><simpara> <![CDATA[           The change is due to a user going offline. Also used when             user is already offline, but this wasn't known previously.            If a one-to-one StreamedMedia             call fails because the contact being called is offline, the             connection manager SHOULD indicate this by removing both the             SelfHandle and the other contact's             handle from the Group interface with reason Offline.                         For 1-1 calls, the call terminates as a result of removing the             remote contact, so the SelfHandle should be removed at the same             time as the remote contact and for the same reason.                       If a handle is removed from a group for this reason, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Offline.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-KICKED--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_KICKED</literal></term>
<listitem><simpara> <![CDATA[           The change is due to a kick operation.            If the SelfHandle is removed             from a group for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Channel.Kicked.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-BUSY--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_BUSY</literal></term>
<listitem><simpara> <![CDATA[           The change is due to a busy indication.            If a one-to-one StreamedMedia             call fails because the contact being called is busy, the             connection manager SHOULD indicate this by removing both the             SelfHandle and the other contact's             handle from the Group interface with reason Busy.                         For 1-1 calls, the call terminates as a result of removing the             remote contact, so the SelfHandle should be removed at the same             time as the remote contact and for the same reason.                       If the SelfHandle is removed             from a group for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Busy.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-INVITED--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_INVITED</literal></term>
<listitem><simpara> <![CDATA[           The change is due to an invitation. This reason SHOULD only be used           when contacts are added to the remote-pending set (to indicate that           the contact has been invited) or to the members (to indicate that           the contact has accepted the invitation).                         Otherwise, what would it mean?                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-BANNED--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_BANNED</literal></term>
<listitem><simpara> <![CDATA[           The change is due to a kick+ban operation.            If the SelfHandle is removed             from a group for this reason, the equivalent D-Bus error is             org.freedesktop.Telepathy.Error.Channel.Banned.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-ERROR--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_ERROR</literal></term>
<listitem><simpara> <![CDATA[             The change is due to an error occurring.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-INVALID-CONTACT--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_INVALID_CONTACT</literal></term>
<listitem><simpara> <![CDATA[           The change is because the requested contact does not exist.            For instance, if the user invites a nonexistent contact to a             chatroom or attempts to call a nonexistent contact, this could             be indicated by the CM adding that contact's handle to             remote-pending for reason None or Invited, then removing it for             reason Invalid_Contact. In the case of a 1-1 StreamedMedia             call, the CM SHOULD remove the self handle from the Group             in the same signal.                         For 1-1 calls, the call terminates as a result of removing the             remote contact, so the SelfHandle should be removed at the same             time as the remote contact and for the same reason.                       If a contact is removed from a group for this reason, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.DoesNotExist.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-NO-ANSWER--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER</literal></term>
<listitem><simpara> <![CDATA[           The change is because the requested contact did not respond.            If a one-to-one StreamedMedia             call fails because the contact being called did not respond, the             connection manager SHOULD indicate this by removing both the             SelfHandle and the other contact's             handle from the Group interface with reason No_Answer.                         Documenting existing practice.                       If a contact is removed from a group for this reason, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.NoAnswer.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-RENAMED--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_RENAMED</literal></term>
<listitem><simpara> <![CDATA[           The change is because a contact's unique identifier changed.           There must be exactly one handle in the removed set and exactly           one handle in one of the added sets. The Renamed           signal on the           Renaming           interface will have been emitted for the same handles,           shortly before this MembersChanged signal is emitted.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-PERMISSION-DENIED--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_PERMISSION_DENIED</literal></term>
<listitem><simpara> <![CDATA[           The change is because there was no permission to contact the             requested handle.            If a contact is removed from a group for this reason, the             equivalent D-Bus error is             org.freedesktop.Telepathy.Error.PermissionDenied.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-GROUP-CHANGE-REASON-SEPARATED--CAPS" role="constant">
<term><literal>TP_CHANNEL_GROUP_CHANGE_REASON_SEPARATED</literal></term>
<listitem><simpara> <![CDATA[           If members are removed with this reason code, the change is             because the group has split into unconnected parts which can only             communicate within themselves (e.g. netsplits on IRC use this             reason code).                                   If members are added with this reason code, the change is because             unconnected parts of the group have rejoined. If this channel             carries messages (e.g. Text             or Tubes             channels) applications must             assume that the contacts being added are likely to have missed some             messages as a result of the separation, and that the contacts             in the group are likely to have missed some messages from the             contacts being added.                      Note that from the added contacts' perspective, they have been             in the group all along, and the contacts we indicate to be in             the group (including the local user) have just rejoined             the group with reason Separated. Application protocols in Tubes             should be prepared to cope with this situation.                       The SelfHandle SHOULD NOT be             removed from channels with this reason.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-CHANNEL-GROUP-CHANGE-REASONS--CAPS" role="macro">
<title>NUM_TP_CHANNEL_GROUP_CHANGE_REASONS</title>
<indexterm zone="NUM-TP-CHANNEL-GROUP-CHANGE-REASONS--CAPS"><primary sortas="NUM_TP_CHANNEL_GROUP_CHANGE_REASONS">NUM_TP_CHANNEL_GROUP_CHANGE_REASONS</primary></indexterm><programlisting>#define             NUM_TP_CHANNEL_GROUP_CHANGE_REASONS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpChannelGroupChangeReason"><type>TpChannelGroupChangeReason</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpChannelPasswordFlags" role="enum">
<title>enum TpChannelPasswordFlags</title>
<indexterm zone="TpChannelPasswordFlags"><primary sortas="TpChannelPasswordFlags">TpChannelPasswordFlags</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_PASSWORD_FLAG_PROVIDE = 8,
} TpChannelPasswordFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-PASSWORD-FLAG-PROVIDE--CAPS" role="constant">
<term><literal>TP_CHANNEL_PASSWORD_FLAG_PROVIDE</literal></term>
<listitem><simpara> <![CDATA[           The ProvidePassword method must be           called now for the user to join the channel         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpDeliveryReportingSupportFlags" role="enum">
<title>enum TpDeliveryReportingSupportFlags</title>
<indexterm zone="TpDeliveryReportingSupportFlags"><primary sortas="TpDeliveryReportingSupportFlags">TpDeliveryReportingSupportFlags</primary></indexterm><programlisting>typedef enum {
    TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_FAILURES = 1,
    TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_SUCCESSES = 2,
} TpDeliveryReportingSupportFlags;
</programlisting>
<para>
<![CDATA[         Flags indicating the level of support for delivery reporting on this         channel. Any future flags added to this set will conform to the         convention that the presence of an extra flag implies that         more operations will succeed.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-DELIVERY-REPORTING-SUPPORT-FLAG-RECEIVE-FAILURES--CAPS" role="constant">
<term><literal>TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_FAILURES</literal></term>
<listitem><simpara> <![CDATA[           Clients MAY expect to receive negative delivery reports if           Message_Sending_Flag_Report_Delivery is specified when sending.                         If senders want delivery reports, they should ask for them.             If they don't want delivery reports, they can just ignore them,             so there's no need to have capability discovery for what will             happen if a delivery report isn't requested.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DELIVERY-REPORTING-SUPPORT-FLAG-RECEIVE-SUCCESSES--CAPS" role="constant">
<term><literal>TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_SUCCESSES</literal></term>
<listitem><simpara> <![CDATA[           Clients MAY expect to receive positive delivery reports if           Message_Sending_Flag_Report_Delivery is specified when sending.                         Same rationale as Receive_Failures.                    ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpDeliveryStatus" role="enum">
<title>enum TpDeliveryStatus</title>
<indexterm zone="TpDeliveryStatus"><primary sortas="TpDeliveryStatus">TpDeliveryStatus</primary></indexterm><programlisting>typedef enum {
    TP_DELIVERY_STATUS_UNKNOWN = 0,
    TP_DELIVERY_STATUS_DELIVERED = 1,
    TP_DELIVERY_STATUS_TEMPORARILY_FAILED = 2,
    TP_DELIVERY_STATUS_PERMANENTLY_FAILED = 3,
    TP_DELIVERY_STATUS_ACCEPTED = 4,
} TpDeliveryStatus;
</programlisting>
<para>
<![CDATA[         The status of a message as indicated by a delivery report.          If this enum is extended in future specifications, this should           only be to add new, non-overlapping conditions (i.e. all failures           should still be signalled as either Temporarily_Failed           or Permanently_Failed). If additional detail is required (e.g.           distinguishing between the various types of permanent failure) this           will be done using additional keys in the Message_Part.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-DELIVERY-STATUS-UNKNOWN--CAPS" role="constant">
<term><literal>TP_DELIVERY_STATUS_UNKNOWN</literal></term>
<listitem><simpara> <![CDATA[           The message's disposition is unknown.           Clients SHOULD consider all messages to have status           Delivery_Status_Unknown unless otherwise specified; connection           managers SHOULD NOT signal this delivery status explicitly.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DELIVERY-STATUS-DELIVERED--CAPS" role="constant">
<term><literal>TP_DELIVERY_STATUS_DELIVERED</literal></term>
<listitem><simpara> <![CDATA[           The message has been delivered to the intended recipient.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DELIVERY-STATUS-TEMPORARILY-FAILED--CAPS" role="constant">
<term><literal>TP_DELIVERY_STATUS_TEMPORARILY_FAILED</literal></term>
<listitem><simpara> <![CDATA[           Delivery of the message has failed. Clients SHOULD notify the user,           but MAY automatically try sending another copy of the message.                         Similar to errors with type="wait" in XMPP; analogous to             4xx errors in SMTP.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DELIVERY-STATUS-PERMANENTLY-FAILED--CAPS" role="constant">
<term><literal>TP_DELIVERY_STATUS_PERMANENTLY_FAILED</literal></term>
<listitem><simpara> <![CDATA[           Delivery of the message has failed. Clients SHOULD NOT try again           unless by specific user action. If the user does not modify the           message or alter configuration before re-sending, this error is           likely to happen again.                         Similar to errors with type="cancel", type="modify"             or type="auth" in XMPP; analogous to 5xx errors in SMTP.                    ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DELIVERY-STATUS-ACCEPTED--CAPS" role="constant">
<term><literal>TP_DELIVERY_STATUS_ACCEPTED</literal></term>
<listitem><simpara> <![CDATA[           An intermediate server has accepted the message but the message           has not been yet delivered to the ultimate recipient. The           connection manager might send a Failed report or Delivered report           later.                         Similar to "202 Accepted" success code in SIP; analogous to             251 and 252 responses in SMTP.                    ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-DELIVERY-STATUSES--CAPS" role="macro">
<title>NUM_TP_DELIVERY_STATUSES</title>
<indexterm zone="NUM-TP-DELIVERY-STATUSES--CAPS"><primary sortas="NUM_TP_DELIVERY_STATUSES">NUM_TP_DELIVERY_STATUSES</primary></indexterm><programlisting>#define             NUM_TP_DELIVERY_STATUSES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpDeliveryStatus"><type>TpDeliveryStatus</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpMediaStreamError" role="enum">
<title>enum TpMediaStreamError</title>
<indexterm zone="TpMediaStreamError"><primary sortas="TpMediaStreamError">TpMediaStreamError</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_ERROR_UNKNOWN = 0,
    TP_MEDIA_STREAM_ERROR_EOS = 1,
    TP_MEDIA_STREAM_ERROR_CODEC_NEGOTIATION_FAILED = 2,
    TP_MEDIA_STREAM_ERROR_CONNECTION_FAILED = 3,
    TP_MEDIA_STREAM_ERROR_NETWORK_ERROR = 4,
    TP_MEDIA_STREAM_ERROR_NO_CODECS = 5,
    TP_MEDIA_STREAM_ERROR_INVALID_CM_BEHAVIOR = 6,
    TP_MEDIA_STREAM_ERROR_MEDIA_ERROR = 7,
} TpMediaStreamError;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-ERROR-UNKNOWN--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_UNKNOWN</literal></term>
<listitem><simpara> <![CDATA[           An unknown error occured.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-ERROR-EOS--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_EOS</literal></term>
<listitem><simpara> <![CDATA[           The end of the stream was reached.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-ERROR-CODEC-NEGOTIATION-FAILED--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_CODEC_NEGOTIATION_FAILED</literal></term>
<listitem><simpara> <![CDATA[           There are no common codecs between the local side           and the other particpants in the call. The possible codecs are not           signalled here: the streaming implementation is assumed to report           them in an implementation-dependent way, e.g. Farsight should use           GstMissingElement.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-ERROR-CONNECTION-FAILED--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_CONNECTION_FAILED</literal></term>
<listitem><simpara> <![CDATA[           A network connection for the Media could not be established or was           lost.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-ERROR-NETWORK-ERROR--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_NETWORK_ERROR</literal></term>
<listitem><simpara> <![CDATA[           There was an error in the networking stack           (other than the connection failure).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-ERROR-NO-CODECS--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_NO_CODECS</literal></term>
<listitem><simpara> <![CDATA[           There are no installed codecs for this media type.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-ERROR-INVALID-CM-BEHAVIOR--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_INVALID_CM_BEHAVIOR</literal></term>
<listitem><simpara> <![CDATA[           The CM is doing something wrong.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-ERROR-MEDIA-ERROR--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_ERROR_MEDIA_ERROR</literal></term>
<listitem><simpara> <![CDATA[           There was an error in the media processing stack.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-ERRORS--CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_ERRORS</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-ERRORS--CAPS"><primary sortas="NUM_TP_MEDIA_STREAM_ERRORS">NUM_TP_MEDIA_STREAM_ERRORS</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_ERRORS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamError"><type>TpMediaStreamError</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpMediaStreamBaseProto" role="enum">
<title>enum TpMediaStreamBaseProto</title>
<indexterm zone="TpMediaStreamBaseProto"><primary sortas="TpMediaStreamBaseProto">TpMediaStreamBaseProto</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_BASE_PROTO_UDP = 0,
    TP_MEDIA_STREAM_BASE_PROTO_TCP = 1,
} TpMediaStreamBaseProto;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-BASE-PROTO-UDP--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_BASE_PROTO_UDP</literal></term>
<listitem><simpara> <![CDATA[UDP (User Datagram Protocol)]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-BASE-PROTO-TCP--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_BASE_PROTO_TCP</literal></term>
<listitem><simpara> <![CDATA[TCP (Transmission Control Protocol)]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-BASE-PROTOS--CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_BASE_PROTOS</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-BASE-PROTOS--CAPS"><primary sortas="NUM_TP_MEDIA_STREAM_BASE_PROTOS">NUM_TP_MEDIA_STREAM_BASE_PROTOS</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_BASE_PROTOS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamBaseProto"><type>TpMediaStreamBaseProto</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpMediaStreamTransportType" role="enum">
<title>enum TpMediaStreamTransportType</title>
<indexterm zone="TpMediaStreamTransportType"><primary sortas="TpMediaStreamTransportType">TpMediaStreamTransportType</primary></indexterm><programlisting>typedef enum {
    TP_MEDIA_STREAM_TRANSPORT_TYPE_LOCAL = 0,
    TP_MEDIA_STREAM_TRANSPORT_TYPE_DERIVED = 1,
    TP_MEDIA_STREAM_TRANSPORT_TYPE_RELAY = 2,
} TpMediaStreamTransportType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-MEDIA-STREAM-TRANSPORT-TYPE-LOCAL--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TRANSPORT_TYPE_LOCAL</literal></term>
<listitem><simpara> <![CDATA[           A local address         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-TRANSPORT-TYPE-DERIVED--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TRANSPORT_TYPE_DERIVED</literal></term>
<listitem><simpara> <![CDATA[           An external address derived by a method such as STUN         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MEDIA-STREAM-TRANSPORT-TYPE-RELAY--CAPS" role="constant">
<term><literal>TP_MEDIA_STREAM_TRANSPORT_TYPE_RELAY</literal></term>
<listitem><simpara> <![CDATA[           An external stream relay         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-MEDIA-STREAM-TRANSPORT-TYPES--CAPS" role="macro">
<title>NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES</title>
<indexterm zone="NUM-TP-MEDIA-STREAM-TRANSPORT-TYPES--CAPS"><primary sortas="NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES">NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES</primary></indexterm><programlisting>#define             NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpMediaStreamTransportType"><type>TpMediaStreamTransportType</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpPropertyFlags" role="enum">
<title>enum TpPropertyFlags</title>
<indexterm zone="TpPropertyFlags"><primary sortas="TpPropertyFlags">TpPropertyFlags</primary></indexterm><programlisting>typedef enum {
    TP_PROPERTY_FLAG_READ = 1,
    TP_PROPERTY_FLAG_WRITE = 2,
} TpPropertyFlags;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-PROPERTY-FLAG-READ--CAPS" role="constant">
<term><literal>TP_PROPERTY_FLAG_READ</literal></term>
<listitem><simpara> <![CDATA[The property can be read]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-PROPERTY-FLAG-WRITE--CAPS" role="constant">
<term><literal>TP_PROPERTY_FLAG_WRITE</literal></term>
<listitem><simpara> <![CDATA[The property can be written]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpMessagePartSupportFlags" role="enum">
<title>enum TpMessagePartSupportFlags</title>
<indexterm zone="TpMessagePartSupportFlags"><primary sortas="TpMessagePartSupportFlags">TpMessagePartSupportFlags</primary></indexterm><programlisting>typedef enum {
    TP_MESSAGE_PART_SUPPORT_FLAG_ONE_ATTACHMENT = 1,
    TP_MESSAGE_PART_SUPPORT_FLAG_MULTIPLE_ATTACHMENTS = 2,
} TpMessagePartSupportFlags;
</programlisting>
<para>
<![CDATA[         Flags indicating the level of support for message parts on this           channel. They are designed such that setting more flags always           implies that the channel has more capabilities.          If no flags are set, this indicates that messages may contain           a single message part whose content-type is any of the types           from SupportedContentTypes, possibly with some alternatives.          There is no flag indicating support for alternatives. This is           because the SendMessage implementation can always accept messages           containing alternatives, even if the underlying protocol does not,           by deleting all alternatives except the first (most preferred)           that is supported.                     Each of the flags so far implies the previous flag, so we could           have used a simple enumeration here; however, we've defined           the message-part support indicator as a flag set for future           expansion.                   See SupportedContentTypes for some           examples.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-MESSAGE-PART-SUPPORT-FLAG-ONE-ATTACHMENT--CAPS" role="constant">
<term><literal>TP_MESSAGE_PART_SUPPORT_FLAG_ONE_ATTACHMENT</literal></term>
<listitem><simpara> <![CDATA[           SendMessage will accept messages           containing a textual message body,           plus a single attachment of any type listed in the           SupportedContentTypes property. It does not make sense for this           flag to be set if Message_Part_Support_Flag_Data_Only is not also set           (because the connection manager can trivially provide an empty text           part if necessary).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-MESSAGE-PART-SUPPORT-FLAG-MULTIPLE-ATTACHMENTS--CAPS" role="constant">
<term><literal>TP_MESSAGE_PART_SUPPORT_FLAG_MULTIPLE_ATTACHMENTS</literal></term>
<listitem><simpara> <![CDATA[           SendMessage will accept messages containing a textual message body,           plus an arbitrary number of attachments of any type listed in the           SupportedContentTypes property. It does not make sense for this           flag to be set if Message_Part_Support_Flag_One_Attachment is not           also set.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpMessageSendingFlags" role="enum">
<title>enum TpMessageSendingFlags</title>
<indexterm zone="TpMessageSendingFlags"><primary sortas="TpMessageSendingFlags">TpMessageSendingFlags</primary></indexterm><programlisting>typedef enum {
    TP_MESSAGE_SENDING_FLAG_REPORT_DELIVERY = 1,
} TpMessageSendingFlags;
</programlisting>
<para>
<![CDATA[         Flags altering the way a message is sent. The "most usual" action         should always be to have these flags unset.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-MESSAGE-SENDING-FLAG-REPORT-DELIVERY--CAPS" role="constant">
<term><literal>TP_MESSAGE_SENDING_FLAG_REPORT_DELIVERY</literal></term>
<listitem><simpara> <![CDATA[           Provide a successful delivery report if possible, even if this is             not the default for this protocol. Ignored if delivery reports are             not possible on this protocol.                         In some protocols, like XMPP, it is not conventional to request               or send positive delivery notifications.                       Delivery failure reports SHOULD always be sent, but if this flag             is present, the connection manager MAY also try harder to obtain             failed delivery reports or allow them to be matched to outgoing             messages.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-SOCKET-ACCESS-CONTROLS--CAPS" role="macro">
<title>NUM_TP_SOCKET_ACCESS_CONTROLS</title>
<indexterm zone="NUM-TP-SOCKET-ACCESS-CONTROLS--CAPS"><primary sortas="NUM_TP_SOCKET_ACCESS_CONTROLS">NUM_TP_SOCKET_ACCESS_CONTROLS</primary></indexterm><programlisting>#define             NUM_TP_SOCKET_ACCESS_CONTROLS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpSocketAccessControl"><type>TpSocketAccessControl</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpSocketAccessControl" role="enum">
<title>enum TpSocketAccessControl</title>
<indexterm zone="TpSocketAccessControl"><primary sortas="TpSocketAccessControl">TpSocketAccessControl</primary></indexterm><programlisting>typedef enum {
    TP_SOCKET_ACCESS_CONTROL_LOCALHOST = 0,
    TP_SOCKET_ACCESS_CONTROL_PORT = 1,
    TP_SOCKET_ACCESS_CONTROL_NETMASK = 2,
    TP_SOCKET_ACCESS_CONTROL_CREDENTIALS = 3,
} TpSocketAccessControl;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-SOCKET-ACCESS-CONTROL-LOCALHOST--CAPS" role="constant">
<term><literal>TP_SOCKET_ACCESS_CONTROL_LOCALHOST</literal></term>
<listitem><simpara> <![CDATA[           The IP or Unix socket can be accessed by any local user (e.g.           a Unix socket that accepts all local connections, or an IP socket           listening on 127.0.0.1 (or ::1) or rejecting connections not from           that address). The associated variant must be ignored.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ACCESS-CONTROL-PORT--CAPS" role="constant">
<term><literal>TP_SOCKET_ACCESS_CONTROL_PORT</literal></term>
<listitem><simpara> <![CDATA[           May only be used on IP sockets. The associated variant must contain           a struct Socket_Address_IPv4 (or Socket_Address_IPv6)           containing the string form of an IP address of the appropriate           version, and a port number. The socket can only be accessed if the           connecting process has that address and port number; all other           connections will be rejected.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ACCESS-CONTROL-NETMASK--CAPS" role="constant">
<term><literal>TP_SOCKET_ACCESS_CONTROL_NETMASK</literal></term>
<listitem><simpara> <![CDATA[           May only be used on IP sockets. The associated variant must contain           a struct Socket_Netmask_IPv4 (or Socket_Netmask_IPv6) with           signature (sy), containing the string form of an           IP address of the appropriate version, and a prefix length "n".           The socket can only be accessed if the first n bits of the           connecting address match the first n bits of the given address.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ACCESS-CONTROL-CREDENTIALS--CAPS" role="constant">
<term><literal>TP_SOCKET_ACCESS_CONTROL_CREDENTIALS</literal></term>
<listitem><simpara> <![CDATA[           May only be used on UNIX sockets.             The connecting process must send a byte when             it first connects, which is not considered to be part of the data             stream. If the operating system uses sendmsg() with SCM_CREDS or             SCM_CREDENTIALS to pass credentials over sockets, the connecting             process must do so if possible; if not, it must still send the             byte.            The listening process will disconnect the connection unless it             can determine by OS-specific means that the connecting process             has the same user ID as the listening process.            The associated variant must be ignored.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-SOCKET-ADDRESS-TYPES--CAPS" role="macro">
<title>NUM_TP_SOCKET_ADDRESS_TYPES</title>
<indexterm zone="NUM-TP-SOCKET-ADDRESS-TYPES--CAPS"><primary sortas="NUM_TP_SOCKET_ADDRESS_TYPES">NUM_TP_SOCKET_ADDRESS_TYPES</primary></indexterm><programlisting>#define             NUM_TP_SOCKET_ADDRESS_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpSocketAddressType"><type>TpSocketAddressType</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpSocketAddressType" role="enum">
<title>enum TpSocketAddressType</title>
<indexterm zone="TpSocketAddressType"><primary sortas="TpSocketAddressType">TpSocketAddressType</primary></indexterm><programlisting>typedef enum {
    TP_SOCKET_ADDRESS_TYPE_UNIX = 0,
    TP_SOCKET_ADDRESS_TYPE_ABSTRACT_UNIX = 1,
    TP_SOCKET_ADDRESS_TYPE_IPV4 = 2,
    TP_SOCKET_ADDRESS_TYPE_IPV6 = 3,
} TpSocketAddressType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-SOCKET-ADDRESS-TYPE-UNIX--CAPS" role="constant">
<term><literal>TP_SOCKET_ADDRESS_TYPE_UNIX</literal></term>
<listitem><simpara> <![CDATA[           A Unix socket. The address variant contains a byte-array, signature 'ay',           containing the path of the socket.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ADDRESS-TYPE-ABSTRACT-UNIX--CAPS" role="constant">
<term><literal>TP_SOCKET_ADDRESS_TYPE_ABSTRACT_UNIX</literal></term>
<listitem><simpara> <![CDATA[           An abstract Unix socket. The address variant contains a byte-array,           signature 'ay', containing the path of the socket including the           leading null byte.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ADDRESS-TYPE-IPV4--CAPS" role="constant">
<term><literal>TP_SOCKET_ADDRESS_TYPE_IPV4</literal></term>
<listitem><simpara> <![CDATA[           An IPv4 socket. The address variant contains a Socket_Address_IPv4,           i.e. a structure with signature (sq)           in which the string is an IPv4 dotted-quad address literal           (and must not be a DNS name), while the 16-bit unsigned integer is           the port number.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-SOCKET-ADDRESS-TYPE-IPV6--CAPS" role="constant">
<term><literal>TP_SOCKET_ADDRESS_TYPE_IPV6</literal></term>
<listitem><simpara> <![CDATA[           An IPv6 socket. The address variant contains a Socket_Address_IPv6,           i.e. a structure with signature (sq)           in which the string is an IPv6 address literal as specified in           RFC2373 (and must not be a DNS name), while the 16-bit unsigned           integer is the port number.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-TUBE-STATES--CAPS" role="macro">
<title>NUM_TP_TUBE_STATES</title>
<indexterm zone="NUM-TP-TUBE-STATES--CAPS"><primary sortas="NUM_TP_TUBE_STATES">NUM_TP_TUBE_STATES</primary></indexterm><programlisting>#define             NUM_TP_TUBE_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpTubeState"><type>TpTubeState</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpTubeState" role="enum">
<title>enum TpTubeState</title>
<indexterm zone="TpTubeState"><primary sortas="TpTubeState">TpTubeState</primary></indexterm><programlisting>typedef enum {
    TP_TUBE_STATE_LOCAL_PENDING = 0,
    TP_TUBE_STATE_REMOTE_PENDING = 1,
    TP_TUBE_STATE_OPEN = 2,
} TpTubeState;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-TUBE-STATE-LOCAL-PENDING--CAPS" role="constant">
<term><literal>TP_TUBE_STATE_LOCAL_PENDING</literal></term>
<listitem><simpara> <![CDATA[           The tube is waiting to be accepted/closed locally.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-TUBE-STATE-REMOTE-PENDING--CAPS" role="constant">
<term><literal>TP_TUBE_STATE_REMOTE_PENDING</literal></term>
<listitem><simpara> <![CDATA[           The tube is waiting to be accepted/closed remotely.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-TUBE-STATE-OPEN--CAPS" role="constant">
<term><literal>TP_TUBE_STATE_OPEN</literal></term>
<listitem><simpara> <![CDATA[           The tube is open for traffic.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-TUBE-TYPES--CAPS" role="macro">
<title>NUM_TP_TUBE_TYPES</title>
<indexterm zone="NUM-TP-TUBE-TYPES--CAPS"><primary sortas="NUM_TP_TUBE_TYPES">NUM_TP_TUBE_TYPES</primary></indexterm><programlisting>#define             NUM_TP_TUBE_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpTubeType"><type>TpTubeType</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpTubeType" role="enum">
<title>enum TpTubeType</title>
<indexterm zone="TpTubeType"><primary sortas="TpTubeType">TpTubeType</primary></indexterm><programlisting>typedef enum {
    TP_TUBE_TYPE_DBUS = 0,
    TP_TUBE_TYPE_STREAM = 1,
} TpTubeType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-TUBE-TYPE-DBUS--CAPS" role="constant">
<term><literal>TP_TUBE_TYPE_DBUS</literal></term>
<listitem><simpara> <![CDATA[           The tube is D-Bus tube as described by the             org.freedesktop.Telepathy.Channel.Type.DBusTube interface.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-TUBE-TYPE-STREAM--CAPS" role="constant">
<term><literal>TP_TUBE_TYPE_STREAM</literal></term>
<listitem><simpara> <![CDATA[           The tube is stream tube as described by the             org.freedesktop.Telepathy.Channel.Type.StreamTube interface.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpChannelCallStateFlags" role="enum">
<title>enum TpChannelCallStateFlags</title>
<indexterm zone="TpChannelCallStateFlags"><primary sortas="TpChannelCallStateFlags">TpChannelCallStateFlags</primary></indexterm><programlisting>typedef enum {
    TP_CHANNEL_CALL_STATE_RINGING = 1,
    TP_CHANNEL_CALL_STATE_QUEUED = 2,
    TP_CHANNEL_CALL_STATE_HELD = 4,
    TP_CHANNEL_CALL_STATE_FORWARDED = 8,
    TP_CHANNEL_CALL_STATE_IN_PROGRESS = 16,
} TpChannelCallStateFlags;
</programlisting>
<para>
<![CDATA[         A set of flags representing call states.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-CHANNEL-CALL-STATE-RINGING--CAPS" role="constant">
<term><literal>TP_CHANNEL_CALL_STATE_RINGING</literal></term>
<listitem><simpara> <![CDATA[           The contact has been alerted about the call but has not responded           (e.g. 180 Ringing in SIP).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CALL-STATE-QUEUED--CAPS" role="constant">
<term><literal>TP_CHANNEL_CALL_STATE_QUEUED</literal></term>
<listitem><simpara> <![CDATA[           The contact is temporarily unavailable, and the call has been placed           in a queue (e.g. 182 Queued in SIP, or call-waiting in telephony).         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CALL-STATE-HELD--CAPS" role="constant">
<term><literal>TP_CHANNEL_CALL_STATE_HELD</literal></term>
<listitem><simpara> <![CDATA[           The contact has placed the call on hold, and will not receive           media from the local user or any other participants until they           unhold the call again.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CALL-STATE-FORWARDED--CAPS" role="constant">
<term><literal>TP_CHANNEL_CALL_STATE_FORWARDED</literal></term>
<listitem><simpara> <![CDATA[           The initiator of the call originally called a contact other than the           current recipient of the call, but the call was then forwarded or           diverted.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-CHANNEL-CALL-STATE-IN-PROGRESS--CAPS" role="constant">
<term><literal>TP_CHANNEL_CALL_STATE_IN_PROGRESS</literal></term>
<listitem><simpara> <![CDATA[           Progress has been made in placing the outgoing call, but the           destination contact may not have been made aware of the call yet           (so the Ringing state is not appropriate). This corresponds to SIP's           status code 183 Session Progress, and could be used when the           outgoing call has reached a gateway, for instance.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-LOCAL-HOLD-STATES--CAPS" role="macro">
<title>NUM_TP_LOCAL_HOLD_STATES</title>
<indexterm zone="NUM-TP-LOCAL-HOLD-STATES--CAPS"><primary sortas="NUM_TP_LOCAL_HOLD_STATES">NUM_TP_LOCAL_HOLD_STATES</primary></indexterm><programlisting>#define             NUM_TP_LOCAL_HOLD_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpLocalHoldState"><type>TpLocalHoldState</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpLocalHoldState" role="enum">
<title>enum TpLocalHoldState</title>
<indexterm zone="TpLocalHoldState"><primary sortas="TpLocalHoldState">TpLocalHoldState</primary></indexterm><programlisting>typedef enum {
    TP_LOCAL_HOLD_STATE_UNHELD = 0,
    TP_LOCAL_HOLD_STATE_HELD = 1,
    TP_LOCAL_HOLD_STATE_PENDING_HOLD = 2,
    TP_LOCAL_HOLD_STATE_PENDING_UNHOLD = 3,
} TpLocalHoldState;
</programlisting>
<para>
<![CDATA[         The hold state of a channel.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-LOCAL-HOLD-STATE-UNHELD--CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_UNHELD</literal></term>
<listitem><simpara> <![CDATA[           All streams are unheld (the call is active). New channels SHOULD           have this hold state.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-HELD--CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_HELD</literal></term>
<listitem><simpara> <![CDATA[           All streams are held (the call is on hold)         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-PENDING-HOLD--CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_PENDING_HOLD</literal></term>
<listitem><simpara> <![CDATA[           The connection manager is attempting to move to state Held, but           has not yet completed that operation. It is unspecified whether           any, all or none of the streams making up the channel are on hold.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-PENDING-UNHOLD--CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_PENDING_UNHOLD</literal></term>
<listitem><simpara> <![CDATA[           The connection manager is attempting to move to state Held, but           has not yet completed that operation. It is unspecified whether           any, all or none of the streams making up the channel are on hold.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-LOCAL-HOLD-STATE-REASONS--CAPS" role="macro">
<title>NUM_TP_LOCAL_HOLD_STATE_REASONS</title>
<indexterm zone="NUM-TP-LOCAL-HOLD-STATE-REASONS--CAPS"><primary sortas="NUM_TP_LOCAL_HOLD_STATE_REASONS">NUM_TP_LOCAL_HOLD_STATE_REASONS</primary></indexterm><programlisting>#define             NUM_TP_LOCAL_HOLD_STATE_REASONS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpLocalHoldStateReason"><type>TpLocalHoldStateReason</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpLocalHoldStateReason" role="enum">
<title>enum TpLocalHoldStateReason</title>
<indexterm zone="TpLocalHoldStateReason"><primary sortas="TpLocalHoldStateReason">TpLocalHoldStateReason</primary></indexterm><programlisting>typedef enum {
    TP_LOCAL_HOLD_STATE_REASON_NONE = 0,
    TP_LOCAL_HOLD_STATE_REASON_REQUESTED = 1,
    TP_LOCAL_HOLD_STATE_REASON_RESOURCE_NOT_AVAILABLE = 2,
} TpLocalHoldStateReason;
</programlisting>
<para>
<![CDATA[         The reason for a change to the Local_Hold_State. Clients MUST         treat unknown values as equivalent to Local_Hold_State_Reason_None.       ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-LOCAL-HOLD-STATE-REASON-NONE--CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_REASON_NONE</literal></term>
<listitem><simpara> <![CDATA[           The reason cannot be described by any of the predefined values           (connection managers SHOULD avoid this reason, but clients MUST           handle it gracefully)         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-REASON-REQUESTED--CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_REASON_REQUESTED</literal></term>
<listitem><simpara> <![CDATA[           The change is in response to a user request         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-LOCAL-HOLD-STATE-REASON-RESOURCE-NOT-AVAILABLE--CAPS" role="constant">
<term><literal>TP_LOCAL_HOLD_STATE_REASON_RESOURCE_NOT_AVAILABLE</literal></term>
<listitem><simpara> <![CDATA[           The change is because some resource was not available         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="TpRichPresenceAccessControlType" role="enum">
<title>enum TpRichPresenceAccessControlType</title>
<indexterm zone="TpRichPresenceAccessControlType"><primary sortas="TpRichPresenceAccessControlType">TpRichPresenceAccessControlType</primary></indexterm><programlisting>typedef enum {
    TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_WHITELIST = 0,
    TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_PUBLISH_LIST = 1,
    TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_GROUP = 2,
    TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_OPEN = 3,
} TpRichPresenceAccessControlType;
</programlisting>
<para>
<![CDATA[         A type of access control for Rich_Presence_Access_Control.         For most types, the exact access control is given by an associated         variant.                     These are the access control types from XMPP publish/subscribe           (XEP-0060).                ]]>
</para>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-RICH-PRESENCE-ACCESS-CONTROL-TYPE-WHITELIST--CAPS" role="constant">
<term><literal>TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_WHITELIST</literal></term>
<listitem><simpara> <![CDATA[           The associated variant is a list of contacts (signature 'au',           Contact_Handle[]) who can see the extended presence information.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-RICH-PRESENCE-ACCESS-CONTROL-TYPE-PUBLISH-LIST--CAPS" role="constant">
<term><literal>TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_PUBLISH_LIST</literal></term>
<listitem><simpara> <![CDATA[           All contacts in the user's 'publish' contact list can see the           extended presence information. The associated variant is ignored.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-RICH-PRESENCE-ACCESS-CONTROL-TYPE-GROUP--CAPS" role="constant">
<term><literal>TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_GROUP</literal></term>
<listitem><simpara> <![CDATA[           The associated variant is a handle of type Group (signature 'u',           Group_Handle) representing a group of contacts who can see the           extended presence information.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-RICH-PRESENCE-ACCESS-CONTROL-TYPE-OPEN--CAPS" role="constant">
<term><literal>TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_OPEN</literal></term>
<listitem><simpara> <![CDATA[           Anyone with access to the service can see the extended presence           information.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-RICH-PRESENCE-ACCESS-CONTROL-TYPES--CAPS" role="macro">
<title>NUM_TP_RICH_PRESENCE_ACCESS_CONTROL_TYPES</title>
<indexterm zone="NUM-TP-RICH-PRESENCE-ACCESS-CONTROL-TYPES--CAPS"><primary sortas="NUM_TP_RICH_PRESENCE_ACCESS_CONTROL_TYPES">NUM_TP_RICH_PRESENCE_ACCESS_CONTROL_TYPES</primary></indexterm><programlisting>#define             NUM_TP_RICH_PRESENCE_ACCESS_CONTROL_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpRichPresenceAccessControlType"><type>TpRichPresenceAccessControlType</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpFileHashType" role="enum">
<title>enum TpFileHashType</title>
<indexterm zone="TpFileHashType"><primary sortas="TpFileHashType">TpFileHashType</primary></indexterm><programlisting>typedef enum {
    TP_FILE_HASH_TYPE_NONE = 0,
    TP_FILE_HASH_TYPE_MD5 = 1,
    TP_FILE_HASH_TYPE_SHA1 = 2,
    TP_FILE_HASH_TYPE_SHA256 = 3,
} TpFileHashType;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-FILE-HASH-TYPE-NONE--CAPS" role="constant">
<term><literal>TP_FILE_HASH_TYPE_NONE</literal></term>
<listitem><simpara> <![CDATA[           No hash.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-HASH-TYPE-MD5--CAPS" role="constant">
<term><literal>TP_FILE_HASH_TYPE_MD5</literal></term>
<listitem><simpara> <![CDATA[           MD5 digest as a string of 32 ASCII hex digits.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-HASH-TYPE-SHA1--CAPS" role="constant">
<term><literal>TP_FILE_HASH_TYPE_SHA1</literal></term>
<listitem><simpara> <![CDATA[           SHA1 digest as a string of ASCII hex digits.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-HASH-TYPE-SHA256--CAPS" role="constant">
<term><literal>TP_FILE_HASH_TYPE_SHA256</literal></term>
<listitem><simpara> <![CDATA[           SHA256 digest as a string of ASCII hex digits.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-FILE-HASH-TYPES--CAPS" role="macro">
<title>NUM_TP_FILE_HASH_TYPES</title>
<indexterm zone="NUM-TP-FILE-HASH-TYPES--CAPS"><primary sortas="NUM_TP_FILE_HASH_TYPES">NUM_TP_FILE_HASH_TYPES</primary></indexterm><programlisting>#define             NUM_TP_FILE_HASH_TYPES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpFileHashType"><type>TpFileHashType</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpFileTransferState" role="enum">
<title>enum TpFileTransferState</title>
<indexterm zone="TpFileTransferState"><primary sortas="TpFileTransferState">TpFileTransferState</primary></indexterm><programlisting>typedef enum {
    TP_FILE_TRANSFER_STATE_NONE = 0,
    TP_FILE_TRANSFER_STATE_PENDING = 1,
    TP_FILE_TRANSFER_STATE_ACCEPTED = 2,
    TP_FILE_TRANSFER_STATE_OPEN = 3,
    TP_FILE_TRANSFER_STATE_COMPLETED = 4,
    TP_FILE_TRANSFER_STATE_CANCELLED = 5,
} TpFileTransferState;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-FILE-TRANSFER-STATE-NONE--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_NONE</literal></term>
<listitem><simpara> <![CDATA[           An invalid state type used as a null value. This value MUST NOT           appear in the State property.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-PENDING--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_PENDING</literal></term>
<listitem><simpara> <![CDATA[           The file transfer is waiting to be accepted/closed by the receiver.           The receiver has to call AcceptFile,           then wait for the state to change to Open and check the offset value.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-ACCEPTED--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_ACCEPTED</literal></term>
<listitem><simpara> <![CDATA[           The receiver has accepted the transfer. The sender now has to           call ProvideFile to actually start the transfer.           The receiver should now wait for the state to change to Open           and check the offset value.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-OPEN--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_OPEN</literal></term>
<listitem><simpara> <![CDATA[           The file transfer is open for traffic.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-COMPLETED--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_COMPLETED</literal></term>
<listitem><simpara> <![CDATA[           The file transfer has been completed successfully.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-CANCELLED--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_CANCELLED</literal></term>
<listitem><simpara> <![CDATA[           The file transfer has been cancelled.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-FILE-TRANSFER-STATES--CAPS" role="macro">
<title>NUM_TP_FILE_TRANSFER_STATES</title>
<indexterm zone="NUM-TP-FILE-TRANSFER-STATES--CAPS"><primary sortas="NUM_TP_FILE_TRANSFER_STATES">NUM_TP_FILE_TRANSFER_STATES</primary></indexterm><programlisting>#define             NUM_TP_FILE_TRANSFER_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpFileTransferState"><type>TpFileTransferState</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpFileTransferStateChangeReason" role="enum">
<title>enum TpFileTransferStateChangeReason</title>
<indexterm zone="TpFileTransferStateChangeReason"><primary sortas="TpFileTransferStateChangeReason">TpFileTransferStateChangeReason</primary></indexterm><programlisting>typedef enum {
    TP_FILE_TRANSFER_STATE_CHANGE_REASON_NONE = 0,
    TP_FILE_TRANSFER_STATE_CHANGE_REASON_REQUESTED = 1,
    TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_STOPPED = 2,
    TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_STOPPED = 3,
    TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_ERROR = 4,
    TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_ERROR = 5,
} TpFileTransferStateChangeReason;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-FILE-TRANSFER-STATE-CHANGE-REASON-NONE--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_CHANGE_REASON_NONE</literal></term>
<listitem><simpara> <![CDATA[           No reason was specified.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-CHANGE-REASON-REQUESTED--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_CHANGE_REASON_REQUESTED</literal></term>
<listitem><simpara> <![CDATA[           The change in state was requested.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-CHANGE-REASON-LOCAL-STOPPED--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_STOPPED</literal></term>
<listitem><simpara> <![CDATA[           The file transfer was cancelled by the local user.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-CHANGE-REASON-REMOTE-STOPPED--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_STOPPED</literal></term>
<listitem><simpara> <![CDATA[           The file transfer was cancelled by the remote user.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-CHANGE-REASON-LOCAL-ERROR--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_ERROR</literal></term>
<listitem><simpara> <![CDATA[           The file transfer was cancelled because of a local error.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-FILE-TRANSFER-STATE-CHANGE-REASON-REMOTE-ERROR--CAPS" role="constant">
<term><literal>TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_ERROR</literal></term>
<listitem><simpara> <![CDATA[           The file transfer was cancelled because of a remote error.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-FILE-TRANSFER-STATE-CHANGE-REASONS--CAPS" role="macro">
<title>NUM_TP_FILE_TRANSFER_STATE_CHANGE_REASONS</title>
<indexterm zone="NUM-TP-FILE-TRANSFER-STATE-CHANGE-REASONS--CAPS"><primary sortas="NUM_TP_FILE_TRANSFER_STATE_CHANGE_REASONS">NUM_TP_FILE_TRANSFER_STATE_CHANGE_REASONS</primary></indexterm><programlisting>#define             NUM_TP_FILE_TRANSFER_STATE_CHANGE_REASONS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpFileTransferStateChangeReason"><type>TpFileTransferStateChangeReason</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpTubeChannelState" role="enum">
<title>enum TpTubeChannelState</title>
<indexterm zone="TpTubeChannelState"><primary sortas="TpTubeChannelState">TpTubeChannelState</primary></indexterm><programlisting>typedef enum {
    TP_TUBE_CHANNEL_STATE_LOCAL_PENDING = 0,
    TP_TUBE_CHANNEL_STATE_REMOTE_PENDING = 1,
    TP_TUBE_CHANNEL_STATE_OPEN = 2,
    TP_TUBE_CHANNEL_STATE_NOT_OFFERED = 3,
} TpTubeChannelState;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-TUBE-CHANNEL-STATE-LOCAL-PENDING--CAPS" role="constant">
<term><literal>TP_TUBE_CHANNEL_STATE_LOCAL_PENDING</literal></term>
<listitem><simpara> <![CDATA[           The initiator offered the tube. The tube is waiting to be           accepted/closed locally. If the client accepts the tube, the tube's           state will be Open.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-TUBE-CHANNEL-STATE-REMOTE-PENDING--CAPS" role="constant">
<term><literal>TP_TUBE_CHANNEL_STATE_REMOTE_PENDING</literal></term>
<listitem><simpara> <![CDATA[           The tube is waiting to be accepted/closed remotely. If the           recipient accepts the tube, the tube's state will be Open.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-TUBE-CHANNEL-STATE-OPEN--CAPS" role="constant">
<term><literal>TP_TUBE_CHANNEL_STATE_OPEN</literal></term>
<listitem><simpara> <![CDATA[           The initiator offered the tube and the recipient accepted it. The           tube is open for traffic. The tube's state stays in this state until           it is closed.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-TUBE-CHANNEL-STATE-NOT-OFFERED--CAPS" role="constant">
<term><literal>TP_TUBE_CHANNEL_STATE_NOT_OFFERED</literal></term>
<listitem><simpara> <![CDATA[           The tube channel has been requested but the tube is not yet offered.           The client should offer the tube to the recipient and the tube's           state will be Remote_Pending. The method used to offer the tube           depends on the tube type.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-TUBE-CHANNEL-STATES--CAPS" role="macro">
<title>NUM_TP_TUBE_CHANNEL_STATES</title>
<indexterm zone="NUM-TP-TUBE-CHANNEL-STATES--CAPS"><primary sortas="NUM_TP_TUBE_CHANNEL_STATES">NUM_TP_TUBE_CHANNEL_STATES</primary></indexterm><programlisting>#define             NUM_TP_TUBE_CHANNEL_STATES</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpTubeChannelState"><type>TpTubeChannelState</type></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpDebugLevel" role="enum">
<title>enum TpDebugLevel</title>
<indexterm zone="TpDebugLevel"><primary sortas="TpDebugLevel">TpDebugLevel</primary></indexterm><programlisting>typedef enum {
    TP_DEBUG_LEVEL_ERROR = 0,
    TP_DEBUG_LEVEL_CRITICAL = 1,
    TP_DEBUG_LEVEL_WARNING = 2,
    TP_DEBUG_LEVEL_MESSAGE = 3,
    TP_DEBUG_LEVEL_INFO = 4,
    TP_DEBUG_LEVEL_DEBUG = 5,
} TpDebugLevel;
</programlisting>
<para>
Bitfield/set of flags generated from the Telepathy specification.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="TP-DEBUG-LEVEL-ERROR--CAPS" role="constant">
<term><literal>TP_DEBUG_LEVEL_ERROR</literal></term>
<listitem><simpara> <![CDATA[           Log level for errors. Error messages are always fatal, resulting           in the service terminating after something completely           unexpected occurred.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DEBUG-LEVEL-CRITICAL--CAPS" role="constant">
<term><literal>TP_DEBUG_LEVEL_CRITICAL</literal></term>
<listitem><simpara> <![CDATA[           Log level for critical messages. Critical messages are messages           that the service might predict and it is up to the service itself           to decide whether to terminate following a critical message.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DEBUG-LEVEL-WARNING--CAPS" role="constant">
<term><literal>TP_DEBUG_LEVEL_WARNING</literal></term>
<listitem><simpara> <![CDATA[           Log level for warnings.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DEBUG-LEVEL-MESSAGE--CAPS" role="constant">
<term><literal>TP_DEBUG_LEVEL_MESSAGE</literal></term>
<listitem><simpara> <![CDATA[           Log level for messages.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DEBUG-LEVEL-INFO--CAPS" role="constant">
<term><literal>TP_DEBUG_LEVEL_INFO</literal></term>
<listitem><simpara> <![CDATA[           Log level for information messages.         ]]>
</simpara></listitem>
</varlistentry>
<varlistentry id="TP-DEBUG-LEVEL-DEBUG--CAPS" role="constant">
<term><literal>TP_DEBUG_LEVEL_DEBUG</literal></term>
<listitem><simpara> <![CDATA[           Log level for debug messages.         ]]>
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="NUM-TP-DEBUG-LEVELS--CAPS" role="macro">
<title>NUM_TP_DEBUG_LEVELS</title>
<indexterm zone="NUM-TP-DEBUG-LEVELS--CAPS"><primary sortas="NUM_TP_DEBUG_LEVELS">NUM_TP_DEBUG_LEVELS</primary></indexterm><programlisting>#define             NUM_TP_DEBUG_LEVELS</programlisting>
<para>
1 higher than the highest valid value of <link linkend="TpDebugLevel"><type>TpDebugLevel</type></link>.</para>
<para>
</para></refsect2>

</refsect1>




</refentry>
