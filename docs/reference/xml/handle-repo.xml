<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="telepathy-glib-handle-repo">
<refmeta>
<refentrytitle role="top_of_page">TpHandleRepoIface</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>TpHandleRepoIface</refname>
<refpurpose>abstract interface for handle allocation</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv role="synopsis">
<title role="synopsis.title">Synopsis</title>
<anchor id="TpHandleRepoIface"/>
<synopsis>

#include &lt;telepathy-glib/handle-repo.h&gt;


                    <link linkend="TpHandleRepoIface-struct">TpHandleRepoIface</link>;
                    <link linkend="TpHandleRepoIfaceClass">TpHandleRepoIfaceClass</link>;
<link linkend="gboolean">gboolean</link>            <link linkend="tp-handle-is-valid">tp_handle_is_valid</link>                  (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-handles-are-valid">tp_handles_are_valid</link>                (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="GArray">GArray</link> *handles,
                                                         <link linkend="gboolean">gboolean</link> allow_zero,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-handles-supported-and-valid">tp_handles_supported_and_valid</link>      (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repos[NUM_TP_HANDLE_TYPES],
                                                         <link linkend="TpHandleType">TpHandleType</link> handle_type,
                                                         const <link linkend="GArray">GArray</link> *handles,
                                                         <link linkend="gboolean">gboolean</link> allow_zero,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                <link linkend="tp-handle-ref">tp_handle_ref</link>                       (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle);
<link linkend="void">void</link>                <link linkend="tp-handles-ref">tp_handles_ref</link>                      (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="GArray">GArray</link> *handles);
<link linkend="void">void</link>                <link linkend="tp-handle-unref">tp_handle_unref</link>                     (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle);
<link linkend="void">void</link>                <link linkend="tp-handles-unref">tp_handles_unref</link>                    (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="GArray">GArray</link> *handles);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-handle-client-hold">tp_handle_client_hold</link>               (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *client,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-handles-client-hold">tp_handles_client_hold</link>              (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *client,
                                                         const <link linkend="GArray">GArray</link> *handles,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-handle-client-release">tp_handle_client_release</link>            (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *client,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-handles-client-release">tp_handles_client_release</link>           (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *client,
                                                         const <link linkend="GArray">GArray</link> *handles,
                                                         <link linkend="GError">GError</link> **error);
const <link linkend="char">char</link>*         <link linkend="tp-handle-inspect">tp_handle_inspect</link>                   (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle);
<link linkend="void">void</link>                <link linkend="tp-handle-set-qdata">tp_handle_set_qdata</link>                 (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repo,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GQuark">GQuark</link> key_id,
                                                         <link linkend="gpointer">gpointer</link> data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);
<link linkend="gpointer">gpointer</link>            <link linkend="tp-handle-get-qdata">tp_handle_get_qdata</link>                 (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repo,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GQuark">GQuark</link> key_id);
<link linkend="TpHandle">TpHandle</link>            <link linkend="tp-handle-ensure">tp_handle_ensure</link>                    (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *id,
                                                         <link linkend="gpointer">gpointer</link> context,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="TpHandle">TpHandle</link>            <link linkend="tp-handle-lookup">tp_handle_lookup</link>                    (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *id,
                                                         <link linkend="gpointer">gpointer</link> context,
                                                         <link linkend="GError">GError</link> **error);


                    <link linkend="TpHandleSet">TpHandleSet</link>;
<link linkend="void">void</link>                (<link linkend="TpHandleSetMemberFunc">*TpHandleSetMemberFunc</link>)            (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="gpointer">gpointer</link> userdata);
<link linkend="TpHandleSet">TpHandleSet</link>*        <link linkend="tp-handle-set-new">tp_handle_set_new</link>                   (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repo);
<link linkend="void">void</link>                <link linkend="tp-handle-set-destroy">tp_handle_set_destroy</link>               (<link linkend="TpHandleSet">TpHandleSet</link> *set);
<link linkend="TpIntSet">TpIntSet</link>*           <link linkend="tp-handle-set-peek">tp_handle_set_peek</link>                  (<link linkend="TpHandleSet">TpHandleSet</link> *set);
<link linkend="void">void</link>                <link linkend="tp-handle-set-add">tp_handle_set_add</link>                   (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandle">TpHandle</link> handle);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-handle-set-remove">tp_handle_set_remove</link>                (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandle">TpHandle</link> handle);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-handle-set-is-member">tp_handle_set_is_member</link>             (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandle">TpHandle</link> handle);
<link linkend="void">void</link>                <link linkend="tp-handle-set-foreach">tp_handle_set_foreach</link>               (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandleSetMemberFunc">TpHandleSetMemberFunc</link> func,
                                                         <link linkend="gpointer">gpointer</link> userdata);
<link linkend="int">int</link>                 <link linkend="tp-handle-set-size">tp_handle_set_size</link>                  (<link linkend="TpHandleSet">TpHandleSet</link> *set);
<link linkend="GArray">GArray</link>*             <link linkend="tp-handle-set-to-array">tp_handle_set_to_array</link>              (<link linkend="TpHandleSet">TpHandleSet</link> *set);
<link linkend="TpIntSet">TpIntSet</link>*           <link linkend="tp-handle-set-update">tp_handle_set_update</link>                (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         const <link linkend="TpIntSet">TpIntSet</link> *add);
<link linkend="TpIntSet">TpIntSet</link>*           <link linkend="tp-handle-set-difference-update">tp_handle_set_difference_update</link>     (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         const <link linkend="TpIntSet">TpIntSet</link> *remove);
</synopsis>
</refsynopsisdiv>

<refsect1 role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<synopsis>

  <link linkend="GInterface">GInterface</link>
   +----TpHandleRepoIface
</synopsis>

</refsect1>




<refsect1 role="implementations">
<title role="implementations.title">Known Implementations</title>
<para>
TpHandleRepoIface is implemented by
 <link linkend="TpDynamicHandleRepo">TpDynamicHandleRepo</link> and  <link linkend="TpStaticHandleRepo">TpStaticHandleRepo</link>.</para>

</refsect1>




<refsect1 role="desc">
<title role="desc.title">Description</title>
<para>
Abstract interface of a repository for handles, supporting operations
which include checking for validity, reference counting, lookup by
string value and lookup by numeric value. See <link linkend="TpDynamicHandleRepo"><type>TpDynamicHandleRepo</type></link>
and <link linkend="TpStaticHandleRepo"><type>TpStaticHandleRepo</type></link> for concrete implementations.</para>
<para>

</para>
</refsect1>

<refsect1 role="details">
<title role="details.title">Details</title>
<refsect2>
<title><anchor id="TpHandleRepoIface-struct" role="struct"/>TpHandleRepoIface</title>
<indexterm><primary>TpHandleRepoIface</primary></indexterm><programlisting>typedef struct _TpHandleRepoIface TpHandleRepoIface;</programlisting>
<para>
Dummy typedef representing any implementation of this interface.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="TpHandleRepoIfaceClass" role="struct"/>TpHandleRepoIfaceClass</title>
<indexterm><primary>TpHandleRepoIfaceClass</primary></indexterm><programlisting>typedef struct _TpHandleRepoIfaceClass TpHandleRepoIfaceClass;</programlisting>
<para>
The class of a handle repository interface. The structure layout is
only available within telepathy-glib, for the handle repository
implementations' benefit.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="tp-handle-is-valid" role="function"/>tp_handle_is_valid ()</title>
<indexterm><primary>tp_handle_is_valid</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_handle_is_valid                  (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
<!--Returns: says it all--></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> A handle of the type stored in the repository <parameter>self</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> Set to InvalidHandle if <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the handle is nonzero and is present in the repository,
else <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handles-are-valid" role="function"/>tp_handles_are_valid ()</title>
<indexterm><primary>tp_handles_are_valid</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_handles_are_valid                (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="GArray">GArray</link> *handles,
                                                         <link linkend="gboolean">gboolean</link> allow_zero,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
<!--Returns: says it all--></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handles</parameter>&nbsp;:</term>
<listitem><simpara> Array of TpHandle representing handles of the type stored in
          the repository <parameter>self</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>allow_zero</parameter>&nbsp;:</term>
<listitem><simpara> If <link linkend="TRUE:CAPS"><literal>TRUE</literal></link>, zero is treated like a valid handle
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> Set to InvalidHandle if <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the handle is present in the repository, else <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handles-supported-and-valid" role="function"/>tp_handles_supported_and_valid ()</title>
<indexterm><primary>tp_handles_supported_and_valid</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_handles_supported_and_valid      (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repos[NUM_TP_HANDLE_TYPES],
                                                         <link linkend="TpHandleType">TpHandleType</link> handle_type,
                                                         const <link linkend="GArray">GArray</link> *handles,
                                                         <link linkend="gboolean">gboolean</link> allow_zero,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Return <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the given handle type is supported (i.e. repos[handle_type]
is not <link linkend="NULL:CAPS"><literal>NULL</literal></link>) and the given handles are all valid in that repository.
If not, set <parameter>error</parameter> and return <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>repos</parameter>&nbsp;:</term>
<listitem><simpara> An array of possibly null pointers to handle repositories, indexed
        by handle type, where a null pointer means an unsupported handle
        type
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle_type</parameter>&nbsp;:</term>
<listitem><simpara> The handle type
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handles</parameter>&nbsp;:</term>
<listitem><simpara> A GArray of guint representing handles of the given type
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>allow_zero</parameter>&nbsp;:</term>
<listitem><simpara> If <link linkend="TRUE:CAPS"><literal>TRUE</literal></link>, zero is treated like a valid handle
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> Used to return an error if <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the handle type is supported and the handles are all
valid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-ref" role="function"/>tp_handle_ref ()</title>
<indexterm><primary>tp_handle_ref</primary></indexterm><programlisting><link linkend="void">void</link>                tp_handle_ref                       (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle);</programlisting>
<para>
Increase the reference count of the given handle, which must be present
in the repository. For repository implementations which never free handles
(like <link linkend="TpStaticHandleRepo"><type>TpStaticHandleRepo</type></link>) this has no effect.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> A handle of the type stored in the repository
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handles-ref" role="function"/>tp_handles_ref ()</title>
<indexterm><primary>tp_handles_ref</primary></indexterm><programlisting><link linkend="void">void</link>                tp_handles_ref                      (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="GArray">GArray</link> *handles);</programlisting>
<para>
Increase the reference count of the given handles. If a handle appears
multiple times in <parameter>handles</parameter> it will be referenced that many times. If
any zero entries appear in <parameter>handles</parameter> they will be ignored without error;
it is an error for any other invalid handle to appear in <parameter>handles</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handles</parameter>&nbsp;:</term>
<listitem><simpara> A GArray of TpHandle representing handles
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-unref" role="function"/>tp_handle_unref ()</title>
<indexterm><primary>tp_handle_unref</primary></indexterm><programlisting><link linkend="void">void</link>                tp_handle_unref                     (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle);</programlisting>
<para>
Decrease the reference count of the given handle. If it reaches zero,
delete the handle. It is an error to attempt to unref a handle
which is not present in the repository.
</para>
<para>
For repository implementations which never free handles (like
<link linkend="TpStaticHandleRepo"><type>TpStaticHandleRepo</type></link>) this has no effect.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> A handle of the type stored in the repository
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handles-unref" role="function"/>tp_handles_unref ()</title>
<indexterm><primary>tp_handles_unref</primary></indexterm><programlisting><link linkend="void">void</link>                tp_handles_unref                    (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="GArray">GArray</link> *handles);</programlisting>
<para>
Decrease the reference count of the given handles. If a handle appears
multiple times in <parameter>handles</parameter> it will be dereferenced that many times. If
any zero entries appear in <parameter>handles</parameter> they will be ignored without error;
it is an error for any other invalid handle to appear in <parameter>handles</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handles</parameter>&nbsp;:</term>
<listitem><simpara> A GArray of TpHandle representing handles
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-client-hold" role="function"/>tp_handle_client_hold ()</title>
<indexterm><primary>tp_handle_client_hold</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_handle_client_hold               (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *client,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Hold the given handle on behalf of the named client.
If the client leaves the bus, the reference is automatically discarded.
</para>
<para>
Handles held multiple times are the same as handles held
once: the client either holds a handle or it doesn't. In particular,
if you call <link linkend="tp-handle-client-hold"><function>tp_handle_client_hold()</function></link> multiple times, then call
<link linkend="tp-handle-client-release"><function>tp_handle_client_release()</function></link> just once, the client no longer holds the handle.
</para>
<para>
It is an error for <parameter>handle</parameter> not to be present in the repository.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>client</parameter>&nbsp;:</term>
<listitem><simpara> The unique bus name of a D-Bus peer
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> A handle of the type stored in the repository
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> Set if <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the client name is valid; else <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handles-client-hold" role="function"/>tp_handles_client_hold ()</title>
<indexterm><primary>tp_handles_client_hold</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_handles_client_hold              (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *client,
                                                         const <link linkend="GArray">GArray</link> *handles,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Hold the given handles on behalf of the named client.
If the client leaves the bus, the reference is automatically discarded.
</para>
<para>
If any of the handles are zero they will be ignored without error.
It is an error for any other invalid handle to be in <parameter>handles</parameter>:
the caller is expected to have validated them first, e.g. using
<link linkend="tp-handles-are-valid"><function>tp_handles_are_valid()</function></link>.
</para>
<para>
Handles appearing multiple times are the same as handles appearing
once: the client either holds a handle or it doesn't.
</para>
<para>
If <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> is returned, the reference counts of all handles are unaffected
(the function either fails completely or succeeds completely).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>client</parameter>&nbsp;:</term>
<listitem><simpara> The D-Bus unique name of a client
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handles</parameter>&nbsp;:</term>
<listitem><simpara> A GArray of TpHandle representing handles
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> Used to return an error if <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the client name is valid; else <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-client-release" role="function"/>tp_handle_client_release ()</title>
<indexterm><primary>tp_handle_client_release</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_handle_client_release            (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *client,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
If the named client holds the given handle, release it.
If this causes the reference count to become zero, delete the handle.
</para>
<para>
For repository implementations which never free handles (like
<link linkend="TpStaticHandleRepo"><type>TpStaticHandleRepo</type></link>) this has no effect.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>client</parameter>&nbsp;:</term>
<listitem><simpara> The unique bus name of a D-Bus peer
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> A handle of the type stored in the repository
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> Set if <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the client name is valid and the client previously held
a reference to the handle, else <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handles-client-release" role="function"/>tp_handles_client_release ()</title>
<indexterm><primary>tp_handles_client_release</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_handles_client_release           (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *client,
                                                         const <link linkend="GArray">GArray</link> *handles,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Releases a reference to the given handles on behalf of the named client.
</para>
<para>
If any of the handles are zero they will be ignored without error.
It is an error for any other invalid handle to be in <parameter>handles</parameter>:
the caller is expected to have validated them first, e.g. using
<link linkend="tp-handles-are-valid"><function>tp_handles_are_valid()</function></link>.
</para>
<para>
If <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> is returned, the reference counts of all handles are unaffected
(the function either fails completely or succeeds completely).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>client</parameter>&nbsp;:</term>
<listitem><simpara> The D-Bus unique name of a client
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handles</parameter>&nbsp;:</term>
<listitem><simpara> A GArray of TpHandle representing handles
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> Used to return an error if <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the client name is valid and the client previously held
a reference to all the handles, else <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-inspect" role="function"/>tp_handle_inspect ()</title>
<indexterm><primary>tp_handle_inspect</primary></indexterm><programlisting>const <link linkend="char">char</link>*         tp_handle_inspect                   (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle);</programlisting>
<para>
<!--Returns: says it all--></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> A handle of the type stored in the repository
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the string represented by the given handle, or NULL if the
handle is absent from the repository. The string is owned by the
handle repository and will remain valid as long as a reference to
the handle exists.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-qdata" role="function"/>tp_handle_set_qdata ()</title>
<indexterm><primary>tp_handle_set_qdata</primary></indexterm><programlisting><link linkend="void">void</link>                tp_handle_set_qdata                 (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repo,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GQuark">GQuark</link> key_id,
                                                         <link linkend="gpointer">gpointer</link> data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy);</programlisting>
<para>
Associates a blob of data with a given handle and a given key
</para>
<para>
If <parameter>destroy</parameter> is set, then the data is freed when the handle is freed.
</para>
<para>
Inspecting the return value from this function is deprecated; it will
be declared void in a future release.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>repo</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> A handle to set data on
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>key_id</parameter>&nbsp;:</term>
<listitem><simpara> Key id to associate data with
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara> data to associate with handle
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&nbsp;:</term>
<listitem><simpara> A <link linkend="GDestroyNotify"><type>GDestroyNotify</type></link> to call to destroy the data,
          or NULL if not needed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-get-qdata" role="function"/>tp_handle_get_qdata ()</title>
<indexterm><primary>tp_handle_get_qdata</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>            tp_handle_get_qdata                 (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repo,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="GQuark">GQuark</link> key_id);</programlisting>
<para>
<!--Returns: says it all--></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>repo</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> A handle to get data from
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>key_id</parameter>&nbsp;:</term>
<listitem><simpara> Key id of data to fetch
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the data associated with a given key on a given handle; <link linkend="NULL:CAPS"><literal>NULL</literal></link>
if there is no associated data.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-ensure" role="function"/>tp_handle_ensure ()</title>
<indexterm><primary>tp_handle_ensure</primary></indexterm><programlisting><link linkend="TpHandle">TpHandle</link>            tp_handle_ensure                    (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *id,
                                                         <link linkend="gpointer">gpointer</link> context,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Return a new reference to the handle for the given string. The handle
is normalized, if possible. If no such handle exists it will be created.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>id</parameter>&nbsp;:</term>
<listitem><simpara> A string whose handle is required
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context</parameter>&nbsp;:</term>
<listitem><simpara> User data to be passed to the normalization callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> Used to return an error if 0 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the handle corresponding to the given string, or 0 if it
is invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-lookup" role="function"/>tp_handle_lookup ()</title>
<indexterm><primary>tp_handle_lookup</primary></indexterm><programlisting><link linkend="TpHandle">TpHandle</link>            tp_handle_lookup                    (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *self,
                                                         const <link linkend="gchar">gchar</link> *id,
                                                         <link linkend="gpointer">gpointer</link> context,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Return the handle for the given string, without incrementing its
reference count. The handle is normalized if possible.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&nbsp;:</term>
<listitem><simpara> A handle repository implementation
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>id</parameter>&nbsp;:</term>
<listitem><simpara> A string whose handle is required
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context</parameter>&nbsp;:</term>
<listitem><simpara> User data to be passed to the normalization callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> Used to raise an error if the handle does not exist or is
 invalid
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the handle corresponding to the given string, or 0 if it
does not exist or is invalid
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="TpHandleSet" role="struct"/>TpHandleSet</title>
<indexterm><primary>TpHandleSet</primary></indexterm><programlisting>typedef struct _TpHandleSet TpHandleSet;</programlisting>
<para>
A set of handles. This is similar to a <link linkend="TpIntSet"><type>TpIntSet</type></link> (and implemented using
one), but adding a handle to the set also references it.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="TpHandleSetMemberFunc" role="function"/>TpHandleSetMemberFunc ()</title>
<indexterm><primary>TpHandleSetMemberFunc</primary></indexterm><programlisting><link linkend="void">void</link>                (*TpHandleSetMemberFunc)            (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandle">TpHandle</link> handle,
                                                         <link linkend="gpointer">gpointer</link> userdata);</programlisting>
<para>
Signature of the callback used to iterate over the handle set in
<link linkend="tp-handle-set-foreach"><function>tp_handle_set_foreach()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara> The set of handles on which <link linkend="tp-handle-set-foreach"><function>tp_handle_set_foreach()</function></link> was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> A handle in the set
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>userdata</parameter>&nbsp;:</term>
<listitem><simpara> Arbitrary user data as supplied to <link linkend="tp-handle-set-foreach"><function>tp_handle_set_foreach()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-new" role="function"/>tp_handle_set_new ()</title>
<indexterm><primary>tp_handle_set_new</primary></indexterm><programlisting><link linkend="TpHandleSet">TpHandleSet</link>*        tp_handle_set_new                   (<link linkend="TpHandleRepoIface">TpHandleRepoIface</link> *repo);</programlisting>
<para>
Creates a new <link linkend="TpHandleSet"><type>TpHandleSet</type></link></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>repo</parameter>&nbsp;:</term>
<listitem><simpara> <link linkend="TpHandleRepo"><type>TpHandleRepo</type></link> that holds the handles to be reffed by this set
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> A new <link linkend="TpHandleSet"><type>TpHandleSet</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-destroy" role="function"/>tp_handle_set_destroy ()</title>
<indexterm><primary>tp_handle_set_destroy</primary></indexterm><programlisting><link linkend="void">void</link>                tp_handle_set_destroy               (<link linkend="TpHandleSet">TpHandleSet</link> *set);</programlisting>
<para>
Delete a <link linkend="TpHandleSet"><type>TpHandleSet</type></link> and unreference any handles that it holds</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara><link linkend="TpHandleSet"><type>TpHandleSet</type></link> to destroy
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-peek" role="function"/>tp_handle_set_peek ()</title>
<indexterm><primary>tp_handle_set_peek</primary></indexterm><programlisting><link linkend="TpIntSet">TpIntSet</link>*           tp_handle_set_peek                  (<link linkend="TpHandleSet">TpHandleSet</link> *set);</programlisting>
<para>
<!--Returns: says it all, this comment is just to keep gtkdoc happy--></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara><link linkend="TpHandleSet"><type>TpHandleSet</type></link> to peek at
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the underlying <link linkend="TpIntSet"><type>TpIntSet</type></link> used by this <link linkend="TpHandleSet"><type>TpHandleSet</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-add" role="function"/>tp_handle_set_add ()</title>
<indexterm><primary>tp_handle_set_add</primary></indexterm><programlisting><link linkend="void">void</link>                tp_handle_set_add                   (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandle">TpHandle</link> handle);</programlisting>
<para>
Add a handle to a <link linkend="TpHandleSet"><type>TpHandleSet</type></link>,and reference it in the attched
<link linkend="TpHandleRepo"><type>TpHandleRepo</type></link></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara> <link linkend="TpHandleSet"><type>TpHandleSet</type></link> to add this handle to
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> handle to add
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-remove" role="function"/>tp_handle_set_remove ()</title>
<indexterm><primary>tp_handle_set_remove</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_handle_set_remove                (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandle">TpHandle</link> handle);</programlisting>
<para>
Remove a handle to a <link linkend="TpHandleSet"><type>TpHandleSet</type></link>,and unreference it in the attched
<link linkend="TpHandleRepo"><type>TpHandleRepo</type></link></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara> <link linkend="TpHandleSet"><type>TpHandleSet</type></link> to remove this handle from
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> handle to remove
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> FALSE if the handle was invalid, or was not in this set
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-is-member" role="function"/>tp_handle_set_is_member ()</title>
<indexterm><primary>tp_handle_set_is_member</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_handle_set_is_member             (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandle">TpHandle</link> handle);</programlisting>
<para>
Check if the handle is in this set</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara> A <link linkend="TpHandleSet"><type>TpHandleSet</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&nbsp;:</term>
<listitem><simpara> handle to check
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if the handle is in this set

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-foreach" role="function"/>tp_handle_set_foreach ()</title>
<indexterm><primary>tp_handle_set_foreach</primary></indexterm><programlisting><link linkend="void">void</link>                tp_handle_set_foreach               (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         <link linkend="TpHandleSetMemberFunc">TpHandleSetMemberFunc</link> func,
                                                         <link linkend="gpointer">gpointer</link> userdata);</programlisting>
<para>
Call <parameter>func</parameter>(<parameter>set</parameter>, <parameter>handle</parameter>, <parameter>userdata</parameter>) for each handle in <parameter>set</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara> A set of handles
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara> A callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>userdata</parameter>&nbsp;:</term>
<listitem><simpara> Arbitrary data to pass to <parameter>func</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-size" role="function"/>tp_handle_set_size ()</title>
<indexterm><primary>tp_handle_set_size</primary></indexterm><programlisting><link linkend="int">int</link>                 tp_handle_set_size                  (<link linkend="TpHandleSet">TpHandleSet</link> *set);</programlisting>
<para>
<!--no further documentation needed--></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara> A set of handles
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the number of handles in this set
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-to-array" role="function"/>tp_handle_set_to_array ()</title>
<indexterm><primary>tp_handle_set_to_array</primary></indexterm><programlisting><link linkend="GArray">GArray</link>*             tp_handle_set_to_array              (<link linkend="TpHandleSet">TpHandleSet</link> *set);</programlisting>
<para>
<!--Returns: says it all, this comment is just to keep gtkdoc happy--></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara> A handle set
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a GArray of guint representing the handles in the set
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-update" role="function"/>tp_handle_set_update ()</title>
<indexterm><primary>tp_handle_set_update</primary></indexterm><programlisting><link linkend="TpIntSet">TpIntSet</link>*           tp_handle_set_update                (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         const <link linkend="TpIntSet">TpIntSet</link> *add);</programlisting>
<para>
Add a set of handles to a handle set, referencing those which are not
already members. The TpIntSet returned must be freed with tp_intset_destroy.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="TpHandleSet"><type>TpHandleSet</type></link> to update
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>add</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="TpIntSet"><type>TpIntSet</type></link> of handles to add
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the handles which were added (some subset of <parameter>add</parameter>)
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="tp-handle-set-difference-update" role="function"/>tp_handle_set_difference_update ()</title>
<indexterm><primary>tp_handle_set_difference_update</primary></indexterm><programlisting><link linkend="TpIntSet">TpIntSet</link>*           tp_handle_set_difference_update     (<link linkend="TpHandleSet">TpHandleSet</link> *set,
                                                         const <link linkend="TpIntSet">TpIntSet</link> *remove);</programlisting>
<para>
Remove a set of handles from a handle set, dereferencing those which are
members. The TpIntSet returned must be freed with tp_intset_destroy.
</para>
<para>
If you want to be able to inspect the handles in the set returned,
you must ensure that this function does not cause their refcount to drop
to zero, for instance by temporarily taking a reference to all the
handles in <parameter>remove</parameter>, calling this function, doing something with the
result and discarding the temporary references.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>set</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="TpHandleSet"><type>TpHandleSet</type></link> to update
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>remove</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="TpIntSet"><type>TpIntSet</type></link> of handles to remove
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the handles which were dereferenced and removed (some subset
 of <parameter>remove</parameter>).
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>



<refsect1>
<title>See Also</title>
TpDynamicHandleRepo, TpStaticHandleRepo
</refsect1>

</refentry>
