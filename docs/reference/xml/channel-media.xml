<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="telepathy-glib-channel-media">
<refmeta>
<refentrytitle role="top_of_page" id="telepathy-glib-channel-media.top_of_page">Media channels</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>Media channels</refname>
<refpurpose>client-side wrappers for the Streamed Media channel
 type, and the Call State, DTMF and Media Signalling interfaces</refpurpose>
</refnamediv>

<refsynopsisdiv id="telepathy-glib-channel-media.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;telepathy-glib/channel.h&gt;

<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-type-streamed-media-call-list-streams">tp_cli_channel_type_streamed_media_call_list_streams</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-type-streamed-media-callback-for-list-streams">tp_cli_channel_type_streamed_media_callback_for_list_streams</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-type-streamed-media-call-remove-streams">tp_cli_channel_type_streamed_media_call_remove_streams</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         const <link linkend="GArray">GArray</link> *in_Streams,
                                                         <link linkend="tp-cli-channel-type-streamed-media-callback-for-remove-streams">tp_cli_channel_type_streamed_media_callback_for_remove_streams</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-type-streamed-media-call-request-stream-direction">tp_cli_channel_type_streamed_media_call_request_stream_direction</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="guint">guint</link> in_Stream_Direction,
                                                         <link linkend="tp-cli-channel-type-streamed-media-callback-for-request-stream-direction">tp_cli_channel_type_streamed_media_callback_for_request_stream_direction</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-type-streamed-media-call-request-streams">tp_cli_channel_type_streamed_media_call_request_streams</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Contact_Handle,
                                                         const <link linkend="GArray">GArray</link> *in_Types,
                                                         <link linkend="tp-cli-channel-type-streamed-media-callback-for-request-streams">tp_cli_channel_type_streamed_media_callback_for_request_streams</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-type-streamed-media-callback-for-list-streams">*tp_cli_channel_type_streamed_media_callback_for_list_streams</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GPtrArray">GPtrArray</link> *out_Streams,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-type-streamed-media-callback-for-remove-streams">*tp_cli_channel_type_streamed_media_callback_for_remove_streams</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-type-streamed-media-callback-for-request-stream-direction">*tp_cli_channel_type_streamed_media_callback_for_request_stream_direction</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-type-streamed-media-callback-for-request-streams">*tp_cli_channel_type_streamed_media_callback_for_request_streams</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GPtrArray">GPtrArray</link> *out_Streams,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-type-streamed-media-run-list-streams">tp_cli_channel_type_streamed_media_run_list_streams</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GPtrArray">GPtrArray</link> **out_Streams,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-type-streamed-media-run-remove-streams">tp_cli_channel_type_streamed_media_run_remove_streams</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         const <link linkend="GArray">GArray</link> *in_Streams,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-type-streamed-media-run-request-stream-direction">tp_cli_channel_type_streamed_media_run_request_stream_direction</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="guint">guint</link> in_Stream_Direction,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-type-streamed-media-run-request-streams">tp_cli_channel_type_streamed_media_run_request_streams</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Contact_Handle,
                                                         const <link linkend="GArray">GArray</link> *in_Types,
                                                         <link linkend="GPtrArray">GPtrArray</link> **out_Streams,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-added">tp_cli_channel_type_streamed_media_connect_to_stream_added</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-added">tp_cli_channel_type_streamed_media_signal_callback_stream_added</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-direction-changed">tp_cli_channel_type_streamed_media_connect_to_stream_direction_changed</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-direction-changed">tp_cli_channel_type_streamed_media_signal_callback_stream_direction_changed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-error">tp_cli_channel_type_streamed_media_connect_to_stream_error</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-error">tp_cli_channel_type_streamed_media_signal_callback_stream_error</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-removed">tp_cli_channel_type_streamed_media_connect_to_stream_removed</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-removed">tp_cli_channel_type_streamed_media_signal_callback_stream_removed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-state-changed">tp_cli_channel_type_streamed_media_connect_to_stream_state_changed</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-state-changed">tp_cli_channel_type_streamed_media_signal_callback_stream_state_changed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-added">*tp_cli_channel_type_streamed_media_signal_callback_stream_added</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="guint">guint</link> arg_Contact_Handle,
                                                         <link linkend="guint">guint</link> arg_Stream_Type,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-direction-changed">*tp_cli_channel_type_streamed_media_signal_callback_stream_direction_changed</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="guint">guint</link> arg_Stream_Direction,
                                                         <link linkend="guint">guint</link> arg_Pending_Flags,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-error">*tp_cli_channel_type_streamed_media_signal_callback_stream_error</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="guint">guint</link> arg_Error_Code,
                                                         const <link linkend="gchar">gchar</link> *arg_Message,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-removed">*tp_cli_channel_type_streamed_media_signal_callback_stream_removed</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-state-changed">*tp_cli_channel_type_streamed_media_signal_callback_stream_state_changed</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="guint">guint</link> arg_Stream_State,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);

<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-interface-call-state-call-get-call-states">tp_cli_channel_interface_call_state_call_get_call_states</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-interface-call-state-callback-for-get-call-states">tp_cli_channel_interface_call_state_callback_for_get_call_states</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-call-state-callback-for-get-call-states">*tp_cli_channel_interface_call_state_callback_for_get_call_states</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="GHashTable">GHashTable</link> *out_States,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-interface-call-state-connect-to-call-state-changed">tp_cli_channel_interface_call_state_connect_to_call_state_changed</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-interface-call-state-signal-callback-call-state-changed">tp_cli_channel_interface_call_state_signal_callback_call_state_changed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-interface-call-state-run-get-call-states">tp_cli_channel_interface_call_state_run_get_call_states</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GHashTable">GHashTable</link> **out_States,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-call-state-signal-callback-call-state-changed">*tp_cli_channel_interface_call_state_signal_callback_call_state_changed</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Contact,
                                                         <link linkend="guint">guint</link> arg_State,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);

<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-interface-dtmf-run-start-tone">tp_cli_channel_interface_dtmf_run_start_tone</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="guchar">guchar</link> in_Event,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-interface-dtmf-run-stop-tone">tp_cli_channel_interface_dtmf_run_stop_tone</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-interface-dtmf-call-start-tone">tp_cli_channel_interface_dtmf_call_start_tone</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="guchar">guchar</link> in_Event,
                                                         <link linkend="tp-cli-channel-interface-dtmf-callback-for-start-tone">tp_cli_channel_interface_dtmf_callback_for_start_tone</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-interface-dtmf-call-stop-tone">tp_cli_channel_interface_dtmf_call_stop_tone</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="tp-cli-channel-interface-dtmf-callback-for-stop-tone">tp_cli_channel_interface_dtmf_callback_for_stop_tone</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-dtmf-callback-for-start-tone">*tp_cli_channel_interface_dtmf_callback_for_start_tone</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-dtmf-callback-for-stop-tone">*tp_cli_channel_interface_dtmf_callback_for_stop_tone</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);

<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-hold-callback-for-get-hold-state">*tp_cli_channel_interface_hold_callback_for_get_hold_state</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> out_HoldState,
                                                         <link linkend="guint">guint</link> out_Reason,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-interface-hold-call-get-hold-state">tp_cli_channel_interface_hold_call_get_hold_state</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-interface-hold-callback-for-get-hold-state">tp_cli_channel_interface_hold_callback_for_get_hold_state</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-interface-hold-run-get-hold-state">tp_cli_channel_interface_hold_run_get_hold_state</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> *out_HoldState,
                                                         <link linkend="guint">guint</link> *out_Reason,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-hold-callback-for-request-hold">*tp_cli_channel_interface_hold_callback_for_request_hold</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-interface-hold-call-request-hold">tp_cli_channel_interface_hold_call_request_hold</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="gboolean">gboolean</link> in_Hold,
                                                         <link linkend="tp-cli-channel-interface-hold-callback-for-request-hold">tp_cli_channel_interface_hold_callback_for_request_hold</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-interface-hold-run-request-hold">tp_cli_channel_interface_hold_run_request_hold</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="gboolean">gboolean</link> in_Hold,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-hold-signal-callback-hold-state-changed">*tp_cli_channel_interface_hold_signal_callback_hold_state_changed</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_HoldState,
                                                         <link linkend="guint">guint</link> arg_Reason,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-interface-hold-connect-to-hold-state-changed">tp_cli_channel_interface_hold_connect_to_hold_state_changed</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-interface-hold-signal-callback-hold-state-changed">tp_cli_channel_interface_hold_signal_callback_hold_state_changed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);

<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-interface-media-signalling-run-get-session-handlers">tp_cli_channel_interface_media_signalling_run_get_session_handlers</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GPtrArray">GPtrArray</link> **out_Session_Handlers,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-interface-media-signalling-call-get-session-handlers">tp_cli_channel_interface_media_signalling_call_get_session_handlers</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-interface-media-signalling-callback-for-get-session-handlers">tp_cli_channel_interface_media_signalling_callback_for_get_session_handlers</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-media-signalling-callback-for-get-session-handlers">*tp_cli_channel_interface_media_signalling_callback_for_get_session_handlers</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GPtrArray">GPtrArray</link> *out_Session_Handlers,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-interface-media-signalling-connect-to-new-session-handler">tp_cli_channel_interface_media_signalling_connect_to_new_session_handler</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-interface-media-signalling-signal-callback-new-session-handler">tp_cli_channel_interface_media_signalling_signal_callback_new_session_handler</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-media-signalling-signal-callback-new-session-handler">*tp_cli_channel_interface_media_signalling_signal_callback_new_session_handler</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="gchar">gchar</link> *arg_Session_Handler,
                                                         const <link linkend="gchar">gchar</link> *arg_Session_Type,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
</synopsis>
</refsynopsisdiv>









<refsect1 id="telepathy-glib-channel-media.description" role="desc">
<title role="desc.title">Description</title>
<para>
This section documents the auto-generated C wrappers for the Streamed Media
channel type, and the DTMF and Media Signalling interfaces which are
optionally supported by channels of this type.
</para>
<para>
Streamed Media channels represent real-time audio or video streaming,
including voice over IP, webcams, and telephony.
</para>
<para>
Channels of type Streamed Media may support the Media Signalling interface.
If not, the connection manager is assumed to be presenting the media
streams to the user automatically (for instance, in a connection manager
like gnome-phone-manager or telepathy-snom that remotely controls a
telephone, the phone's own speaker and microphone will probably be
used directly).
</para>
<para>
If Media Signalling is supported, the Telepathy client is responsible for
actually streaming the media, using the Media Signalling interface to
provide signalling (connection managers might implement this interface in
terms of Jingle or SDP, for instance). The Telepathy project suggests that
client authors use the Farsight library for this; the glue between Media
Signalling and Farsight is currently done in telepathy-stream-engine, an
additional D-Bus service, but it will be provided as a library in future.
</para>
<para>
Channels of type Streamed Media may also support the DTMF and
CallState interfaces.</para>
<para>
</para>
</refsect1>

<refsect1 id="telepathy-glib-channel-media.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="tp-cli-channel-type-streamed-media-call-list-streams" role="function">
<title>tp_cli_channel_type_streamed_media_call_list_streams ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-call-list-streams"><primary sortas="tp_cli_channel_type_streamed_media_call_list_streams">tp_cli_channel_type_streamed_media_call_list_streams</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_type_streamed_media_call_list_streams
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-type-streamed-media-callback-for-list-streams">tp_cli_channel_type_streamed_media_callback_for_list_streams</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a ListStreams method call.
</para>
<para>
Returns an array of structs representing the streams currently active         within this channel. Each stream is identified by an unsigned integer         which is unique for each stream within the channel.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-call-remove-streams" role="function">
<title>tp_cli_channel_type_streamed_media_call_remove_streams ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-call-remove-streams"><primary sortas="tp_cli_channel_type_streamed_media_call_remove_streams">tp_cli_channel_type_streamed_media_call_remove_streams</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_type_streamed_media_call_remove_streams
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         const <link linkend="GArray">GArray</link> *in_Streams,
                                                         <link linkend="tp-cli-channel-type-streamed-media-callback-for-remove-streams">tp_cli_channel_type_streamed_media_callback_for_remove_streams</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a RemoveStreams method call.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Request that the given streams are removed. If all streams are           removed, the channel MAY close.&lt;/p&gt;          &lt;p&gt;Clients SHOULD NOT attempt to terminate calls by removing all the           streams; instead, clients SHOULD terminate calls by removing the           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Channel.Interface&quot;&gt;Group.SelfHandle&lt;/tp:dbus-ref&gt;           from the channel, using either           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Channel.Interface.Group&quot;&gt;RemoveMembers&lt;/tp:dbus-ref&gt;           or           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Channel.Interface.Group&quot;&gt;RemoveMembersWithReason&lt;/tp:dbus-ref&gt;.           &lt;/p&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Streams</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: An array of stream identifiers (as defined in           &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt;)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-call-request-stream-direction" role="function">
<title>tp_cli_channel_type_streamed_media_call_request_stream_direction ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-call-request-stream-direction"><primary sortas="tp_cli_channel_type_streamed_media_call_request_stream_direction">tp_cli_channel_type_streamed_media_call_request_stream_direction</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_type_streamed_media_call_request_stream_direction
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="guint">guint</link> in_Stream_Direction,
                                                         <link linkend="tp-cli-channel-type-streamed-media-callback-for-request-stream-direction">tp_cli_channel_type_streamed_media_callback_for_request_stream_direction</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a RequestStreamDirection method call.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Request a change in the direction of an existing stream. In particular,         this might be useful to stop sending media of a particular type,         or inform the peer that you are no longer using media that is being         sent to you.&lt;/p&gt;          &lt;p&gt;Depending on the protocol, streams which are no longer sending in         either direction should be removed and a         &lt;tp:member-ref&gt;StreamRemoved&lt;/tp:member-ref&gt; signal emitted.         Some direction changes can be enforced locally (for example,         BIDIRECTIONAL -&amp;gt; RECEIVE can be achieved by merely stopping sending),         others may not be possible on some protocols, and some need agreement         from the remote end. In this case, the MEDIA_STREAM_PENDING_REMOTE_SEND         flag will be set in the         &lt;tp:member-ref&gt;StreamDirectionChanged&lt;/tp:member-ref&gt; signal, and the         signal         emitted again without the flag to indicate the resulting direction when         the remote end has accepted or rejected the change.&lt;/p&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: The stream identifier (as defined in           &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt;)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Stream_Direction</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: The desired stream direction (a value of MediaStreamDirection)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-call-request-streams" role="function">
<title>tp_cli_channel_type_streamed_media_call_request_streams ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-call-request-streams"><primary sortas="tp_cli_channel_type_streamed_media_call_request_streams">tp_cli_channel_type_streamed_media_call_request_streams</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_type_streamed_media_call_request_streams
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Contact_Handle,
                                                         const <link linkend="GArray">GArray</link> *in_Types,
                                                         <link linkend="tp-cli-channel-type-streamed-media-callback-for-request-streams">tp_cli_channel_type_streamed_media_callback_for_request_streams</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a RequestStreams method call.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Request that streams be established to exchange the given types of         media with the given member. In general this will try and establish a         bidirectional stream, but on some protocols it may not be possible to         indicate to the peer that you would like to receive media, so a         send-only stream will be created initially. In the cases where the         stream requires remote agreement (eg you wish to receive media from         them), the &lt;tp:member-ref&gt;StreamDirectionChanged&lt;/tp:member-ref&gt; signal         will be emitted with the         MEDIA_STREAM_PENDING_REMOTE_SEND flag set, and the signal emitted again         with the flag cleared when the remote end has replied.&lt;/p&gt;          &lt;p&gt;If streams of the requested types already exist, calling this           method results in the creation of additional streams. Accordingly,           clients wishing to have exactly one audio stream or exactly one           video stream SHOULD check for the current streams using           &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt; before calling this           method.&lt;/p&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Contact_Handle</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A contact handle with whom to establish the streams
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Types</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: An array of stream types (values of MediaStreamType)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-callback-for-list-streams" role="function">
<title>tp_cli_channel_type_streamed_media_callback_for_list_streams ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-callback-for-list-streams"><primary sortas="tp_cli_channel_type_streamed_media_callback_for_list_streams">tp_cli_channel_type_streamed_media_callback_for_list_streams</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_type_streamed_media_callback_for_list_streams)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GPtrArray">GPtrArray</link> *out_Streams,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a ListStreams method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Streams</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: &lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;           An array of structs containing:           &lt;ul&gt;           &lt;li&gt;the stream identifier&lt;/li&gt;           &lt;li&gt;the contact handle who the stream is with (or 0 if the stream             represents more than a single member)&lt;/li&gt;           &lt;li&gt;the type of the stream&lt;/li&gt;           &lt;li&gt;the current stream state&lt;/li&gt;           &lt;li&gt;the current direction of the stream&lt;/li&gt;           &lt;li&gt;the current pending send flags&lt;/li&gt;           &lt;/ul&gt;
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-callback-for-remove-streams" role="function">
<title>tp_cli_channel_type_streamed_media_callback_for_remove_streams ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-callback-for-remove-streams"><primary sortas="tp_cli_channel_type_streamed_media_callback_for_remove_streams">tp_cli_channel_type_streamed_media_callback_for_remove_streams</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_type_streamed_media_callback_for_remove_streams)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a RemoveStreams method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-callback-for-request-stream-direction" role="function">
<title>tp_cli_channel_type_streamed_media_callback_for_request_stream_direction ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-callback-for-request-stream-direction"><primary sortas="tp_cli_channel_type_streamed_media_callback_for_request_stream_direction">tp_cli_channel_type_streamed_media_callback_for_request_stream_direction</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_type_streamed_media_callback_for_request_stream_direction)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a RequestStreamDirection method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-callback-for-request-streams" role="function">
<title>tp_cli_channel_type_streamed_media_callback_for_request_streams ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-callback-for-request-streams"><primary sortas="tp_cli_channel_type_streamed_media_callback_for_request_streams">tp_cli_channel_type_streamed_media_callback_for_request_streams</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_type_streamed_media_callback_for_request_streams)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GPtrArray">GPtrArray</link> *out_Streams,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a RequestStreams method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Streams</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: &lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;           An array of structs (in the same order as the given stream types)           containing:           &lt;ul&gt;             &lt;li&gt;the stream identifier&lt;/li&gt;             &lt;li&gt;the contact handle who the stream is with (or 0 if the stream               represents more than a single member)&lt;/li&gt;             &lt;li&gt;the type of the stream&lt;/li&gt;             &lt;li&gt;the current stream state&lt;/li&gt;             &lt;li&gt;the current direction of the stream&lt;/li&gt;             &lt;li&gt;the current pending send flags&lt;/li&gt;           &lt;/ul&gt;
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-run-list-streams" role="function">
<title>tp_cli_channel_type_streamed_media_run_list_streams ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-run-list-streams"><primary sortas="tp_cli_channel_type_streamed_media_run_list_streams">tp_cli_channel_type_streamed_media_run_list_streams</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_type_streamed_media_run_list_streams
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GPtrArray">GPtrArray</link> **out_Streams,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method ListStreams and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Returns an array of structs representing the streams currently active         within this channel. Each stream is identified by an unsigned integer         which is unique for each stream within the channel.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Streams</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: &lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;           An array of structs containing:           &lt;ul&gt;           &lt;li&gt;the stream identifier&lt;/li&gt;           &lt;li&gt;the contact handle who the stream is with (or 0 if the stream             represents more than a single member)&lt;/li&gt;           &lt;li&gt;the type of the stream&lt;/li&gt;           &lt;li&gt;the current stream state&lt;/li&gt;           &lt;li&gt;the current direction of the stream&lt;/li&gt;           &lt;li&gt;the current pending send flags&lt;/li&gt;           &lt;/ul&gt;
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-run-remove-streams" role="function">
<title>tp_cli_channel_type_streamed_media_run_remove_streams ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-run-remove-streams"><primary sortas="tp_cli_channel_type_streamed_media_run_remove_streams">tp_cli_channel_type_streamed_media_run_remove_streams</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_type_streamed_media_run_remove_streams
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         const <link linkend="GArray">GArray</link> *in_Streams,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method RemoveStreams and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Request that the given streams are removed. If all streams are           removed, the channel MAY close.&lt;/p&gt;          &lt;p&gt;Clients SHOULD NOT attempt to terminate calls by removing all the           streams; instead, clients SHOULD terminate calls by removing the           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Channel.Interface&quot;&gt;Group.SelfHandle&lt;/tp:dbus-ref&gt;           from the channel, using either           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Channel.Interface.Group&quot;&gt;RemoveMembers&lt;/tp:dbus-ref&gt;           or           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy.Channel.Interface.Group&quot;&gt;RemoveMembersWithReason&lt;/tp:dbus-ref&gt;.           &lt;/p&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Streams</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: An array of stream identifiers (as defined in           &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt;)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-run-request-stream-direction" role="function">
<title>tp_cli_channel_type_streamed_media_run_request_stream_direction ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-run-request-stream-direction"><primary sortas="tp_cli_channel_type_streamed_media_run_request_stream_direction">tp_cli_channel_type_streamed_media_run_request_stream_direction</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_type_streamed_media_run_request_stream_direction
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="guint">guint</link> in_Stream_Direction,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method RequestStreamDirection and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Request a change in the direction of an existing stream. In particular,         this might be useful to stop sending media of a particular type,         or inform the peer that you are no longer using media that is being         sent to you.&lt;/p&gt;          &lt;p&gt;Depending on the protocol, streams which are no longer sending in         either direction should be removed and a         &lt;tp:member-ref&gt;StreamRemoved&lt;/tp:member-ref&gt; signal emitted.         Some direction changes can be enforced locally (for example,         BIDIRECTIONAL -&amp;gt; RECEIVE can be achieved by merely stopping sending),         others may not be possible on some protocols, and some need agreement         from the remote end. In this case, the MEDIA_STREAM_PENDING_REMOTE_SEND         flag will be set in the         &lt;tp:member-ref&gt;StreamDirectionChanged&lt;/tp:member-ref&gt; signal, and the         signal         emitted again without the flag to indicate the resulting direction when         the remote end has accepted or rejected the change.&lt;/p&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: The stream identifier (as defined in           &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt;)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Stream_Direction</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: The desired stream direction (a value of MediaStreamDirection)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-run-request-streams" role="function">
<title>tp_cli_channel_type_streamed_media_run_request_streams ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-run-request-streams"><primary sortas="tp_cli_channel_type_streamed_media_run_request_streams">tp_cli_channel_type_streamed_media_run_request_streams</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_type_streamed_media_run_request_streams
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Contact_Handle,
                                                         const <link linkend="GArray">GArray</link> *in_Types,
                                                         <link linkend="GPtrArray">GPtrArray</link> **out_Streams,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method RequestStreams and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Request that streams be established to exchange the given types of         media with the given member. In general this will try and establish a         bidirectional stream, but on some protocols it may not be possible to         indicate to the peer that you would like to receive media, so a         send-only stream will be created initially. In the cases where the         stream requires remote agreement (eg you wish to receive media from         them), the &lt;tp:member-ref&gt;StreamDirectionChanged&lt;/tp:member-ref&gt; signal         will be emitted with the         MEDIA_STREAM_PENDING_REMOTE_SEND flag set, and the signal emitted again         with the flag cleared when the remote end has replied.&lt;/p&gt;          &lt;p&gt;If streams of the requested types already exist, calling this           method results in the creation of additional streams. Accordingly,           clients wishing to have exactly one audio stream or exactly one           video stream SHOULD check for the current streams using           &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt; before calling this           method.&lt;/p&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Contact_Handle</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A contact handle with whom to establish the streams
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Types</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: An array of stream types (values of MediaStreamType)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Streams</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: &lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;           An array of structs (in the same order as the given stream types)           containing:           &lt;ul&gt;             &lt;li&gt;the stream identifier&lt;/li&gt;             &lt;li&gt;the contact handle who the stream is with (or 0 if the stream               represents more than a single member)&lt;/li&gt;             &lt;li&gt;the type of the stream&lt;/li&gt;             &lt;li&gt;the current stream state&lt;/li&gt;             &lt;li&gt;the current direction of the stream&lt;/li&gt;             &lt;li&gt;the current pending send flags&lt;/li&gt;           &lt;/ul&gt;
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-connect-to-stream-added" role="function">
<title>tp_cli_channel_type_streamed_media_connect_to_stream_added ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-connect-to-stream-added"><primary sortas="tp_cli_channel_type_streamed_media_connect_to_stream_added">tp_cli_channel_type_streamed_media_connect_to_stream_added</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_type_streamed_media_connect_to_stream_added
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-added">tp_cli_channel_type_streamed_media_signal_callback_stream_added</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal StreamAdded.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Emitted when a new stream has been added to this channel.           Clients SHOULD assume that the stream&apos;s           &lt;tp:type&gt;Media_Stream_State&lt;/tp:type&gt; is initially Disconnected.&lt;/p&gt;          &lt;p&gt;If a connection manager needs to represent the addition of a stream           whose state is already Connecting or Connected, it MUST do this           by emitting StreamAdded, closely followed by           &lt;tp:member-ref&gt;StreamStateChanged&lt;/tp:member-ref&gt; indicating a           change to the appropriate state.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;Historically, it was not clear from the StreamAdded signal what             the state of the stream was. telepathy-spec 0.17.22             clarified this.&lt;/p&gt;         &lt;/tp:rationale&gt;          &lt;p&gt;Similarly, clients SHOULD assume that the initial           &lt;tp:type&gt;Media_Stream_Direction&lt;/tp:type&gt; of a newly added stream           is Receive, and that the initial           &lt;tp:type&gt;Media_Stream_Pending_Send&lt;/tp:type&gt; is           Pending_Local_Send.&lt;/p&gt;          &lt;p&gt;If a connection manager needs to represent the addition of a stream           whose direction or pending-send differs from those initial values,           it MUST do so by emitting StreamAdded, closely followed by           &lt;tp:member-ref&gt;StreamDirectionChanged&lt;/tp:member-ref&gt; indicating a           change to the appropriate direction and pending-send state.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;StreamAdded doesn&apos;t itself indicate the stream&apos;s direction; this             is unfortunate, but is preserved for compatibility.&lt;/p&gt;            &lt;p&gt;This is the appropriate direction for streams added by a remote             contact on existing connection managers, and does not violate             user privacy by automatically sending audio or video (audio streams             start off muted, video streams start off not sending). For             streams added by the local user using the client receiving the             signal, the true direction can also be determined from the return             value of the &lt;tp:member-ref&gt;RequestStreams&lt;/tp:member-ref&gt;             method.&lt;/p&gt;            &lt;p&gt;Existing clients typically operate by maintaining a separate             idea of the directions that they would like the streams to have,             and enforcing these intended directions by calling             &lt;tp:member-ref&gt;RequestStreamDirection&lt;/tp:member-ref&gt; whenever             needed.&lt;/p&gt;         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-connect-to-stream-direction-changed" role="function">
<title>tp_cli_channel_type_streamed_media_connect_to_stream_direction_changed ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-connect-to-stream-direction-changed"><primary sortas="tp_cli_channel_type_streamed_media_connect_to_stream_direction_changed">tp_cli_channel_type_streamed_media_connect_to_stream_direction_changed</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_type_streamed_media_connect_to_stream_direction_changed
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-direction-changed">tp_cli_channel_type_streamed_media_signal_callback_stream_direction_changed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal StreamDirectionChanged.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Emitted when the direction or pending flags of a stream are           changed.&lt;/p&gt;          &lt;p&gt;If the MEDIA_STREAM_PENDING_LOCAL_SEND flag is set, the remote user           has requested that we begin sending on this stream.           &lt;tp:member-ref&gt;RequestStreamDirection&lt;/tp:member-ref&gt;           should be called to indicate whether or not this change is           acceptable.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;This allows for a MSN-style user interface, &amp;quot;Fred has asked you             to enable your webcam. (Accept | Reject)&amp;quot;, if desired.&lt;/p&gt;         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-connect-to-stream-error" role="function">
<title>tp_cli_channel_type_streamed_media_connect_to_stream_error ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-connect-to-stream-error"><primary sortas="tp_cli_channel_type_streamed_media_connect_to_stream_error">tp_cli_channel_type_streamed_media_connect_to_stream_error</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_type_streamed_media_connect_to_stream_error
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-error">tp_cli_channel_type_streamed_media_signal_callback_stream_error</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal StreamError.
</para>
<para>
Emitted when a stream encounters an error.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-connect-to-stream-removed" role="function">
<title>tp_cli_channel_type_streamed_media_connect_to_stream_removed ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-connect-to-stream-removed"><primary sortas="tp_cli_channel_type_streamed_media_connect_to_stream_removed">tp_cli_channel_type_streamed_media_connect_to_stream_removed</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_type_streamed_media_connect_to_stream_removed
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-removed">tp_cli_channel_type_streamed_media_signal_callback_stream_removed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal StreamRemoved.
</para>
<para>
Emitted when a stream has been removed from this channel.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-connect-to-stream-state-changed" role="function">
<title>tp_cli_channel_type_streamed_media_connect_to_stream_state_changed ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-connect-to-stream-state-changed"><primary sortas="tp_cli_channel_type_streamed_media_connect_to_stream_state_changed">tp_cli_channel_type_streamed_media_connect_to_stream_state_changed</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_type_streamed_media_connect_to_stream_state_changed
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-type-streamed-media-signal-callback-stream-state-changed">tp_cli_channel_type_streamed_media_signal_callback_stream_state_changed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal StreamStateChanged.
</para>
<para>
Emitted when a member&apos;s stream&apos;s state changes.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-signal-callback-stream-added" role="function">
<title>tp_cli_channel_type_streamed_media_signal_callback_stream_added ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-signal-callback-stream-added"><primary sortas="tp_cli_channel_type_streamed_media_signal_callback_stream_added">tp_cli_channel_type_streamed_media_signal_callback_stream_added</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_type_streamed_media_signal_callback_stream_added)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="guint">guint</link> arg_Contact_Handle,
                                                         <link linkend="guint">guint</link> arg_Stream_Type,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal StreamAdded.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-added"><function>tp_cli_channel_type_streamed_media_connect_to_stream_added()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> The stream identifier (as defined in           &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt;)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Contact_Handle</parameter>&#160;:</term>
<listitem><simpara> The contact handle who the stream is with (or 0 if it           represents more than a single member)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Stream_Type</parameter>&#160;:</term>
<listitem><simpara> The stream type (a value from MediaStreamType)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-signal-callback-stream-direction-changed" role="function">
<title>tp_cli_channel_type_streamed_media_signal_callback_stream_direction_changed ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-signal-callback-stream-direction-changed"><primary sortas="tp_cli_channel_type_streamed_media_signal_callback_stream_direction_changed">tp_cli_channel_type_streamed_media_signal_callback_stream_direction_changed</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_type_streamed_media_signal_callback_stream_direction_changed)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="guint">guint</link> arg_Stream_Direction,
                                                         <link linkend="guint">guint</link> arg_Pending_Flags,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal StreamDirectionChanged.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-direction-changed"><function>tp_cli_channel_type_streamed_media_connect_to_stream_direction_changed()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> The stream identifier (as defined in &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt;)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Stream_Direction</parameter>&#160;:</term>
<listitem><simpara> The new stream direction (as defined in ListStreams)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Pending_Flags</parameter>&#160;:</term>
<listitem><simpara> The new pending send flags (as defined in ListStreams)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-signal-callback-stream-error" role="function">
<title>tp_cli_channel_type_streamed_media_signal_callback_stream_error ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-signal-callback-stream-error"><primary sortas="tp_cli_channel_type_streamed_media_signal_callback_stream_error">tp_cli_channel_type_streamed_media_signal_callback_stream_error</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_type_streamed_media_signal_callback_stream_error)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="guint">guint</link> arg_Error_Code,
                                                         const <link linkend="gchar">gchar</link> *arg_Message,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal StreamError.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-error"><function>tp_cli_channel_type_streamed_media_connect_to_stream_error()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> The stream identifier (as defined in         &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt;)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Error_Code</parameter>&#160;:</term>
<listitem><simpara> A stream error number, one of the values of MediaStreamError
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Message</parameter>&#160;:</term>
<listitem><simpara> A string describing the error (for debugging purposes only)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-signal-callback-stream-removed" role="function">
<title>tp_cli_channel_type_streamed_media_signal_callback_stream_removed ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-signal-callback-stream-removed"><primary sortas="tp_cli_channel_type_streamed_media_signal_callback_stream_removed">tp_cli_channel_type_streamed_media_signal_callback_stream_removed</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_type_streamed_media_signal_callback_stream_removed)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal StreamRemoved.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-removed"><function>tp_cli_channel_type_streamed_media_connect_to_stream_removed()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> stream_id - the stream identifier (as defined in         &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt;)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-type-streamed-media-signal-callback-stream-state-changed" role="function">
<title>tp_cli_channel_type_streamed_media_signal_callback_stream_state_changed ()</title>
<indexterm zone="tp-cli-channel-type-streamed-media-signal-callback-stream-state-changed"><primary sortas="tp_cli_channel_type_streamed_media_signal_callback_stream_state_changed">tp_cli_channel_type_streamed_media_signal_callback_stream_state_changed</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_type_streamed_media_signal_callback_stream_state_changed)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Stream_ID,
                                                         <link linkend="guint">guint</link> arg_Stream_State,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal StreamStateChanged.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-type-streamed-media-connect-to-stream-state-changed"><function>tp_cli_channel_type_streamed_media_connect_to_stream_state_changed()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> The stream identifier (as defined in           &lt;tp:member-ref&gt;ListStreams&lt;/tp:member-ref&gt;)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Stream_State</parameter>&#160;:</term>
<listitem><simpara> The new stream state (as defined in ListStreams)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-call-state-call-get-call-states" role="function">
<title>tp_cli_channel_interface_call_state_call_get_call_states ()</title>
<indexterm zone="tp-cli-channel-interface-call-state-call-get-call-states"><primary sortas="tp_cli_channel_interface_call_state_call_get_call_states">tp_cli_channel_interface_call_state_call_get_call_states</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_interface_call_state_call_get_call_states
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-interface-call-state-callback-for-get-call-states">tp_cli_channel_interface_call_state_callback_for_get_call_states</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a GetCallStates method call.
</para>
<para>
Get the current call states for all contacts involved in this call.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-call-state-callback-for-get-call-states" role="function">
<title>tp_cli_channel_interface_call_state_callback_for_get_call_states ()</title>
<indexterm zone="tp-cli-channel-interface-call-state-callback-for-get-call-states"><primary sortas="tp_cli_channel_interface_call_state_callback_for_get_call_states">tp_cli_channel_interface_call_state_callback_for_get_call_states</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_call_state_callback_for_get_call_states)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="GHashTable">GHashTable</link> *out_States,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a GetCallStates method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_States</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: The current call states. Participants where the call state flags           would be 0 (all unset) may be omitted from this mapping.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-call-state-connect-to-call-state-changed" role="function">
<title>tp_cli_channel_interface_call_state_connect_to_call_state_changed ()</title>
<indexterm zone="tp-cli-channel-interface-call-state-connect-to-call-state-changed"><primary sortas="tp_cli_channel_interface_call_state_connect_to_call_state_changed">tp_cli_channel_interface_call_state_connect_to_call_state_changed</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_interface_call_state_connect_to_call_state_changed
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-interface-call-state-signal-callback-call-state-changed">tp_cli_channel_interface_call_state_signal_callback_call_state_changed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal CallStateChanged.
</para>
<para>
Emitted when the state of a member of the channel has changed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-call-state-run-get-call-states" role="function">
<title>tp_cli_channel_interface_call_state_run_get_call_states ()</title>
<indexterm zone="tp-cli-channel-interface-call-state-run-get-call-states"><primary sortas="tp_cli_channel_interface_call_state_run_get_call_states">tp_cli_channel_interface_call_state_run_get_call_states</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_interface_call_state_run_get_call_states
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GHashTable">GHashTable</link> **out_States,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method GetCallStates and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Get the current call states for all contacts involved in this call.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_States</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: The current call states. Participants where the call state flags           would be 0 (all unset) may be omitted from this mapping.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-call-state-signal-callback-call-state-changed" role="function">
<title>tp_cli_channel_interface_call_state_signal_callback_call_state_changed ()</title>
<indexterm zone="tp-cli-channel-interface-call-state-signal-callback-call-state-changed"><primary sortas="tp_cli_channel_interface_call_state_signal_callback_call_state_changed">tp_cli_channel_interface_call_state_signal_callback_call_state_changed</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_call_state_signal_callback_call_state_changed)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_Contact,
                                                         <link linkend="guint">guint</link> arg_State,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal CallStateChanged.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-interface-call-state-connect-to-call-state-changed"><function>tp_cli_channel_interface_call_state_connect_to_call_state_changed()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Contact</parameter>&#160;:</term>
<listitem><simpara> An integer handle for the contact.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_State</parameter>&#160;:</term>
<listitem><simpara> The new state for this contact.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-dtmf-run-start-tone" role="function">
<title>tp_cli_channel_interface_dtmf_run_start_tone ()</title>
<indexterm zone="tp-cli-channel-interface-dtmf-run-start-tone"><primary sortas="tp_cli_channel_interface_dtmf_run_start_tone">tp_cli_channel_interface_dtmf_run_start_tone</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_interface_dtmf_run_start_tone
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="guchar">guchar</link> in_Event,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method StartTone and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Start sending a DTMF tone on this stream. Where possible, the tone         will continue until &lt;tp:member-ref&gt;StopTone&lt;/tp:member-ref&gt; is called.         On certain protocols, it may         only be possible to send events with a predetermined length. In this         case, the implementation may emit a fixed-length tone, and the StopTone         method call should return NotAvailable.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A stream ID as defined in the StreamedMedia channel type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Event</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A numeric event code from the DTMF_Event enum.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-dtmf-run-stop-tone" role="function">
<title>tp_cli_channel_interface_dtmf_run_stop_tone ()</title>
<indexterm zone="tp-cli-channel-interface-dtmf-run-stop-tone"><primary sortas="tp_cli_channel_interface_dtmf_run_stop_tone">tp_cli_channel_interface_dtmf_run_stop_tone</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_interface_dtmf_run_stop_tone
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method StopTone and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Stop sending any DTMF tone which has been started using the         &lt;tp:member-ref&gt;StartTone&lt;/tp:member-ref&gt;         method. If there is no current tone, this method will do nothing.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A stream ID as defined in the StreamedMedia channel type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-dtmf-call-start-tone" role="function">
<title>tp_cli_channel_interface_dtmf_call_start_tone ()</title>
<indexterm zone="tp-cli-channel-interface-dtmf-call-start-tone"><primary sortas="tp_cli_channel_interface_dtmf_call_start_tone">tp_cli_channel_interface_dtmf_call_start_tone</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_interface_dtmf_call_start_tone
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="guchar">guchar</link> in_Event,
                                                         <link linkend="tp-cli-channel-interface-dtmf-callback-for-start-tone">tp_cli_channel_interface_dtmf_callback_for_start_tone</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a StartTone method call.
</para>
<para>
Start sending a DTMF tone on this stream. Where possible, the tone         will continue until &lt;tp:member-ref&gt;StopTone&lt;/tp:member-ref&gt; is called.         On certain protocols, it may         only be possible to send events with a predetermined length. In this         case, the implementation may emit a fixed-length tone, and the StopTone         method call should return NotAvailable.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A stream ID as defined in the StreamedMedia channel type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Event</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A numeric event code from the DTMF_Event enum.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-dtmf-call-stop-tone" role="function">
<title>tp_cli_channel_interface_dtmf_call_stop_tone ()</title>
<indexterm zone="tp-cli-channel-interface-dtmf-call-stop-tone"><primary sortas="tp_cli_channel_interface_dtmf_call_stop_tone">tp_cli_channel_interface_dtmf_call_stop_tone</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_interface_dtmf_call_stop_tone
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> in_Stream_ID,
                                                         <link linkend="tp-cli-channel-interface-dtmf-callback-for-stop-tone">tp_cli_channel_interface_dtmf_callback_for_stop_tone</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a StopTone method call.
</para>
<para>
Stop sending any DTMF tone which has been started using the         &lt;tp:member-ref&gt;StartTone&lt;/tp:member-ref&gt;         method. If there is no current tone, this method will do nothing.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Stream_ID</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A stream ID as defined in the StreamedMedia channel type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-dtmf-callback-for-start-tone" role="function">
<title>tp_cli_channel_interface_dtmf_callback_for_start_tone ()</title>
<indexterm zone="tp-cli-channel-interface-dtmf-callback-for-start-tone"><primary sortas="tp_cli_channel_interface_dtmf_callback_for_start_tone">tp_cli_channel_interface_dtmf_callback_for_start_tone</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_dtmf_callback_for_start_tone)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a StartTone method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-dtmf-callback-for-stop-tone" role="function">
<title>tp_cli_channel_interface_dtmf_callback_for_stop_tone ()</title>
<indexterm zone="tp-cli-channel-interface-dtmf-callback-for-stop-tone"><primary sortas="tp_cli_channel_interface_dtmf_callback_for_stop_tone">tp_cli_channel_interface_dtmf_callback_for_stop_tone</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_dtmf_callback_for_stop_tone)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a StopTone method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-hold-callback-for-get-hold-state" role="function">
<title>tp_cli_channel_interface_hold_callback_for_get_hold_state ()</title>
<indexterm zone="tp-cli-channel-interface-hold-callback-for-get-hold-state"><primary sortas="tp_cli_channel_interface_hold_callback_for_get_hold_state">tp_cli_channel_interface_hold_callback_for_get_hold_state</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_hold_callback_for_get_hold_state)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> out_HoldState,
                                                         <link linkend="guint">guint</link> out_Reason,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a GetHoldState method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_HoldState</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: The state of the channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Reason</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: The reason why the channel is in that state
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-hold-call-get-hold-state" role="function">
<title>tp_cli_channel_interface_hold_call_get_hold_state ()</title>
<indexterm zone="tp-cli-channel-interface-hold-call-get-hold-state"><primary sortas="tp_cli_channel_interface_hold_call_get_hold_state">tp_cli_channel_interface_hold_call_get_hold_state</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_interface_hold_call_get_hold_state
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-interface-hold-callback-for-get-hold-state">tp_cli_channel_interface_hold_callback_for_get_hold_state</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a GetHoldState method call.
</para>
<para>
Return whether the local user has placed the channel on hold.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-hold-run-get-hold-state" role="function">
<title>tp_cli_channel_interface_hold_run_get_hold_state ()</title>
<indexterm zone="tp-cli-channel-interface-hold-run-get-hold-state"><primary sortas="tp_cli_channel_interface_hold_run_get_hold_state">tp_cli_channel_interface_hold_run_get_hold_state</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_interface_hold_run_get_hold_state
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> *out_HoldState,
                                                         <link linkend="guint">guint</link> *out_Reason,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method GetHoldState and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Return whether the local user has placed the channel on hold.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_HoldState</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: The state of the channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Reason</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: The reason why the channel is in that state
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-hold-callback-for-request-hold" role="function">
<title>tp_cli_channel_interface_hold_callback_for_request_hold ()</title>
<indexterm zone="tp-cli-channel-interface-hold-callback-for-request-hold"><primary sortas="tp_cli_channel_interface_hold_callback_for_request_hold">tp_cli_channel_interface_hold_callback_for_request_hold</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_hold_callback_for_request_hold)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a RequestHold method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-hold-call-request-hold" role="function">
<title>tp_cli_channel_interface_hold_call_request_hold ()</title>
<indexterm zone="tp-cli-channel-interface-hold-call-request-hold"><primary sortas="tp_cli_channel_interface_hold_call_request_hold">tp_cli_channel_interface_hold_call_request_hold</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_interface_hold_call_request_hold
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="gboolean">gboolean</link> in_Hold,
                                                         <link linkend="tp-cli-channel-interface-hold-callback-for-request-hold">tp_cli_channel_interface_hold_callback_for_request_hold</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a RequestHold method call.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Request that the channel be put on hold (be instructed not to send           any media streams to you) or be taken off hold.&lt;/p&gt;          &lt;p&gt;If the connection manager can immediately tell that the requested           state change could not possibly succeed, this method SHOULD           return the NotAvailable error. If the requested state is the           same as the current state, this method SHOULD return successfully           without doing anything.&lt;/p&gt;          &lt;p&gt;Otherwise, this method SHOULD immediately set the hold state to           Local_Hold_State_Pending_Hold or Local_Hold_State_Pending_Unhold           (as appropriate), emitting           &lt;tp:member-ref&gt;HoldStateChanged&lt;/tp:member-ref&gt; if this is a change,           and return successfully.&lt;/p&gt;          &lt;p&gt;The eventual success or failure of the request is indicated by a           subsequent HoldStateChanged signal, changing the hold state to           Local_Hold_State_Held or Local_Hold_State_Unheld.&lt;/p&gt;          &lt;p&gt;If the channel has multiple streams, and the connection manager           succeeds in changing the hold state of one stream but fails to           change the hold state of another, it SHOULD attempt to revert           all streams to their previous hold states.&lt;/p&gt;          &lt;p&gt;The following state transitions SHOULD be used, where           appropriate:&lt;/p&gt;          &lt;ul&gt;           &lt;li&gt;Successful hold:             (Unheld, any reason)  (Pending_Hold, Requested)              (Held, Requested)           &lt;/li&gt;           &lt;li&gt;Successful unhold:             (Held, any reason)  (Pending_Unhold, Requested)              (Unheld, Requested)           &lt;/li&gt;           &lt;li&gt;Attempting to unhold fails at the first attempt to acquire a             resource:             (Held, any reason)  (Pending_Unhold, Requested)              (Held, Resource_Not_Available)           &lt;/li&gt;           &lt;li&gt;Attempting to unhold acquires one resource, but fails to acquire             a second, and takes time to release the first:             (Held, any reason)  (Pending_Unhold, Requested)              (Pending_Hold, Resource_Not_Available)              (Held, Resource_Not_Available)           &lt;/li&gt;         &lt;/ul&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Hold</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A boolean indicating whether or not the channel should be on hold
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-hold-run-request-hold" role="function">
<title>tp_cli_channel_interface_hold_run_request_hold ()</title>
<indexterm zone="tp-cli-channel-interface-hold-run-request-hold"><primary sortas="tp_cli_channel_interface_hold_run_request_hold">tp_cli_channel_interface_hold_run_request_hold</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_interface_hold_run_request_hold
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="gboolean">gboolean</link> in_Hold,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method RequestHold and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Request that the channel be put on hold (be instructed not to send           any media streams to you) or be taken off hold.&lt;/p&gt;          &lt;p&gt;If the connection manager can immediately tell that the requested           state change could not possibly succeed, this method SHOULD           return the NotAvailable error. If the requested state is the           same as the current state, this method SHOULD return successfully           without doing anything.&lt;/p&gt;          &lt;p&gt;Otherwise, this method SHOULD immediately set the hold state to           Local_Hold_State_Pending_Hold or Local_Hold_State_Pending_Unhold           (as appropriate), emitting           &lt;tp:member-ref&gt;HoldStateChanged&lt;/tp:member-ref&gt; if this is a change,           and return successfully.&lt;/p&gt;          &lt;p&gt;The eventual success or failure of the request is indicated by a           subsequent HoldStateChanged signal, changing the hold state to           Local_Hold_State_Held or Local_Hold_State_Unheld.&lt;/p&gt;          &lt;p&gt;If the channel has multiple streams, and the connection manager           succeeds in changing the hold state of one stream but fails to           change the hold state of another, it SHOULD attempt to revert           all streams to their previous hold states.&lt;/p&gt;          &lt;p&gt;The following state transitions SHOULD be used, where           appropriate:&lt;/p&gt;          &lt;ul&gt;           &lt;li&gt;Successful hold:             (Unheld, any reason)  (Pending_Hold, Requested)              (Held, Requested)           &lt;/li&gt;           &lt;li&gt;Successful unhold:             (Held, any reason)  (Pending_Unhold, Requested)              (Unheld, Requested)           &lt;/li&gt;           &lt;li&gt;Attempting to unhold fails at the first attempt to acquire a             resource:             (Held, any reason)  (Pending_Unhold, Requested)              (Held, Resource_Not_Available)           &lt;/li&gt;           &lt;li&gt;Attempting to unhold acquires one resource, but fails to acquire             a second, and takes time to release the first:             (Held, any reason)  (Pending_Unhold, Requested)              (Pending_Hold, Resource_Not_Available)              (Held, Resource_Not_Available)           &lt;/li&gt;         &lt;/ul&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>in_Hold</parameter>&#160;:</term>
<listitem><simpara> Used to pass an 'in' argument: A boolean indicating whether or not the channel should be on hold
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-hold-signal-callback-hold-state-changed" role="function">
<title>tp_cli_channel_interface_hold_signal_callback_hold_state_changed ()</title>
<indexterm zone="tp-cli-channel-interface-hold-signal-callback-hold-state-changed"><primary sortas="tp_cli_channel_interface_hold_signal_callback_hold_state_changed">tp_cli_channel_interface_hold_signal_callback_hold_state_changed</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_hold_signal_callback_hold_state_changed)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> arg_HoldState,
                                                         <link linkend="guint">guint</link> arg_Reason,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal HoldStateChanged.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-interface-hold-connect-to-hold-state-changed"><function>tp_cli_channel_interface_hold_connect_to_hold_state_changed()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_HoldState</parameter>&#160;:</term>
<listitem><simpara> The state of the channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Reason</parameter>&#160;:</term>
<listitem><simpara> The reason for the state change
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-hold-connect-to-hold-state-changed" role="function">
<title>tp_cli_channel_interface_hold_connect_to_hold_state_changed ()</title>
<indexterm zone="tp-cli-channel-interface-hold-connect-to-hold-state-changed"><primary sortas="tp_cli_channel_interface_hold_connect_to_hold_state_changed">tp_cli_channel_interface_hold_connect_to_hold_state_changed</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_interface_hold_connect_to_hold_state_changed
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-interface-hold-signal-callback-hold-state-changed">tp_cli_channel_interface_hold_signal_callback_hold_state_changed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal HoldStateChanged.
</para>
<para>
Emitted to indicate that the hold state has changed for this channel.         This may occur as a consequence of you requesting a change with         &lt;tp:member-ref&gt;RequestHold&lt;/tp:member-ref&gt;, or the state changing as a         result of a request from         another process.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-media-signalling-run-get-session-handlers" role="function">
<title>tp_cli_channel_interface_media_signalling_run_get_session_handlers ()</title>
<indexterm zone="tp-cli-channel-interface-media-signalling-run-get-session-handlers"><primary sortas="tp_cli_channel_interface_media_signalling_run_get_session_handlers">tp_cli_channel_interface_media_signalling_run_get_session_handlers</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_interface_media_signalling_run_get_session_handlers
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GPtrArray">GPtrArray</link> **out_Session_Handlers,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method GetSessionHandlers and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Returns all currently active session handlers on this channel         as a list of (session_handler_path, type).</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Session_Handlers</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: (Undocumented)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-media-signalling-call-get-session-handlers" role="function">
<title>tp_cli_channel_interface_media_signalling_call_get_session_handlers ()</title>
<indexterm zone="tp-cli-channel-interface-media-signalling-call-get-session-handlers"><primary sortas="tp_cli_channel_interface_media_signalling_call_get_session_handlers">tp_cli_channel_interface_media_signalling_call_get_session_handlers</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_interface_media_signalling_call_get_session_handlers
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-interface-media-signalling-callback-for-get-session-handlers">tp_cli_channel_interface_media_signalling_callback_for_get_session_handlers</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a GetSessionHandlers method call.
</para>
<para>
Returns all currently active session handlers on this channel         as a list of (session_handler_path, type).</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-media-signalling-callback-for-get-session-handlers" role="function">
<title>tp_cli_channel_interface_media_signalling_callback_for_get_session_handlers ()</title>
<indexterm zone="tp-cli-channel-interface-media-signalling-callback-for-get-session-handlers"><primary sortas="tp_cli_channel_interface_media_signalling_callback_for_get_session_handlers">tp_cli_channel_interface_media_signalling_callback_for_get_session_handlers</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_media_signalling_callback_for_get_session_handlers)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GPtrArray">GPtrArray</link> *out_Session_Handlers,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a GetSessionHandlers method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Session_Handlers</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: (Undocumented)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-media-signalling-connect-to-new-session-handler" role="function">
<title>tp_cli_channel_interface_media_signalling_connect_to_new_session_handler ()</title>
<indexterm zone="tp-cli-channel-interface-media-signalling-connect-to-new-session-handler"><primary sortas="tp_cli_channel_interface_media_signalling_connect_to_new_session_handler">tp_cli_channel_interface_media_signalling_connect_to_new_session_handler</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_interface_media_signalling_connect_to_new_session_handler
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-interface-media-signalling-signal-callback-new-session-handler">tp_cli_channel_interface_media_signalling_signal_callback_new_session_handler</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal NewSessionHandler.
</para>
<para>
Signal that a session handler object has been created. The client         should create a session object and create streams for the streams         within.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-media-signalling-signal-callback-new-session-handler" role="function">
<title>tp_cli_channel_interface_media_signalling_signal_callback_new_session_handler ()</title>
<indexterm zone="tp-cli-channel-interface-media-signalling-signal-callback-new-session-handler"><primary sortas="tp_cli_channel_interface_media_signalling_signal_callback_new_session_handler">tp_cli_channel_interface_media_signalling_signal_callback_new_session_handler</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_media_signalling_signal_callback_new_session_handler)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="gchar">gchar</link> *arg_Session_Handler,
                                                         const <link linkend="gchar">gchar</link> *arg_Session_Type,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal NewSessionHandler.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-interface-media-signalling-connect-to-new-session-handler"><function>tp_cli_channel_interface_media_signalling_connect_to_new_session_handler()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Session_Handler</parameter>&#160;:</term>
<listitem><simpara> Object path of the new &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy&quot;&gt;Media.SessionHandler&lt;/tp:dbus-ref&gt;           object
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>arg_Session_Type</parameter>&#160;:</term>
<listitem><simpara> String indicating type of session, eg &amp;quot;rtp&amp;quot;
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>



<refsect1 id="telepathy-glib-channel-media.see-also">
<title>See Also</title>
channel-group, <link linkend="TpChannel"><type>TpChannel</type></link>
</refsect1>

</refentry>
