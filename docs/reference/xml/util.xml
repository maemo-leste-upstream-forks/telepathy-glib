<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="telepathy-glib-util">
<refmeta>
<refentrytitle role="top_of_page" id="telepathy-glib-util.top_of_page">Utilities</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>Utilities</refname>
<refpurpose>Non-Telepathy utility functions</refpurpose>
</refnamediv>

<refsynopsisdiv id="telepathy-glib-util.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;telepathy-glib/util.h&gt;

#define             <link linkend="tp-verify">tp_verify</link>                           (R)
#define             <link linkend="tp-verify-true">tp_verify_true</link>                      (R)
#define             <link linkend="tp-verify-statement">tp_verify_statement</link>                 (R)
<link linkend="void">void</link>                <link linkend="tp-g-hash-table-update">tp_g_hash_table_update</link>              (<link linkend="GHashTable">GHashTable</link> *target,
                                                         <link linkend="GHashTable">GHashTable</link> *source,
                                                         <link linkend="GBoxedCopyFunc">GBoxedCopyFunc</link> key_dup,
                                                         <link linkend="GBoxedCopyFunc">GBoxedCopyFunc</link> value_dup);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-g-ptr-array-contains">tp_g_ptr_array_contains</link>             (<link linkend="GPtrArray">GPtrArray</link> *haystack,
                                                         <link linkend="gpointer">gpointer</link> needle);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new">tp_g_value_slice_new</link>                (<link linkend="GType">GType</link> type);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-boolean">tp_g_value_slice_new_boolean</link>        (<link linkend="gboolean">gboolean</link> b);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-boxed">tp_g_value_slice_new_boxed</link>          (<link linkend="GType">GType</link> type,
                                                         <link linkend="gconstpointer">gconstpointer</link> p);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-static-boxed">tp_g_value_slice_new_static_boxed</link>   (<link linkend="GType">GType</link> type,
                                                         <link linkend="gconstpointer">gconstpointer</link> p);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-take-boxed">tp_g_value_slice_new_take_boxed</link>     (<link linkend="GType">GType</link> type,
                                                         <link linkend="gpointer">gpointer</link> p);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-double">tp_g_value_slice_new_double</link>         (<link linkend="double">double</link> d);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-int">tp_g_value_slice_new_int</link>            (<link linkend="gint">gint</link> n);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-int64">tp_g_value_slice_new_int64</link>          (<link linkend="gint64">gint64</link> n);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-string">tp_g_value_slice_new_string</link>         (const <link linkend="gchar">gchar</link> *string);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-static-string">tp_g_value_slice_new_static_string</link>  (const <link linkend="gchar">gchar</link> *string);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-take-string">tp_g_value_slice_new_take_string</link>    (<link linkend="gchar">gchar</link> *string);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-uint">tp_g_value_slice_new_uint</link>           (<link linkend="guint">guint</link> n);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-new-uint64">tp_g_value_slice_new_uint64</link>         (<link linkend="guint64">guint64</link> n);
<link linkend="void">void</link>                <link linkend="tp-g-value-slice-free">tp_g_value_slice_free</link>               (<link linkend="GValue">GValue</link> *value);
<link linkend="GValue">GValue</link> *            <link linkend="tp-g-value-slice-dup">tp_g_value_slice_dup</link>                (const <link linkend="GValue">GValue</link> *value);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-strdiff">tp_strdiff</link>                          (const <link linkend="gchar">gchar</link> *left,
                                                         const <link linkend="gchar">gchar</link> *right);
<link linkend="gpointer">gpointer</link>            <link linkend="tp-mixin-offset-cast">tp_mixin_offset_cast</link>                (<link linkend="gpointer">gpointer</link> instance,
                                                         <link linkend="guint">guint</link> offset);
<link linkend="guint">guint</link>               <link linkend="tp-mixin-class-get-offset">tp_mixin_class_get_offset</link>           (<link linkend="gpointer">gpointer</link> klass,
                                                         <link linkend="GQuark">GQuark</link> quark);
<link linkend="guint">guint</link>               <link linkend="tp-mixin-instance-get-offset">tp_mixin_instance_get_offset</link>        (<link linkend="gpointer">gpointer</link> instance,
                                                         <link linkend="GQuark">GQuark</link> quark);
<link linkend="gchar">gchar</link> *             <link linkend="tp-escape-as-identifier">tp_escape_as_identifier</link>             (const <link linkend="gchar">gchar</link> *name);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-strv-contains">tp_strv_contains</link>                    (const <link linkend="gchar">gchar</link> * const *strv,
                                                         const <link linkend="gchar">gchar</link> *str);
<link linkend="gint64">gint64</link>              <link linkend="tp-g-key-file-get-int64">tp_g_key_file_get_int64</link>             (<link linkend="GKeyFile">GKeyFile</link> *key_file,
                                                         const <link linkend="gchar">gchar</link> *group_name,
                                                         const <link linkend="gchar">gchar</link> *key,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="guint64">guint64</link>             <link linkend="tp-g-key-file-get-uint64">tp_g_key_file_get_uint64</link>            (<link linkend="GKeyFile">GKeyFile</link> *key_file,
                                                         const <link linkend="gchar">gchar</link> *group_name,
                                                         const <link linkend="gchar">gchar</link> *key,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gulong">gulong</link>              <link linkend="tp-g-signal-connect-object">tp_g_signal_connect_object</link>          (<link linkend="gpointer">gpointer</link> instance,
                                                         const <link linkend="gchar">gchar</link> *detailed_signal,
                                                         <link linkend="GCallback">GCallback</link> c_handler,
                                                         <link linkend="gpointer">gpointer</link> gobject,
                                                         <link linkend="GConnectFlags">GConnectFlags</link> connect_flags);
<link linkend="GValueArray">GValueArray</link> *       <link linkend="tp-value-array-build">tp_value_array_build</link>                (<link linkend="gsize">gsize</link> length,
                                                         <link linkend="GType">GType</link> type,
                                                         ...);
</synopsis>
</refsynopsisdiv>









<refsect1 id="telepathy-glib-util.description" role="desc">
<title role="desc.title">Description</title>
<para>
Some utility functions used in telepathy-glib which could have been in
GLib, but aren't.</para>
<para>
</para>
</refsect1>

<refsect1 id="telepathy-glib-util.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="tp-verify" role="macro">
<title>tp_verify()</title>
<indexterm zone="tp-verify"><primary sortas="tp_verify">tp_verify</primary></indexterm><programlisting># define tp_verify(R) extern int (* tp_verify_function__ (void)) [tp_verify_true (R)]
</programlisting>
<para>
Make an assertion at compile time, like C++0x's proposed static_assert
keyword. If <parameter>R</parameter> is determined to be true, there is no overhead at runtime;
if <parameter>R</parameter> is determined to be false, compilation will fail.
</para>
<para>
This macro can be used at file scope (it expands to a dummy extern
declaration).
</para>
<para>
(This is gnulib's verify macro, written by Paul Eggert, Bruno Haible and
Jim Meyering.)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>R</parameter>&#160;:</term>
<listitem><simpara> a requirement (constant expression) to be checked at compile-time
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-verify-true" role="macro">
<title>tp_verify_true()</title>
<indexterm zone="tp-verify-true"><primary sortas="tp_verify_true">tp_verify_true</primary></indexterm><programlisting>#define             tp_verify_true(R)</programlisting>
<para>
Make an assertion at compile time, like C++0x's proposed static_assert
keyword. If <parameter>R</parameter> is determined to be true, there is no overhead at runtime,
and the macro evaluates to 1 as an integer constant expression;
if <parameter>R</parameter> is determined to be false, compilation will fail.
</para>
<para>
This macro can be used anywhere that an integer constant expression would
be allowed.
</para>
<para>
(This is gnulib's verify_true macro, written by Paul Eggert, Bruno Haible
and Jim Meyering.)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>R</parameter>&#160;:</term>
<listitem><simpara> a requirement (constant expression) to be checked at compile-time
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-verify-statement" role="macro">
<title>tp_verify_statement()</title>
<indexterm zone="tp-verify-statement"><primary sortas="tp_verify_statement">tp_verify_statement</primary></indexterm><programlisting>#define tp_verify_statement(R) ((void) tp_verify_true (R))
</programlisting>
<para>
Make an assertion at compile time, like C++0x's proposed static_assert
keyword. If <parameter>R</parameter> is determined to be true, there is no overhead at runtime;
if <parameter>R</parameter> is determined to be false, compilation will fail.
</para>
<para>
This macro can be used anywhere that a statement would be allowed; it
is equivalent to ((void) tp_verify_true (R)).</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>R</parameter>&#160;:</term>
<listitem><simpara> a requirement (constant expression) to be checked at compile-time
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-g-hash-table-update" role="function" condition="since:0.7.0">
<title>tp_g_hash_table_update ()</title>
<indexterm zone="tp-g-hash-table-update" role="0.7.0"><primary sortas="tp_g_hash_table_update">tp_g_hash_table_update</primary></indexterm><programlisting><link linkend="void">void</link>                tp_g_hash_table_update              (<link linkend="GHashTable">GHashTable</link> *target,
                                                         <link linkend="GHashTable">GHashTable</link> *source,
                                                         <link linkend="GBoxedCopyFunc">GBoxedCopyFunc</link> key_dup,
                                                         <link linkend="GBoxedCopyFunc">GBoxedCopyFunc</link> value_dup);</programlisting>
<para>
Add each item in <parameter>source</parameter> to <parameter>target</parameter>, replacing any existing item with the
same key. <parameter>key_dup</parameter> and <parameter>value_dup</parameter> are used to duplicate the items; in
principle they could also be used to convert between types.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>target</parameter>&#160;:</term>
<listitem><simpara> The hash table to be updated
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>source</parameter>&#160;:</term>
<listitem><simpara> The hash table to update it with (read-only)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>key_dup</parameter>&#160;:</term>
<listitem><simpara> function to duplicate a key from <parameter>source</parameter> so it can be be stored
          in <parameter>target</parameter>. If NULL, the key is not copied, but is used as-is
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>value_dup</parameter>&#160;:</term>
<listitem><simpara> function to duplicate a value from <parameter>source</parameter> so it can be stored
            in <parameter>target</parameter>. If NULL, the value is not copied, but is used as-is
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.0</para></refsect2>
<refsect2 id="tp-g-ptr-array-contains" role="function">
<title>tp_g_ptr_array_contains ()</title>
<indexterm zone="tp-g-ptr-array-contains"><primary sortas="tp_g_ptr_array_contains">tp_g_ptr_array_contains</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_g_ptr_array_contains             (<link linkend="GPtrArray">GPtrArray</link> *haystack,
                                                         <link linkend="gpointer">gpointer</link> needle);</programlisting>
<para>
<!--no further documentation needed--></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>haystack</parameter>&#160;:</term>
<listitem><simpara> The pointer array to be searched
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>needle</parameter>&#160;:</term>
<listitem><simpara> The pointer to look for
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> if <parameter>needle</parameter> is one of the elements of <parameter>haystack</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-g-value-slice-new" role="function" condition="since:0.5.14">
<title>tp_g_value_slice_new ()</title>
<indexterm zone="tp-g-value-slice-new" role="0.5.14"><primary sortas="tp_g_value_slice_new">tp_g_value_slice_new</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new                (<link linkend="GType">GType</link> type);</programlisting>
<para>
Slice-allocate an empty <link linkend="GValue"><type>GValue</type></link>. <link linkend="tp-g-value-slice-new-boolean"><function>tp_g_value_slice_new_boolean()</function></link> and similar
functions are likely to be more convenient to use for the types supported.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&#160;:</term>
<listitem><simpara> The type desired for the new GValue
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a newly allocated, newly initialized <link linkend="GValue"><type>GValue</type></link>, to be freed with
<link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>.
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.5.14</para></refsect2>
<refsect2 id="tp-g-value-slice-new-boolean" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_boolean ()</title>
<indexterm zone="tp-g-value-slice-new-boolean" role="0.7.27"><primary sortas="tp_g_value_slice_new_boolean">tp_g_value_slice_new_boolean</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_boolean        (<link linkend="gboolean">gboolean</link> b);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>b</parameter>&#160;:</term>
<listitem><simpara> a boolean value
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <link linkend="G-TYPE-BOOLEAN--CAPS"><literal>G_TYPE_BOOLEAN</literal></link> with value <parameter>b</parameter>, to be freed with
<link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-boxed" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_boxed ()</title>
<indexterm zone="tp-g-value-slice-new-boxed" role="0.7.27"><primary sortas="tp_g_value_slice_new_boxed">tp_g_value_slice_new_boxed</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_boxed          (<link linkend="GType">GType</link> type,
                                                         <link linkend="gconstpointer">gconstpointer</link> p);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&#160;:</term>
<listitem><simpara> a boxed type
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>p</parameter>&#160;:</term>
<listitem><simpara> a pointer of type <parameter>type</parameter>, which will be copied
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <parameter>type</parameter> whose value is a copy of <parameter>p</parameter>,
to be freed with <link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-static-boxed" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_static_boxed ()</title>
<indexterm zone="tp-g-value-slice-new-static-boxed" role="0.7.27"><primary sortas="tp_g_value_slice_new_static_boxed">tp_g_value_slice_new_static_boxed</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_static_boxed   (<link linkend="GType">GType</link> type,
                                                         <link linkend="gconstpointer">gconstpointer</link> p);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&#160;:</term>
<listitem><simpara> a boxed type
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>p</parameter>&#160;:</term>
<listitem><simpara> a pointer of type <parameter>type</parameter>, which must remain valid forever
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <parameter>type</parameter> whose value is <parameter>p</parameter>,
to be freed with <link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-take-boxed" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_take_boxed ()</title>
<indexterm zone="tp-g-value-slice-new-take-boxed" role="0.7.27"><primary sortas="tp_g_value_slice_new_take_boxed">tp_g_value_slice_new_take_boxed</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_take_boxed     (<link linkend="GType">GType</link> type,
                                                         <link linkend="gpointer">gpointer</link> p);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&#160;:</term>
<listitem><simpara> a boxed type
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>p</parameter>&#160;:</term>
<listitem><simpara> a pointer of type <parameter>type</parameter> which will be freed with <link linkend="g-boxed-free"><function>g_boxed_free()</function></link> by the
 returned <link linkend="GValue"><type>GValue</type></link> (the caller must own it before calling this function, but
 no longer owns it after this function returns)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <parameter>type</parameter> whose value is <parameter>p</parameter>,
to be freed with <link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-double" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_double ()</title>
<indexterm zone="tp-g-value-slice-new-double" role="0.7.27"><primary sortas="tp_g_value_slice_new_double">tp_g_value_slice_new_double</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_double         (<link linkend="double">double</link> d);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>d</parameter>&#160;:</term>
<listitem><simpara> a number
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <link linkend="G-TYPE-DOUBLE--CAPS"><literal>G_TYPE_DOUBLE</literal></link> with value <parameter>n</parameter>, to be freed with
<link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-int" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_int ()</title>
<indexterm zone="tp-g-value-slice-new-int" role="0.7.27"><primary sortas="tp_g_value_slice_new_int">tp_g_value_slice_new_int</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_int            (<link linkend="gint">gint</link> n);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>n</parameter>&#160;:</term>
<listitem><simpara> an integer
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <link linkend="G-TYPE-INT--CAPS"><literal>G_TYPE_INT</literal></link> with value <parameter>n</parameter>, to be freed with
<link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-int64" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_int64 ()</title>
<indexterm zone="tp-g-value-slice-new-int64" role="0.7.27"><primary sortas="tp_g_value_slice_new_int64">tp_g_value_slice_new_int64</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_int64          (<link linkend="gint64">gint64</link> n);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>n</parameter>&#160;:</term>
<listitem><simpara> a 64-bit integer
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <link linkend="G-TYPE-INT64--CAPS"><literal>G_TYPE_INT64</literal></link> with value <parameter>n</parameter>, to be freed with
<link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-string" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_string ()</title>
<indexterm zone="tp-g-value-slice-new-string" role="0.7.27"><primary sortas="tp_g_value_slice_new_string">tp_g_value_slice_new_string</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_string         (const <link linkend="gchar">gchar</link> *string);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>string</parameter>&#160;:</term>
<listitem><simpara> a string to be copied into the value
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <link linkend="G-TYPE-STRING--CAPS"><literal>G_TYPE_STRING</literal></link> whose value is a copy of <parameter>string</parameter>,
to be freed with <link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-static-string" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_static_string ()</title>
<indexterm zone="tp-g-value-slice-new-static-string" role="0.7.27"><primary sortas="tp_g_value_slice_new_static_string">tp_g_value_slice_new_static_string</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_static_string  (const <link linkend="gchar">gchar</link> *string);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>string</parameter>&#160;:</term>
<listitem><simpara> a static string which must remain valid forever, to be pointed to
 by the value
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <link linkend="G-TYPE-STRING--CAPS"><literal>G_TYPE_STRING</literal></link> whose value is <parameter>string</parameter>,
to be freed with <link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-take-string" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_take_string ()</title>
<indexterm zone="tp-g-value-slice-new-take-string" role="0.7.27"><primary sortas="tp_g_value_slice_new_take_string">tp_g_value_slice_new_take_string</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_take_string    (<link linkend="gchar">gchar</link> *string);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>string</parameter>&#160;:</term>
<listitem><simpara> a string which will be freed with <link linkend="g-free"><function>g_free()</function></link> by the returned <link linkend="GValue"><type>GValue</type></link>
 (the caller must own it before calling this function, but no longer owns
 it after this function returns)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <link linkend="G-TYPE-STRING--CAPS"><literal>G_TYPE_STRING</literal></link> whose value is <parameter>string</parameter>,
to be freed with <link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-uint" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_uint ()</title>
<indexterm zone="tp-g-value-slice-new-uint" role="0.7.27"><primary sortas="tp_g_value_slice_new_uint">tp_g_value_slice_new_uint</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_uint           (<link linkend="guint">guint</link> n);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>n</parameter>&#160;:</term>
<listitem><simpara> an unsigned integer
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <link linkend="G-TYPE-UINT--CAPS"><literal>G_TYPE_UINT</literal></link> with value <parameter>n</parameter>, to be freed with
<link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-new-uint64" role="function" condition="since:0.7.27">
<title>tp_g_value_slice_new_uint64 ()</title>
<indexterm zone="tp-g-value-slice-new-uint64" role="0.7.27"><primary sortas="tp_g_value_slice_new_uint64">tp_g_value_slice_new_uint64</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_new_uint64         (<link linkend="guint64">guint64</link> n);</programlisting>
<para>
Slice-allocate and initialize a <link linkend="GValue"><type>GValue</type></link>. This function is convenient to
use when constructing hash tables from string to <link linkend="GValue"><type>GValue</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>n</parameter>&#160;:</term>
<listitem><simpara> a 64-bit unsigned integer
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GValue"><type>GValue</type></link> of type <link linkend="G-TYPE-UINT64--CAPS"><literal>G_TYPE_UINT64</literal></link> with value <parameter>n</parameter>, to be freed with
<link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.27</para></refsect2>
<refsect2 id="tp-g-value-slice-free" role="function">
<title>tp_g_value_slice_free ()</title>
<indexterm zone="tp-g-value-slice-free"><primary sortas="tp_g_value_slice_free">tp_g_value_slice_free</primary></indexterm><programlisting><link linkend="void">void</link>                tp_g_value_slice_free               (<link linkend="GValue">GValue</link> *value);</programlisting>
<para>
Unset and free a slice-allocated GValue.
</para>
<para>
<literal>(GDestroyNotify) tp_g_value_slice_free</literal> can be used
as a destructor for values in a <link linkend="GHashTable"><type>GHashTable</type></link>, for example.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>value</parameter>&#160;:</term>
<listitem><simpara> A GValue which was allocated with the g_slice API
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-g-value-slice-dup" role="function" condition="since:0.5.14">
<title>tp_g_value_slice_dup ()</title>
<indexterm zone="tp-g-value-slice-dup" role="0.5.14"><primary sortas="tp_g_value_slice_dup">tp_g_value_slice_dup</primary></indexterm><programlisting><link linkend="GValue">GValue</link> *            tp_g_value_slice_dup                (const <link linkend="GValue">GValue</link> *value);</programlisting>
<para>
<!-- 'Returns' says it all --></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>value</parameter>&#160;:</term>
<listitem><simpara> A GValue
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a newly allocated copy of <parameter>value</parameter>, to be freed with
<link linkend="tp-g-value-slice-free"><function>tp_g_value_slice_free()</function></link> or <link linkend="g-slice-free"><function>g_slice_free()</function></link>.
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.5.14</para></refsect2>
<refsect2 id="tp-strdiff" role="function">
<title>tp_strdiff ()</title>
<indexterm zone="tp-strdiff"><primary sortas="tp_strdiff">tp_strdiff</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_strdiff                          (const <link linkend="gchar">gchar</link> *left,
                                                         const <link linkend="gchar">gchar</link> *right);</programlisting>
<para>
Return <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> if the given strings are different. Unlike <link linkend="strcmp"><type>strcmp</type></link> this
function will handle null pointers, treating them as distinct from any
string.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>left</parameter>&#160;:</term>
<listitem><simpara> The first string to compare (may be NULL)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>right</parameter>&#160;:</term>
<listitem><simpara> The second string to compare (may be NULL)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> if <parameter>left</parameter> and <parameter>right</parameter> are both <link linkend="NULL--CAPS"><literal>NULL</literal></link>, or if
         neither is <link linkend="NULL--CAPS"><literal>NULL</literal></link> and both have the same contents; <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> otherwise
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-mixin-offset-cast" role="function">
<title>tp_mixin_offset_cast ()</title>
<indexterm zone="tp-mixin-offset-cast"><primary sortas="tp_mixin_offset_cast">tp_mixin_offset_cast</primary></indexterm><programlisting><link linkend="gpointer">gpointer</link>            tp_mixin_offset_cast                (<link linkend="gpointer">gpointer</link> instance,
                                                         <link linkend="guint">guint</link> offset);</programlisting>
<para>
Extend a pointer by an offset, provided the offset is not 0.
This is used to cast from an object instance to one of the telepathy-glib
mixin classes.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&#160;:</term>
<listitem><simpara> A pointer to a structure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>offset</parameter>&#160;:</term>
<listitem><simpara> The offset of a structure member in bytes, which must not be 0
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a pointer <parameter>offset</parameter> bytes beyond <parameter>instance</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-mixin-class-get-offset" role="function">
<title>tp_mixin_class_get_offset ()</title>
<indexterm zone="tp-mixin-class-get-offset"><primary sortas="tp_mixin_class_get_offset">tp_mixin_class_get_offset</primary></indexterm><programlisting><link linkend="guint">guint</link>               tp_mixin_class_get_offset           (<link linkend="gpointer">gpointer</link> klass,
                                                         <link linkend="GQuark">GQuark</link> quark);</programlisting>
<para>
If the type of <parameter>klass</parameter>, or any of its ancestor types, has had an offset
attached using qdata with the given <parameter>quark</parameter>, return that offset. If not,
this indicates a programming error and results are undefined.
</para>
<para>
This is used to implement the telepathy-glib mixin classes.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>klass</parameter>&#160;:</term>
<listitem><simpara> A pointer to a GObjectClass-derived class structure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>quark</parameter>&#160;:</term>
<listitem><simpara> A quark that was used to store the offset with <link linkend="g-type-set-qdata"><function>g_type_set_qdata()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the offset of the mixin class
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-mixin-instance-get-offset" role="function">
<title>tp_mixin_instance_get_offset ()</title>
<indexterm zone="tp-mixin-instance-get-offset"><primary sortas="tp_mixin_instance_get_offset">tp_mixin_instance_get_offset</primary></indexterm><programlisting><link linkend="guint">guint</link>               tp_mixin_instance_get_offset        (<link linkend="gpointer">gpointer</link> instance,
                                                         <link linkend="GQuark">GQuark</link> quark);</programlisting>
<para>
If the type of <parameter>instance</parameter>, or any of its ancestor types, has had an offset
attached using qdata with the given <parameter>quark</parameter>, return that offset. If not,
this indicates a programming error and results are undefined.
</para>
<para>
This is used to implement the telepathy-glib mixin classes.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&#160;:</term>
<listitem><simpara> A pointer to a GObject-derived instance structure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>quark</parameter>&#160;:</term>
<listitem><simpara> A quark that was used to store the offset with <link linkend="g-type-set-qdata"><function>g_type_set_qdata()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the offset of the mixin
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-escape-as-identifier" role="function">
<title>tp_escape_as_identifier ()</title>
<indexterm zone="tp-escape-as-identifier"><primary sortas="tp_escape_as_identifier">tp_escape_as_identifier</primary></indexterm><programlisting><link linkend="gchar">gchar</link> *             tp_escape_as_identifier             (const <link linkend="gchar">gchar</link> *name);</programlisting>
<para>
Escape an arbitrary string so it follows the rules for a C identifier,
and hence an object path component, interface element component,
bus name component or member name in D-Bus.
</para>
<para>
Unlike g_strcanon this is a reversible encoding, so it preserves
distinctness.
</para>
<para>
The escaping consists of replacing all non-alphanumerics, and the first
character if it's a digit, with an underscore and two lower-case hex
digits:
</para>
<para>
   "0123abc_xyz\x01\xff" -> _30123abc_5fxyz_01_ff
</para>
<para>
i.e. similar to URI encoding, but with _ taking the role of %, and a
smaller allowed set. As a special case, "" is escaped to "_" (just for
completeness, really).</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>name</parameter>&#160;:</term>
<listitem><simpara> The string to be escaped
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the escaped string, which must be freed by the caller with <link linkend="g-free"><type>g_free</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-strv-contains" role="function" condition="since:0.7.15">
<title>tp_strv_contains ()</title>
<indexterm zone="tp-strv-contains" role="0.7.15"><primary sortas="tp_strv_contains">tp_strv_contains</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_strv_contains                    (const <link linkend="gchar">gchar</link> * const *strv,
                                                         const <link linkend="gchar">gchar</link> *str);</programlisting>
<para>
<!-- --></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>strv</parameter>&#160;:</term>
<listitem><simpara> a NULL-terminated array of strings, or <link linkend="NULL--CAPS"><literal>NULL</literal></link> (which is treated as an
       empty strv)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>str</parameter>&#160;:</term>
<listitem><simpara> a non-NULL string
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE if <parameter>str</parameter> is an element of <parameter>strv</parameter>, according to <link linkend="strcmp"><function>strcmp()</function></link>.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.15</para></refsect2>
<refsect2 id="tp-g-key-file-get-int64" role="function" condition="since:0.7.31">
<title>tp_g_key_file_get_int64 ()</title>
<indexterm zone="tp-g-key-file-get-int64" role="0.7.31"><primary sortas="tp_g_key_file_get_int64">tp_g_key_file_get_int64</primary></indexterm><programlisting><link linkend="gint64">gint64</link>              tp_g_key_file_get_int64             (<link linkend="GKeyFile">GKeyFile</link> *key_file,
                                                         const <link linkend="gchar">gchar</link> *group_name,
                                                         const <link linkend="gchar">gchar</link> *key,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Returns the value associated with <parameter>key</parameter> under <parameter>group_name</parameter> as a signed
64-bit integer. This is similar to <link linkend="g-key-file-get-integer"><function>g_key_file_get_integer()</function></link> but can return
64-bit results without truncation.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>key_file</parameter>&#160;:</term>
<listitem><simpara> a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> <link linkend="GKeyFile"><type>GKeyFile</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>group_name</parameter>&#160;:</term>
<listitem><simpara> a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> group name
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>key</parameter>&#160;:</term>
<listitem><simpara> a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> key
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> return location for a <link linkend="GError"><type>GError</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the value associated with the key as a signed 64-bit integer, or
0 if the key was not found or could not be parsed.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.31</para></refsect2>
<refsect2 id="tp-g-key-file-get-uint64" role="function" condition="since:0.7.31">
<title>tp_g_key_file_get_uint64 ()</title>
<indexterm zone="tp-g-key-file-get-uint64" role="0.7.31"><primary sortas="tp_g_key_file_get_uint64">tp_g_key_file_get_uint64</primary></indexterm><programlisting><link linkend="guint64">guint64</link>             tp_g_key_file_get_uint64            (<link linkend="GKeyFile">GKeyFile</link> *key_file,
                                                         const <link linkend="gchar">gchar</link> *group_name,
                                                         const <link linkend="gchar">gchar</link> *key,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Returns the value associated with <parameter>key</parameter> under <parameter>group_name</parameter> as an unsigned
64-bit integer. This is similar to <link linkend="g-key-file-get-integer"><function>g_key_file_get_integer()</function></link> but can return
large positive results without truncation.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>key_file</parameter>&#160;:</term>
<listitem><simpara> a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> <link linkend="GKeyFile"><type>GKeyFile</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>group_name</parameter>&#160;:</term>
<listitem><simpara> a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> group name
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>key</parameter>&#160;:</term>
<listitem><simpara> a non-<link linkend="NULL--CAPS"><literal>NULL</literal></link> key
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> return location for a <link linkend="GError"><type>GError</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the value associated with the key as an unsigned 64-bit integer,
or 0 if the key was not found or could not be parsed.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.31</para></refsect2>
<refsect2 id="tp-g-signal-connect-object" role="function">
<title>tp_g_signal_connect_object ()</title>
<indexterm zone="tp-g-signal-connect-object"><primary sortas="tp_g_signal_connect_object">tp_g_signal_connect_object</primary></indexterm><programlisting><link linkend="gulong">gulong</link>              tp_g_signal_connect_object          (<link linkend="gpointer">gpointer</link> instance,
                                                         const <link linkend="gchar">gchar</link> *detailed_signal,
                                                         <link linkend="GCallback">GCallback</link> c_handler,
                                                         <link linkend="gpointer">gpointer</link> gobject,
                                                         <link linkend="GConnectFlags">GConnectFlags</link> connect_flags);</programlisting>
<para>
Connects a <link linkend="GCallback"><type>GCallback</type></link> function to a signal for a particular object, as if
with <link linkend="g-signal-connect"><function>g_signal_connect()</function></link>. Additionally, arranges for the signal handler to be
disconnected if <parameter>observer</parameter> is destroyed.
</para>
<para>
This is similar to <link linkend="g-signal-connect-data"><function>g_signal_connect_data()</function></link>, but uses a closure which
ensures that the <parameter>gobject</parameter> stays alive during the call to <parameter>c_handler</parameter>
by temporarily adding a reference count to <parameter>gobject</parameter>.
</para>
<para>
This is similar to <link linkend="g-signal-connect-object"><function>g_signal_connect_object()</function></link>, but doesn't have the
documented bug that everyone is too scared to fix. Also, it does not allow
you to pass in NULL as <parameter>gobject</parameter>
</para>
<para>
This is intended to be a convenient way for objects to use themselves as
user_data for callbacks without having to explicitly disconnect all the
handlers in their finalizers.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&#160;:</term>
<listitem><simpara> the instance to connect to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detailed_signal</parameter>&#160;:</term>
<listitem><simpara> a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_handler</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="GCallback"><type>GCallback</type></link> to connect.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>gobject</parameter>&#160;:</term>
<listitem><simpara> the object to pass as data to <parameter>c_handler</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>connect_flags</parameter>&#160;:</term>
<listitem><simpara> a combination of <link linkend="GConnnectFlags"><type>GConnnectFlags</type></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the handler id.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-value-array-build" role="function">
<title>tp_value_array_build ()</title>
<indexterm zone="tp-value-array-build"><primary sortas="tp_value_array_build">tp_value_array_build</primary></indexterm><programlisting><link linkend="GValueArray">GValueArray</link> *       tp_value_array_build                (<link linkend="gsize">gsize</link> length,
                                                         <link linkend="GType">GType</link> type,
                                                         ...);</programlisting>
<para>
Creates a new <link linkend="GValueArray"><type>GValueArray</type></link> for use with structs, containing the values
passed in as parameters. The values are copied or reffed as appropriate for
their type.
</para>
<para>
<example>
  <title> using tp_value_array_build</title>
   <programlisting>
GValueArray *array = tp_value_array_build (2,
   G_TYPE_STRING, host,
   G_TYPE_UINT, port,
   G_TYPE_INVALID);
   </programlisting>
</example></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>length</parameter>&#160;:</term>
<listitem><simpara> The number of elements that should be in the array
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>type</parameter>&#160;:</term>
<listitem><simpara> The type of the first argument.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>...</parameter>&#160;:</term>
<listitem><simpara> The value of the first item in the struct followed by a list of type,
value pairs terminated by G_TYPE_INVALID.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a newly created <link linkend="GValueArray"><type>GValueArray</type></link>, free with g_value_array_free.
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>




</refentry>
