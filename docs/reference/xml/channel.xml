<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="telepathy-glib-channel">
<refmeta>
<refentrytitle role="top_of_page" id="telepathy-glib-channel.top_of_page">TpChannel</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>TELEPATHY-GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>TpChannel</refname>
<refpurpose>proxy object for a Telepathy channel</refpurpose>
</refnamediv>

<refsynopsisdiv id="telepathy-glib-channel.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>
<anchor id="TpChannel"/>
<synopsis>

#include &lt;telepathy-glib/channel.h&gt;

                    <link linkend="TpChannel-struct">TpChannel</link>;
                    <link linkend="TpChannelClass">TpChannelClass</link>;
<link linkend="TpChannel">TpChannel</link> *         <link linkend="tp-channel-new">tp_channel_new</link>                      (<link linkend="TpConnection">TpConnection</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *object_path,
                                                         const <link linkend="gchar">gchar</link> *optional_channel_type,
                                                         <link linkend="TpHandleType">TpHandleType</link> optional_handle_type,
                                                         <link linkend="TpHandle">TpHandle</link> optional_handle,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="TpChannel">TpChannel</link> *         <link linkend="tp-channel-new-from-properties">tp_channel_new_from_properties</link>      (<link linkend="TpConnection">TpConnection</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *object_path,
                                                         const <link linkend="GHashTable">GHashTable</link> *immutable_properties,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-channel-run-until-ready">tp_channel_run_until_ready</link>          (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="void">void</link>                (<link linkend="TpChannelWhenReadyCb">*TpChannelWhenReadyCb</link>)             (<link linkend="TpChannel">TpChannel</link> *channel,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="void">void</link>                <link linkend="tp-channel-call-when-ready">tp_channel_call_when_ready</link>          (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="TpChannelWhenReadyCb">TpChannelWhenReadyCb</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="void">void</link>                <link linkend="tp-channel-init-known-interfaces">tp_channel_init_known_interfaces</link>    (void);
<link linkend="TpConnection">TpConnection</link> *      <link linkend="tp-channel-borrow-connection">tp_channel_borrow_connection</link>        (<link linkend="TpChannel">TpChannel</link> *self);
<link linkend="GHashTable">GHashTable</link> *        <link linkend="tp-channel-borrow-immutable-properties">tp_channel_borrow_immutable_properties</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *self);
const <link linkend="gchar">gchar</link> *       <link linkend="tp-channel-get-channel-type">tp_channel_get_channel_type</link>         (<link linkend="TpChannel">TpChannel</link> *self);
<link linkend="GQuark">GQuark</link>              <link linkend="tp-channel-get-channel-type-id">tp_channel_get_channel_type_id</link>      (<link linkend="TpChannel">TpChannel</link> *self);
<link linkend="TpHandle">TpHandle</link>            <link linkend="tp-channel-get-handle">tp_channel_get_handle</link>               (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="TpHandleType">TpHandleType</link> *handle_type);
const <link linkend="gchar">gchar</link> *       <link linkend="tp-channel-get-identifier">tp_channel_get_identifier</link>           (<link linkend="TpChannel">TpChannel</link> *self);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-channel-is-ready">tp_channel_is_ready</link>                 (<link linkend="TpChannel">TpChannel</link> *self);

<link linkend="TpChannelGroupFlags">TpChannelGroupFlags</link>  <link linkend="tp-channel-group-get-flags">tp_channel_group_get_flags</link>         (<link linkend="TpChannel">TpChannel</link> *self);
<link linkend="TpHandle">TpHandle</link>            <link linkend="tp-channel-group-get-handle-owner">tp_channel_group_get_handle_owner</link>   (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle);
<link linkend="TpHandle">TpHandle</link>            <link linkend="tp-channel-group-get-self-handle">tp_channel_group_get_self_handle</link>    (<link linkend="TpChannel">TpChannel</link> *self);
const <link linkend="TpIntSet">TpIntSet</link> *    <link linkend="tp-channel-group-get-local-pending">tp_channel_group_get_local_pending</link>  (<link linkend="TpChannel">TpChannel</link> *self);
const <link linkend="TpIntSet">TpIntSet</link> *    <link linkend="tp-channel-group-get-members">tp_channel_group_get_members</link>        (<link linkend="TpChannel">TpChannel</link> *self);
const <link linkend="TpIntSet">TpIntSet</link> *    <link linkend="tp-channel-group-get-remote-pending">tp_channel_group_get_remote_pending</link> (<link linkend="TpChannel">TpChannel</link> *self);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-channel-group-get-local-pending-info">tp_channel_group_get_local_pending_info</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> local_pending,
                                                         <link linkend="TpHandle">TpHandle</link> *actor,
                                                         <link linkend="TpChannelGroupChangeReason">TpChannelGroupChangeReason</link> *reason,
                                                         const <link linkend="gchar">gchar</link> **message);
#define             <link linkend="TP-ERRORS-REMOVED-FROM-GROUP--CAPS">TP_ERRORS_REMOVED_FROM_GROUP</link>


<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-call-close">tp_cli_channel_call_close</link>          (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-callback-for-close">tp_cli_channel_callback_for_close</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-call-get-channel-type">tp_cli_channel_call_get_channel_type</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-callback-for-get-channel-type">tp_cli_channel_callback_for_get_channel_type</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-call-get-handle">tp_cli_channel_call_get_handle</link>     (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-callback-for-get-handle">tp_cli_channel_callback_for_get_handle</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-call-get-interfaces">tp_cli_channel_call_get_interfaces</link> (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-callback-for-get-interfaces">tp_cli_channel_callback_for_get_interfaces</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-callback-for-close">*tp_cli_channel_callback_for_close</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-callback-for-get-channel-type">*tp_cli_channel_callback_for_get_channel_type</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="gchar">gchar</link> *out_Channel_Type,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-callback-for-get-handle">*tp_cli_channel_callback_for_get_handle</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> out_Target_Handle_Type,
                                                         <link linkend="guint">guint</link> out_Target_Handle,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-callback-for-get-interfaces">*tp_cli_channel_callback_for_get_interfaces</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="gchar">gchar</link> **out_Interfaces,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-run-close">tp_cli_channel_run_close</link>            (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-run-get-channel-type">tp_cli_channel_run_get_channel_type</link> (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="gchar">gchar</link> **out_Channel_Type,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-run-get-handle">tp_cli_channel_run_get_handle</link>       (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> *out_Target_Handle_Type,
                                                         <link linkend="guint">guint</link> *out_Target_Handle,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-run-get-interfaces">tp_cli_channel_run_get_interfaces</link>   (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="gchar">gchar</link> ***out_Interfaces,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
<link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * <link linkend="tp-cli-channel-connect-to-closed">tp_cli_channel_connect_to_closed</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-signal-callback-closed">tp_cli_channel_signal_callback_closed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-signal-callback-closed">*tp_cli_channel_signal_callback_closed</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);

<link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * <link linkend="tp-cli-channel-interface-destroyable-call-destroy">tp_cli_channel_interface_destroyable_call_destroy</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-interface-destroyable-callback-for-destroy">tp_cli_channel_interface_destroyable_callback_for_destroy</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="void">void</link>                (<link linkend="tp-cli-channel-interface-destroyable-callback-for-destroy">*tp_cli_channel_interface_destroyable_callback_for_destroy</link>)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);
<link linkend="gboolean">gboolean</link>            <link linkend="tp-cli-channel-interface-destroyable-run-destroy">tp_cli_channel_interface_destroyable_run_destroy</link>
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);
</synopsis>
</refsynopsisdiv>

<refsect1 id="telepathy-glib-channel.object-hierarchy" role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<synopsis>
  <link linkend="GObject">GObject</link>
   +----<link linkend="TpProxy">TpProxy</link>
         +----TpChannel
</synopsis>
</refsect1>



<refsect1 id="telepathy-glib-channel.implemented-interfaces" role="impl_interfaces">
<title role="impl_interfaces.title">Implemented Interfaces</title>
<para>
TpChannel implements
 <link linkend="TpChannelIface">TpChannelIface</link>.</para>
</refsect1>


<refsect1 id="telepathy-glib-channel.properties" role="properties">
<title role="properties.title">Properties</title>
<synopsis>
  &quot;<link linkend="TpChannel--channel-properties">channel-properties</link>&quot;       <link linkend="GHashTable-gchararray+GValue-*">GHashTable_gchararray+GValue_*</link>  : Read / Write / Construct Only
  &quot;<link linkend="TpChannel--channel-ready">channel-ready</link>&quot;            <link linkend="gboolean">gboolean</link>              : Read
  &quot;<link linkend="TpChannel--connection">connection</link>&quot;               <link linkend="TpConnection">TpConnection</link>*         : Read / Write / Construct Only
  &quot;<link linkend="TpChannel--group-flags">group-flags</link>&quot;              <link linkend="guint">guint</link>                 : Read
  &quot;<link linkend="TpChannel--group-self-handle">group-self-handle</link>&quot;        <link linkend="guint">guint</link>                 : Read
  &quot;<link linkend="TpChannel--identifier">identifier</link>&quot;               <link linkend="gchar">gchar</link>*                : Read
</synopsis>
</refsect1>

<refsect1 id="telepathy-glib-channel.signals" role="signal_proto">
<title role="signal_proto.title">Signals</title>
<synopsis>
  &quot;<link linkend="TpChannel-group-flags-changed">group-flags-changed</link>&quot;                            : Run Last / Has Details
  &quot;<link linkend="TpChannel-group-members-changed">group-members-changed</link>&quot;                          : Run Last / Has Details
  &quot;<link linkend="TpChannel-group-members-changed-detailed">group-members-changed-detailed</link>&quot;                 : Run Last / Has Details
</synopsis>
</refsect1>


<refsect1 id="telepathy-glib-channel.description" role="desc">
<title role="desc.title">Description</title>
<para>
<link linkend="TpChannel"><type>TpChannel</type></link> objects provide convenient access to Telepathy channels.
</para>
<para>
Compared with a simple proxy for method calls, they add the following
features:
</para>
<para>
* calling <link linkend="GetChannelType"><function>GetChannelType()</function></link>, <link linkend="GetInterfaces"><function>GetInterfaces()</function></link>, <link linkend="GetHandles"><function>GetHandles()</function></link> automatically
</para>
<para>
This section also documents the auto-generated C wrappers for the
Channel D-Bus interface. Of these, in general, only
<link linkend="tp-cli-channel-call-close"><function>tp_cli_channel_call_close()</function></link> and <link linkend="tp-cli-channel-run-close"><function>tp_cli_channel_run_close()</function></link> are useful (the
<link linkend="TpChannel"><type>TpChannel</type></link> object provides a more convenient API for the rest).</para>
<para>
</para>
</refsect1>

<refsect1 id="telepathy-glib-channel.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="TpChannel-struct" role="struct">
<title>TpChannel</title>
<indexterm zone="TpChannel-struct" role="0.7.1"><primary sortas="TpChannel">TpChannel</primary></indexterm><programlisting>typedef struct _TpChannel TpChannel;</programlisting>
<para>
A proxy object for a Telepathy channel.
</para>
<para>
(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</para>
<para>
</para><variablelist role="struct">
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="TpChannelClass" role="struct" condition="since:0.7.1">
<title>TpChannelClass</title>
<indexterm zone="TpChannelClass" role="0.7.1"><primary sortas="TpChannelClass">TpChannelClass</primary></indexterm><programlisting>typedef struct {
    TpProxyClass parent_class;
} TpChannelClass;
</programlisting>
<para>
The class of a <link linkend="TpChannel"><type>TpChannel</type></link>. In addition to <parameter>parent_class</parameter> there are four
pointers reserved for possible future use.
</para>
<para>
(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</para>
<para>
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="TpProxyClass">TpProxyClass</link>&#160;<structfield>parent_class</structfield>;</term>
<listitem><simpara> parent class
</simpara></listitem>
</varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-channel-new" role="function" condition="since:0.7.1">
<title>tp_channel_new ()</title>
<indexterm zone="tp-channel-new" role="0.7.1"><primary sortas="tp_channel_new">tp_channel_new</primary></indexterm><programlisting><link linkend="TpChannel">TpChannel</link> *         tp_channel_new                      (<link linkend="TpConnection">TpConnection</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *object_path,
                                                         const <link linkend="gchar">gchar</link> *optional_channel_type,
                                                         <link linkend="TpHandleType">TpHandleType</link> optional_handle_type,
                                                         <link linkend="TpHandle">TpHandle</link> optional_handle,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
<!-- --></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&#160;:</term>
<listitem><simpara> a connection; may not be <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>object_path</parameter>&#160;:</term>
<listitem><simpara> the object path of the channel; may not be <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>optional_channel_type</parameter>&#160;:</term>
<listitem><simpara> the channel type if already known, or <link linkend="NULL--CAPS"><literal>NULL</literal></link> if not
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>optional_handle_type</parameter>&#160;:</term>
<listitem><simpara> the handle type if already known, or
 <link linkend="TP-UNKNOWN-HANDLE-TYPE--CAPS"><literal>TP_UNKNOWN_HANDLE_TYPE</literal></link> if not
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>optional_handle</parameter>&#160;:</term>
<listitem><simpara> the handle if already known, or 0 if not
 (if <parameter>optional_handle_type</parameter> is <link linkend="TP-UNKNOWN-HANDLE-TYPE--CAPS"><literal>TP_UNKNOWN_HANDLE_TYPE</literal></link> or
 <link linkend="TP-HANDLE-TYPE-NONE--CAPS"><literal>TP_HANDLE_TYPE_NONE</literal></link>, this must be 0)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> used to indicate the error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a new channel proxy, or <link linkend="NULL--CAPS"><literal>NULL</literal></link> on invalid arguments.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-channel-new-from-properties" role="function" condition="since:0.7.19">
<title>tp_channel_new_from_properties ()</title>
<indexterm zone="tp-channel-new-from-properties" role="0.7.19"><primary sortas="tp_channel_new_from_properties">tp_channel_new_from_properties</primary></indexterm><programlisting><link linkend="TpChannel">TpChannel</link> *         tp_channel_new_from_properties      (<link linkend="TpConnection">TpConnection</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *object_path,
                                                         const <link linkend="GHashTable">GHashTable</link> *immutable_properties,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
<!-- --></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&#160;:</term>
<listitem><simpara> a connection; may not be <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>object_path</parameter>&#160;:</term>
<listitem><simpara> the object path of the channel; may not be <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>immutable_properties</parameter>&#160;:</term>
<listitem><simpara> the immutable properties of the channel,
 as signalled by the NewChannel D-Bus signal or returned by the
 CreateChannel and EnsureChannel D-Bus methods: a mapping from
 strings (D-Bus interface name + "." + property name) to <link linkend="GValue"><type>GValue</type></link> instances
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> used to indicate the error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a new channel proxy, or <link linkend="NULL--CAPS"><literal>NULL</literal></link> on invalid arguments

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.19</para></refsect2>
<refsect2 id="tp-channel-run-until-ready" role="function" condition="since:0.7.1">
<title>tp_channel_run_until_ready ()</title>
<indexterm zone="tp-channel-run-until-ready" role="0.7.1"><primary sortas="tp_channel_run_until_ready">tp_channel_run_until_ready</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_channel_run_until_ready          (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
If <parameter>self</parameter> is ready for use (introspection has finished, etc.), return
immediately. Otherwise, re-enter the main loop until the channel either
becomes invalid or becomes ready for use, or until the main loop stored
via <parameter>loop</parameter> is cancelled.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> if not <link linkend="NULL--CAPS"><literal>NULL</literal></link> and <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> is returned, used to raise an error
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> if not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GMainLoop"><type>GMainLoop</type></link> is placed here while it is being run
 (so calling code can call <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link> to abort), and <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
 placed here after the loop has been run
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> if the channel has been introspected and is ready for use,
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> if the channel has become invalid.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="TpChannelWhenReadyCb" role="function">
<title>TpChannelWhenReadyCb ()</title>
<indexterm zone="TpChannelWhenReadyCb"><primary sortas="TpChannelWhenReadyCb">TpChannelWhenReadyCb</primary></indexterm><programlisting><link linkend="void">void</link>                (*TpChannelWhenReadyCb)             (<link linkend="TpChannel">TpChannel</link> *channel,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Signature of a callback passed to <link linkend="tp-channel-call-when-ready"><function>tp_channel_call_when_ready()</function></link>, which
will be called exactly once, when the channel becomes ready or
invalid (whichever happens first)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>channel</parameter>&#160;:</term>
<listitem><simpara> the channel (which may be in the middle of being disposed,
 if error is non-<link linkend="NULL--CAPS"><literal>NULL</literal></link>, error->domain is TP_DBUS_ERRORS and error->code is
 TP_DBUS_ERROR_PROXY_UNREFERENCED)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> if the channel is ready for use, or the error with which
 it was invalidated if it is now invalid
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> whatever was passed to <link linkend="tp-channel-call-when-ready"><function>tp_channel_call_when_ready()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-channel-call-when-ready" role="function" condition="since:0.7.7">
<title>tp_channel_call_when_ready ()</title>
<indexterm zone="tp-channel-call-when-ready" role="0.7.7"><primary sortas="tp_channel_call_when_ready">tp_channel_call_when_ready</primary></indexterm><programlisting><link linkend="void">void</link>                tp_channel_call_when_ready          (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="TpChannelWhenReadyCb">TpChannelWhenReadyCb</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
If <parameter>self</parameter> is ready for use or has been invalidated, call <parameter>callback</parameter>
immediately, then return. Otherwise, arrange
for <parameter>callback</parameter> to be called when <parameter>self</parameter> either becomes ready for use
or becomes invalid.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the channel becomes ready or invalidated, whichever
 happens first
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> arbitrary user-supplied data passed to the callback
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.7</para></refsect2>
<refsect2 id="tp-channel-init-known-interfaces" role="function" condition="since:0.7.6">
<title>tp_channel_init_known_interfaces ()</title>
<indexterm zone="tp-channel-init-known-interfaces" role="0.7.6"><primary sortas="tp_channel_init_known_interfaces">tp_channel_init_known_interfaces</primary></indexterm><programlisting><link linkend="void">void</link>                tp_channel_init_known_interfaces    (void);</programlisting>
<para>
Ensure that the known interfaces for TpChannel have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
<link linkend="tp-proxy-or-subclass-hook-on-interface-add"><function>tp_proxy_or_subclass_hook_on_interface_add()</function></link> with first argument
<link linkend="TP-TYPE-CHANNEL--CAPS"><literal>TP_TYPE_CHANNEL</literal></link>.</para>
<para>
</para><para role="since">Since 0.7.6</para></refsect2>
<refsect2 id="tp-channel-borrow-connection" role="function" condition="since:0.7.12">
<title>tp_channel_borrow_connection ()</title>
<indexterm zone="tp-channel-borrow-connection" role="0.7.12"><primary sortas="tp_channel_borrow_connection">tp_channel_borrow_connection</primary></indexterm><programlisting><link linkend="TpConnection">TpConnection</link> *      tp_channel_borrow_connection        (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
Returns the connection for this channel. The returned pointer is only valid
while this channel is valid - reference it with <link linkend="g-object-ref"><function>g_object_ref()</function></link> if needed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the value of <link linkend="TpChannel--connection"><type>"connection"</type></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-borrow-immutable-properties" role="function">
<title>tp_channel_borrow_immutable_properties ()</title>
<indexterm zone="tp-channel-borrow-immutable-properties"><primary sortas="tp_channel_borrow_immutable_properties">tp_channel_borrow_immutable_properties</primary></indexterm><programlisting><link linkend="GHashTable">GHashTable</link> *        tp_channel_borrow_immutable_properties
                                                        (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
Returns the immutable D-Bus properties of this channel, the same as
<link linkend="TpChannel--channel-properties"><type>"channel-properties"</type></link>.
</para>
<para>
The returned hash table should not be altered, and is not necessarily
valid after the main loop is next re-entered. Copy it with
<link linkend="g-boxed-copy"><function>g_boxed_copy()</function></link> (its type is <link linkend="TP-HASH-TYPE-QUALIFIED-PROPERTY-VALUE-MAP--CAPS"><literal>TP_HASH_TYPE_QUALIFIED_PROPERTY_VALUE_MAP</literal></link>)
if a copy that remains valid must be kept.
</para>
<para>
If the <link linkend="TpChannel--channel-properties"><type>"channel-properties"</type></link> property was not set during
construction (e.g. by calling <link linkend="tp-channel-new-from-properties"><function>tp_channel_new_from_properties()</function></link>), a
reasonable but possibly incomplete version will be made up from the values
of individual properties; reading this property repeatedly may yield
progressively more complete values until <link linkend="TpChannel--channel-ready"><type>"channel-ready"</type></link>
becomes <link linkend="TRUE--CAPS"><literal>TRUE</literal></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="GHashTable"><type>GHashTable</type></link> where the keys are strings,
 D-Bus interface name + "." + property name, and the values are <link linkend="GValue"><type>GValue</type></link>
 instances
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-channel-get-channel-type" role="function" condition="since:0.7.12">
<title>tp_channel_get_channel_type ()</title>
<indexterm zone="tp-channel-get-channel-type" role="0.7.12"><primary sortas="tp_channel_get_channel_type">tp_channel_get_channel_type</primary></indexterm><programlisting>const <link linkend="gchar">gchar</link> *       tp_channel_get_channel_type         (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
Get the D-Bus interface name representing this channel's type,
if it has been discovered.
</para>
<para>
This is the same as the <link linkend="TpChannel--channel-type"><type>"channel-type"</type></link> property.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the channel type, if the channel is ready; either the channel
 type or <link linkend="NULL--CAPS"><literal>NULL</literal></link>, if the channel is not yet ready.
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-get-channel-type-id" role="function" condition="since:0.7.12">
<title>tp_channel_get_channel_type_id ()</title>
<indexterm zone="tp-channel-get-channel-type-id" role="0.7.12"><primary sortas="tp_channel_get_channel_type_id">tp_channel_get_channel_type_id</primary></indexterm><programlisting><link linkend="GQuark">GQuark</link>              tp_channel_get_channel_type_id      (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
Get the D-Bus interface name representing this channel's type, as a GQuark,
if it has been discovered.
</para>
<para>
This is the same as the <link linkend="TpChannel--channel-type"><type>"channel-type"</type></link> property, except that it
is a GQuark rather than a string.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the channel type, if the channel is ready; either the channel
 type or 0, if the channel is not yet ready.
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-get-handle" role="function" condition="since:0.7.12">
<title>tp_channel_get_handle ()</title>
<indexterm zone="tp-channel-get-handle" role="0.7.12"><primary sortas="tp_channel_get_handle">tp_channel_get_handle</primary></indexterm><programlisting><link linkend="TpHandle">TpHandle</link>            tp_channel_get_handle               (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="TpHandleType">TpHandleType</link> *handle_type);</programlisting>
<para>
Get the handle representing the contact, chatroom, etc. with which this
channel communicates for its whole lifetime, or 0 if there is no such
handle or it has not yet been discovered.
</para>
<para>
This is the same as the <link linkend="TpChannel--handle"><type>"handle"</type></link> property.
</para>
<para>
If <link linkend="handle-type"><literal>handle_type</literal></link> is not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, the type of handle is written into it.
This will be <link linkend="TP-UNKNOWN-HANDLE-TYPE--CAPS"><literal>TP_UNKNOWN_HANDLE_TYPE</literal></link> if the handle has not yet been
discovered, or <link linkend="TP-HANDLE-TYPE-NONE--CAPS"><literal>TP_HANDLE_TYPE_NONE</literal></link> if there is no handle with which this
channel will always communicate. This is the same as the
<link linkend="TpChannel--handle-type"><type>"handle-type"</type></link> property.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle_type</parameter>&#160;:</term>
<listitem><simpara> if not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return the type of this handle
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the handle
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-get-identifier" role="function" condition="since:0.7.21">
<title>tp_channel_get_identifier ()</title>
<indexterm zone="tp-channel-get-identifier" role="0.7.21"><primary sortas="tp_channel_get_identifier">tp_channel_get_identifier</primary></indexterm><programlisting>const <link linkend="gchar">gchar</link> *       tp_channel_get_identifier           (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
This channel's associated identifier, or NULL if no identifier or unknown.
</para>
<para>
The identifier is the result of inspecting <link linkend="TpChannel--handle"><type>"handle"</type></link>.
This is the same as the <link linkend="TpChannel--identifier"><type>"identifier"</type></link> property.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the identifier
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.21</para></refsect2>
<refsect2 id="tp-channel-is-ready" role="function" condition="since:0.7.12">
<title>tp_channel_is_ready ()</title>
<indexterm zone="tp-channel-is-ready" role="0.7.12"><primary sortas="tp_channel_is_ready">tp_channel_is_ready</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_channel_is_ready                 (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
Returns the same thing as the <link linkend="TpChannel--channel-ready"><type>"channel-ready"</type></link> property.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> if introspection has completed
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-group-get-flags" role="function" condition="since:0.7.12">
<title>tp_channel_group_get_flags ()</title>
<indexterm zone="tp-channel-group-get-flags" role="0.7.12"><primary sortas="tp_channel_group_get_flags">tp_channel_group_get_flags</primary></indexterm><programlisting><link linkend="TpChannelGroupFlags">TpChannelGroupFlags</link>  tp_channel_group_get_flags         (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
Return the <link linkend="TpChannel--group-flags"><type>"group-flags"</type></link> property (see the description
of that property for notes on validity).</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the group flags, or 0
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-group-get-handle-owner" role="function" condition="since:0.7.12">
<title>tp_channel_group_get_handle_owner ()</title>
<indexterm zone="tp-channel-group-get-handle-owner" role="0.7.12"><primary sortas="tp_channel_group_get_handle_owner">tp_channel_group_get_handle_owner</primary></indexterm><programlisting><link linkend="TpHandle">TpHandle</link>            tp_channel_group_get_handle_owner   (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> handle);</programlisting>
<para>
Synopsis (see below for further explanation):
</para>
<para>
- if <parameter>self</parameter> is not a group or <parameter>handle</parameter> is not a member of this channel,
  result is undefined;
- if <parameter>self</parameter> does not have <link linkend="TpChannel--ready"><type>"ready"</type></link> = TRUE, result is undefined;
- if <parameter>self</parameter> does not have flags that include <link linkend="TP-CHANNEL-FLAG-PROPERTIES--CAPS"><literal>TP_CHANNEL_FLAG_PROPERTIES</literal></link>,
  result is undefined;
- if <parameter>handle</parameter> is channel-specific and its globally valid "owner" is known,
  return that owner;
- if <parameter>handle</parameter> is channel-specific and its globally valid "owner" is unknown,
  return zero;
- if <parameter>handle</parameter> is globally valid, return <parameter>handle</parameter> itself
</para>
<para>
Some channels (those with flags that include
<link linkend="TP-CHANNEL-FLAG-CHANNEL-SPECIFIC-HANDLES--CAPS"><literal>TP_CHANNEL_FLAG_CHANNEL_SPECIFIC_HANDLES</literal></link>) have a concept of
"channel-specific handles". These are handles that only have meaning within
the context of the channel - for instance, in XMPP Multi-User Chat,
participants in a chatroom are identified by an in-room JID consisting
of the JID of the chatroom plus a local nickname.
</para>
<para>
Depending on the protocol and configuration, it might be possible to find
out what globally valid handle (i.e. an identifier that you could add to
your contact list) "owns" a channel-specific handle. For instance, in
most XMPP MUC chatrooms, normal users cannot see what global JID
corresponds to an in-room JID, but moderators can.
</para>
<para>
This is further complicated by the fact that channels with channel-specific
handles can sometimes have members with globally valid handles (for
instance, if you invite someone to an XMPP MUC using their globally valid
JID, you would expect to see the handle representing that JID in the
Group's remote-pending set).
</para>
<para>
This function's result is undefined unless the channel is ready
and its flags include <link linkend="TP-CHANNEL-FLAG-PROPERTIES--CAPS"><literal>TP_CHANNEL_FLAG_PROPERTIES</literal></link> (an implementation
without extra D-Bus round trips is not possible using the older API).</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handle</parameter>&#160;:</term>
<listitem><simpara> a handle which is a member of this channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the global handle that owns the given handle, or 0
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-group-get-self-handle" role="function" condition="since:0.7.12">
<title>tp_channel_group_get_self_handle ()</title>
<indexterm zone="tp-channel-group-get-self-handle" role="0.7.12"><primary sortas="tp_channel_group_get_self_handle">tp_channel_group_get_self_handle</primary></indexterm><programlisting><link linkend="TpHandle">TpHandle</link>            tp_channel_group_get_self_handle    (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
Return the <link linkend="TpChannel--group-self-handle"><type>"group-self-handle"</type></link> property (see the description
of that property for notes on validity).</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the handle representing the user, or 0
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-group-get-local-pending" role="function" condition="since:0.7.12">
<title>tp_channel_group_get_local_pending ()</title>
<indexterm zone="tp-channel-group-get-local-pending" role="0.7.12"><primary sortas="tp_channel_group_get_local_pending">tp_channel_group_get_local_pending</primary></indexterm><programlisting>const <link linkend="TpIntSet">TpIntSet</link> *    tp_channel_group_get_local_pending  (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
If <parameter>self</parameter> is ready and is a group, return a <link linkend="TpIntSet"><type>TpIntSet</type></link> containing
its local-pending members.
</para>
<para>
If <parameter>self</parameter> is a group but is not ready, the result may either be a set
of local-pending members, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>.
</para>
<para>
If <parameter>self</parameter> is not a group, return <link linkend="NULL--CAPS"><literal>NULL</literal></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the local-pending members, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-group-get-members" role="function" condition="since:0.7.12">
<title>tp_channel_group_get_members ()</title>
<indexterm zone="tp-channel-group-get-members" role="0.7.12"><primary sortas="tp_channel_group_get_members">tp_channel_group_get_members</primary></indexterm><programlisting>const <link linkend="TpIntSet">TpIntSet</link> *    tp_channel_group_get_members        (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
If <parameter>self</parameter> is ready and is a group, return a <link linkend="TpIntSet"><type>TpIntSet</type></link> containing
its members.
</para>
<para>
If <parameter>self</parameter> is a group but is not ready, the result may either be a set
of members, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>.
</para>
<para>
If <parameter>self</parameter> is not a group, return <link linkend="NULL--CAPS"><literal>NULL</literal></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the members, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-group-get-remote-pending" role="function" condition="since:0.7.12">
<title>tp_channel_group_get_remote_pending ()</title>
<indexterm zone="tp-channel-group-get-remote-pending" role="0.7.12"><primary sortas="tp_channel_group_get_remote_pending">tp_channel_group_get_remote_pending</primary></indexterm><programlisting>const <link linkend="TpIntSet">TpIntSet</link> *    tp_channel_group_get_remote_pending (<link linkend="TpChannel">TpChannel</link> *self);</programlisting>
<para>
If <parameter>self</parameter> is ready and is a group, return a <link linkend="TpIntSet"><type>TpIntSet</type></link> containing
its remote-pending members.
</para>
<para>
If <parameter>self</parameter> is a group but is not ready, the result may either be a set
of remote-pending members, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>.
</para>
<para>
If <parameter>self</parameter> is not a group, return <link linkend="NULL--CAPS"><literal>NULL</literal></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the remote-pending members, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="tp-channel-group-get-local-pending-info" role="function" condition="since:0.7.12">
<title>tp_channel_group_get_local_pending_info ()</title>
<indexterm zone="tp-channel-group-get-local-pending-info" role="0.7.12"><primary sortas="tp_channel_group_get_local_pending_info">tp_channel_group_get_local_pending_info</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_channel_group_get_local_pending_info
                                                        (<link linkend="TpChannel">TpChannel</link> *self,
                                                         <link linkend="TpHandle">TpHandle</link> local_pending,
                                                         <link linkend="TpHandle">TpHandle</link> *actor,
                                                         <link linkend="TpChannelGroupChangeReason">TpChannelGroupChangeReason</link> *reason,
                                                         const <link linkend="gchar">gchar</link> **message);</programlisting>
<para>
If <parameter>local_pending</parameter> is actually the handle of a local-pending contact,
write additional information into <parameter>actor</parameter>, <parameter>reason</parameter> and <parameter>message</parameter> and return
<link linkend="TRUE--CAPS"><literal>TRUE</literal></link>. The handle and message are not referenced or copied, and can only be
assumed to remain valid until the main loop is re-entered.
</para>
<para>
If <parameter>local_pending</parameter> is not the handle of a local-pending contact,
write 0 into <parameter>actor</parameter>, <link linkend="TP-CHANNEL-GROUP-CHANGE-REASON-NONE--CAPS"><literal>TP_CHANNEL_GROUP_CHANGE_REASON_NONE</literal></link> into <parameter>reason</parameter>
and "" into <parameter>message</parameter>, and return <link linkend="FALSE--CAPS"><literal>FALSE</literal></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>local_pending</parameter>&#160;:</term>
<listitem><simpara> the handle of a local-pending contact about whom more
 information is needed
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>actor</parameter>&#160;:</term>
<listitem><simpara> either <link linkend="NULL--CAPS"><literal>NULL</literal></link> or a location to return the contact who requested
 the change
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>reason</parameter>&#160;:</term>
<listitem><simpara> either <link linkend="NULL--CAPS"><literal>NULL</literal></link> or a location to return the reason for the change
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message</parameter>&#160;:</term>
<listitem><simpara> either <link linkend="NULL--CAPS"><literal>NULL</literal></link> or a location to return the user-supplied message
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> if the contact is in fact local-pending
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.7.12</para></refsect2>
<refsect2 id="TP-ERRORS-REMOVED-FROM-GROUP--CAPS" role="macro" condition="since:0.7.1">
<title>TP_ERRORS_REMOVED_FROM_GROUP</title>
<indexterm zone="TP-ERRORS-REMOVED-FROM-GROUP--CAPS" role="0.7.1"><primary sortas="TP_ERRORS_REMOVED_FROM_GROUP">TP_ERRORS_REMOVED_FROM_GROUP</primary></indexterm><programlisting>#define TP_ERRORS_REMOVED_FROM_GROUP (tp_errors_removed_from_group_quark ())
</programlisting>
<para>
<link linkend="GError"><type>GError</type></link> domain representing the local user being removed from a channel
with the Group interface. The <parameter>code</parameter> in a <link linkend="GError"><type>GError</type></link> with this domain must
be a member of <link linkend="TpChannelGroupChangeReason"><type>TpChannelGroupChangeReason</type></link>.
</para>
<para>
This error may be raised on non-Group channels with certain reason codes
if there's no better error code to use (mainly
<link linkend="TP-CHANNEL-GROUP-CHANGE-REASON-NONE--CAPS"><literal>TP_CHANNEL_GROUP_CHANGE_REASON_NONE</literal></link>).
</para>
<para>
This macro expands to a function call returning a <link linkend="GQuark"><type>GQuark</type></link>.</para>
<para>
</para><para role="since">Since 0.7.1</para></refsect2>
<refsect2 id="tp-cli-channel-call-close" role="function">
<title>tp_cli_channel_call_close ()</title>
<indexterm zone="tp-cli-channel-call-close"><primary sortas="tp_cli_channel_call_close">tp_cli_channel_call_close</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_call_close          (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-callback-for-close">tp_cli_channel_callback_for_close</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a Close method call.
</para>
<para>
Request that the channel be closed. This is not the case until         the &lt;tp:member-ref&gt;Closed&lt;/tp:member-ref&gt; signal has been emitted, and         depending on the connection         manager this may simply remove you from the channel on the server,         rather than causing it to stop existing entirely. Some channels         such as contact list channels may not be closed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-call-get-channel-type" role="function" condition="deprecated:Use the ChannelType         property if possible.">
<title>tp_cli_channel_call_get_channel_type ()</title>
<indexterm zone="tp-cli-channel-call-get-channel-type" role="deprecated"><primary sortas="tp_cli_channel_call_get_channel_type">tp_cli_channel_call_get_channel_type</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_call_get_channel_type
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-callback-for-get-channel-type">tp_cli_channel_callback_for_get_channel_type</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<warning><para><literal>tp_cli_channel_call_get_channel_type</literal> is deprecated and should not be used in newly-written code. Use the ChannelType         property if possible.</para></warning>
<para>
Start a GetChannelType method call.
</para>
<para>
Returns the interface name for the type of this channel.  Clients         SHOULD use the &lt;tp:member-ref&gt;ChannelType&lt;/tp:member-ref&gt; property         instead, falling back to this method only if necessary.          &lt;tp:rationale&gt;           The GetAll method lets clients retrieve all properties in one           round-trip.         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-call-get-handle" role="function" condition="deprecated:Use the TargetHandleType         and TargetHandle properties if possible.">
<title>tp_cli_channel_call_get_handle ()</title>
<indexterm zone="tp-cli-channel-call-get-handle" role="deprecated"><primary sortas="tp_cli_channel_call_get_handle">tp_cli_channel_call_get_handle</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_call_get_handle     (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-callback-for-get-handle">tp_cli_channel_callback_for_get_handle</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<warning><para><literal>tp_cli_channel_call_get_handle</literal> is deprecated and should not be used in newly-written code. Use the TargetHandleType         and TargetHandle properties if possible.</para></warning>
<para>
Start a GetHandle method call.
</para>
<para>
Returns the handle type and number if this channel represents a         communication with a particular contact, room or server-stored list, or         zero if it is transient and defined only by its contents. Clients         SHOULD use the &lt;tp:member-ref&gt;TargetHandle&lt;/tp:member-ref&gt; and         &lt;tp:member-ref&gt;TargetHandleType&lt;/tp:member-ref&gt; properties instead,         falling back to this method only if necessary.          &lt;tp:rationale&gt;           The GetAll method lets clients retrieve all properties in one           round-trip.         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-call-get-interfaces" role="function" condition="deprecated:Use the Interfaces         property if possible.">
<title>tp_cli_channel_call_get_interfaces ()</title>
<indexterm zone="tp-cli-channel-call-get-interfaces" role="deprecated"><primary sortas="tp_cli_channel_call_get_interfaces">tp_cli_channel_call_get_interfaces</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_call_get_interfaces (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-callback-for-get-interfaces">tp_cli_channel_callback_for_get_interfaces</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<warning><para><literal>tp_cli_channel_call_get_interfaces</literal> is deprecated and should not be used in newly-written code. Use the Interfaces         property if possible.</para></warning>
<para>
Start a GetInterfaces method call.
</para>
<para>
Get the optional interfaces implemented by the channel.         Clients SHOULD use the &lt;tp:member-ref&gt;Interfaces&lt;/tp:member-ref&gt;         property instead, falling back to this method only if necessary.          &lt;tp:rationale&gt;           The GetAll method lets clients retrieve all properties in one           round-trip.         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-callback-for-close" role="function">
<title>tp_cli_channel_callback_for_close ()</title>
<indexterm zone="tp-cli-channel-callback-for-close"><primary sortas="tp_cli_channel_callback_for_close">tp_cli_channel_callback_for_close</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_callback_for_close)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a Close method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-callback-for-get-channel-type" role="function" condition="deprecated:Use the ChannelType         property if possible.">
<title>tp_cli_channel_callback_for_get_channel_type ()</title>
<indexterm zone="tp-cli-channel-callback-for-get-channel-type" role="deprecated"><primary sortas="tp_cli_channel_callback_for_get_channel_type">tp_cli_channel_callback_for_get_channel_type</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_callback_for_get_channel_type)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="gchar">gchar</link> *out_Channel_Type,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<warning><para><literal>tp_cli_channel_callback_for_get_channel_type</literal> is deprecated and should not be used in newly-written code. Use the ChannelType         property if possible.</para></warning>
<para>
Signature of the callback called when a GetChannelType method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Channel_Type</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: The interface name
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-callback-for-get-handle" role="function" condition="deprecated:Use the TargetHandleType         and TargetHandle properties if possible.">
<title>tp_cli_channel_callback_for_get_handle ()</title>
<indexterm zone="tp-cli-channel-callback-for-get-handle" role="deprecated"><primary sortas="tp_cli_channel_callback_for_get_handle">tp_cli_channel_callback_for_get_handle</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_callback_for_get_handle)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="guint">guint</link> out_Target_Handle_Type,
                                                         <link linkend="guint">guint</link> out_Target_Handle,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<warning><para><literal>tp_cli_channel_callback_for_get_handle</literal> is deprecated and should not be used in newly-written code. Use the TargetHandleType         and TargetHandle properties if possible.</para></warning>
<para>
Signature of the callback called when a GetHandle method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Target_Handle_Type</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: The same as TargetHandleType.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Target_Handle</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: The same as TargetHandle.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-callback-for-get-interfaces" role="function" condition="deprecated:Use the Interfaces         property if possible.">
<title>tp_cli_channel_callback_for_get_interfaces ()</title>
<indexterm zone="tp-cli-channel-callback-for-get-interfaces" role="deprecated"><primary sortas="tp_cli_channel_callback_for_get_interfaces">tp_cli_channel_callback_for_get_interfaces</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_callback_for_get_interfaces)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="gchar">gchar</link> **out_Interfaces,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<warning><para><literal>tp_cli_channel_callback_for_get_interfaces</literal> is deprecated and should not be used in newly-written code. Use the Interfaces         property if possible.</para></warning>
<para>
Signature of the callback called when a GetInterfaces method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Interfaces</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <parameter>error</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>: An array of the D-Bus interface names
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-run-close" role="function">
<title>tp_cli_channel_run_close ()</title>
<indexterm zone="tp-cli-channel-run-close"><primary sortas="tp_cli_channel_run_close">tp_cli_channel_run_close</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_run_close            (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method Close and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Request that the channel be closed. This is not the case until         the &lt;tp:member-ref&gt;Closed&lt;/tp:member-ref&gt; signal has been emitted, and         depending on the connection         manager this may simply remove you from the channel on the server,         rather than causing it to stop existing entirely. Some channels         such as contact list channels may not be closed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-run-get-channel-type" role="function" condition="deprecated:Use the ChannelType         property if possible.">
<title>tp_cli_channel_run_get_channel_type ()</title>
<indexterm zone="tp-cli-channel-run-get-channel-type" role="deprecated"><primary sortas="tp_cli_channel_run_get_channel_type">tp_cli_channel_run_get_channel_type</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_run_get_channel_type (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="gchar">gchar</link> **out_Channel_Type,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<warning><para><literal>tp_cli_channel_run_get_channel_type</literal> is deprecated and should not be used in newly-written code. Use the ChannelType         property if possible.</para></warning>
<para>
Call the method GetChannelType and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Returns the interface name for the type of this channel.  Clients         SHOULD use the &lt;tp:member-ref&gt;ChannelType&lt;/tp:member-ref&gt; property         instead, falling back to this method only if necessary.          &lt;tp:rationale&gt;           The GetAll method lets clients retrieve all properties in one           round-trip.         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Channel_Type</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: The interface name
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-run-get-handle" role="function" condition="deprecated:Use the TargetHandleType         and TargetHandle properties if possible.">
<title>tp_cli_channel_run_get_handle ()</title>
<indexterm zone="tp-cli-channel-run-get-handle" role="deprecated"><primary sortas="tp_cli_channel_run_get_handle">tp_cli_channel_run_get_handle</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_run_get_handle       (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="guint">guint</link> *out_Target_Handle_Type,
                                                         <link linkend="guint">guint</link> *out_Target_Handle,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<warning><para><literal>tp_cli_channel_run_get_handle</literal> is deprecated and should not be used in newly-written code. Use the TargetHandleType         and TargetHandle properties if possible.</para></warning>
<para>
Call the method GetHandle and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Returns the handle type and number if this channel represents a         communication with a particular contact, room or server-stored list, or         zero if it is transient and defined only by its contents. Clients         SHOULD use the &lt;tp:member-ref&gt;TargetHandle&lt;/tp:member-ref&gt; and         &lt;tp:member-ref&gt;TargetHandleType&lt;/tp:member-ref&gt; properties instead,         falling back to this method only if necessary.          &lt;tp:rationale&gt;           The GetAll method lets clients retrieve all properties in one           round-trip.         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Target_Handle_Type</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: The same as TargetHandleType.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Target_Handle</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: The same as TargetHandle.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-run-get-interfaces" role="function" condition="deprecated:Use the Interfaces         property if possible.">
<title>tp_cli_channel_run_get_interfaces ()</title>
<indexterm zone="tp-cli-channel-run-get-interfaces" role="deprecated"><primary sortas="tp_cli_channel_run_get_interfaces">tp_cli_channel_run_get_interfaces</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_run_get_interfaces   (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="gchar">gchar</link> ***out_Interfaces,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<warning><para><literal>tp_cli_channel_run_get_interfaces</literal> is deprecated and should not be used in newly-written code. Use the Interfaces         property if possible.</para></warning>
<para>
Call the method GetInterfaces and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
Get the optional interfaces implemented by the channel.         Clients SHOULD use the &lt;tp:member-ref&gt;Interfaces&lt;/tp:member-ref&gt;         property instead, falling back to this method only if necessary.          &lt;tp:rationale&gt;           The GetAll method lets clients retrieve all properties in one           round-trip.         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>out_Interfaces</parameter>&#160;:</term>
<listitem><simpara> Used to return an 'out' argument if <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> is returned: An array of the D-Bus interface names
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-connect-to-closed" role="function">
<title>tp_cli_channel_connect_to_closed ()</title>
<indexterm zone="tp-cli-channel-connect-to-closed"><primary sortas="tp_cli_channel_connect_to_closed">tp_cli_channel_connect_to_closed</primary></indexterm><programlisting><link linkend="TpProxySignalConnection">TpProxySignalConnection</link> * tp_cli_channel_connect_to_closed
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="tp-cli-channel-signal-callback-closed">tp_cli_channel_signal_callback_closed</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Connect a handler to the signal Closed.
</para>
<para>
Emitted when the channel has been closed. Method calls on the         channel are no longer valid after this signal has been emitted,         and the connection manager may then remove the object from the bus         at any point.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> Callback to be called when the signal is
  received
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data for the callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> Destructor for the user-supplied data, which
  will be called when this signal is disconnected, or
  before this function returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="GObject"><type>GObject</type></link> which will be weakly referenced; 
  if it is destroyed, this callback will automatically be
  disconnected
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to raise an error if <link linkend="NULL--CAPS"><literal>NULL</literal></link> is
  returned
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxySignalConnection"><type>TpProxySignalConnection</type></link> containing all of the
above, which can be used to disconnect the signal; or
<link linkend="NULL--CAPS"><literal>NULL</literal></link> if the proxy does not have the desired interface
or has become invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-signal-callback-closed" role="function">
<title>tp_cli_channel_signal_callback_closed ()</title>
<indexterm zone="tp-cli-channel-signal-callback-closed"><primary sortas="tp_cli_channel_signal_callback_closed">tp_cli_channel_signal_callback_closed</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_signal_callback_closed)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Represents the signature of a callback for the signal Closed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> The proxy on which <link linkend="tp-cli-channel-connect-to-closed"><function>tp_cli_channel_connect_to_closed()</function></link>
 was called
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> User-supplied weakly referenced object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-destroyable-call-destroy" role="function">
<title>tp_cli_channel_interface_destroyable_call_destroy ()</title>
<indexterm zone="tp-cli-channel-interface-destroyable-call-destroy"><primary sortas="tp_cli_channel_interface_destroyable_call_destroy">tp_cli_channel_interface_destroyable_call_destroy</primary></indexterm><programlisting><link linkend="TpProxyPendingCall">TpProxyPendingCall</link> * tp_cli_channel_interface_destroyable_call_destroy
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="tp-cli-channel-interface-destroyable-callback-for-destroy">tp_cli_channel_interface_destroyable_callback_for_destroy</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Start a Destroy method call.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Close the channel abruptly, possibly with loss of data. The           connection manager MUST NOT re-create the channel unless/until           more events occur.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;The main motivating situation for this method is that when a Text             channel with pending messages is closed with Close, it comes back             as an incoming channel (to avoid a race between Close and an             incoming message). If Destroy is called on a Text channel, the CM             should delete all pending messages and close the channel, and             the channel shouldn&apos;t be re-created until/unless another message             arrives.&lt;/p&gt;         &lt;/tp:rationale&gt;          &lt;p&gt;Most clients SHOULD call           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy&quot;&gt;Channel.Close&lt;/tp:dbus-ref&gt;           instead. However, if a client explicitly intends to destroy the           channel with possible loss of data, it SHOULD call this method           if this interface is supported (according to the           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy&quot;&gt;Channel.Interfaces&lt;/tp:dbus-ref&gt;           property), falling back to Close if not.&lt;/p&gt;          &lt;p&gt;In particular, channel dispatchers SHOULD use this method if           available when terminating channels that cannot be handled           correctly (for instance, if no handler has been installed for           a channel type, or if the handler crashes repeatedly).&lt;/p&gt;          &lt;p&gt;Connection managers do not need to implement this interface on           channels where Close and Destroy would be equivalent.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;Callers need to be able to fall back to Close in any case.&lt;/p&gt;         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpProxy"><type>TpProxy</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> the timeout in milliseconds, or -1 to use the
  default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> called when the method call succeeds or fails;
  may be <link linkend="NULL--CAPS"><literal>NULL</literal></link> to make a "fire and forget" call with no 
  reply tracking
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data passed to the callback;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy</parameter>&#160;:</term>
<listitem><simpara> called with the user_data as argument, after the
  call has succeeded, failed or been cancelled;
  must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, a <link linkend="GObject"><type>GObject</type></link> which will be 
  weakly referenced; if it is destroyed, this call 
  will automatically be cancelled. Must be <link linkend="NULL--CAPS"><literal>NULL</literal></link> if 
  <parameter>callback</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> a <link linkend="TpProxyPendingCall"><type>TpProxyPendingCall</type></link> representing the call in
 progress. It is borrowed from the object, and will become
 invalid when the callback is called, the call is
 cancelled or the <link linkend="TpProxy"><type>TpProxy</type></link> becomes invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-destroyable-callback-for-destroy" role="function">
<title>tp_cli_channel_interface_destroyable_callback_for_destroy ()</title>
<indexterm zone="tp-cli-channel-interface-destroyable-callback-for-destroy"><primary sortas="tp_cli_channel_interface_destroyable_callback_for_destroy">tp_cli_channel_interface_destroyable_callback_for_destroy</primary></indexterm><programlisting><link linkend="void">void</link>                (*tp_cli_channel_interface_destroyable_callback_for_destroy)
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         const <link linkend="GError">GError</link> *error,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GObject">GObject</link> *weak_object);</programlisting>
<para>
Signature of the callback called when a Destroy method call
succeeds or fails.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> the proxy on which the call was made
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> <link linkend="NULL--CAPS"><literal>NULL</literal></link> on success, or an error on failure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> user-supplied data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>weak_object</parameter>&#160;:</term>
<listitem><simpara> user-supplied object
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="tp-cli-channel-interface-destroyable-run-destroy" role="function">
<title>tp_cli_channel_interface_destroyable_run_destroy ()</title>
<indexterm zone="tp-cli-channel-interface-destroyable-run-destroy"><primary sortas="tp_cli_channel_interface_destroyable_run_destroy">tp_cli_channel_interface_destroyable_run_destroy</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            tp_cli_channel_interface_destroyable_run_destroy
                                                        (<link linkend="TpChannel">TpChannel</link> *proxy,
                                                         <link linkend="gint">gint</link> timeout_ms,
                                                         <link linkend="GError">GError</link> **error,
                                                         <link linkend="GMainLoop">GMainLoop</link> **loop);</programlisting>
<para>
Call the method Destroy and run the main loop
until it returns. Before calling this method, you must
add a reference to any borrowed objects you need to keep,
and generally ensure that everything is in a consistent
state.
</para>
<para>
&lt;tp:docstring xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;         &lt;p&gt;Close the channel abruptly, possibly with loss of data. The           connection manager MUST NOT re-create the channel unless/until           more events occur.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;The main motivating situation for this method is that when a Text             channel with pending messages is closed with Close, it comes back             as an incoming channel (to avoid a race between Close and an             incoming message). If Destroy is called on a Text channel, the CM             should delete all pending messages and close the channel, and             the channel shouldn&apos;t be re-created until/unless another message             arrives.&lt;/p&gt;         &lt;/tp:rationale&gt;          &lt;p&gt;Most clients SHOULD call           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy&quot;&gt;Channel.Close&lt;/tp:dbus-ref&gt;           instead. However, if a client explicitly intends to destroy the           channel with possible loss of data, it SHOULD call this method           if this interface is supported (according to the           &lt;tp:dbus-ref namespace=&quot;org.freedesktop.Telepathy&quot;&gt;Channel.Interfaces&lt;/tp:dbus-ref&gt;           property), falling back to Close if not.&lt;/p&gt;          &lt;p&gt;In particular, channel dispatchers SHOULD use this method if           available when terminating channels that cannot be handled           correctly (for instance, if no handler has been installed for           a channel type, or if the handler crashes repeatedly).&lt;/p&gt;          &lt;p&gt;Connection managers do not need to implement this interface on           channels where Close and Destroy would be equivalent.&lt;/p&gt;          &lt;tp:rationale&gt;           &lt;p&gt;Callers need to be able to fall back to Close in any case.&lt;/p&gt;         &lt;/tp:rationale&gt;</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> A <link linkend="TpChannel"><type>TpChannel</type></link> or subclass
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout_ms</parameter>&#160;:</term>
<listitem><simpara> Timeout in milliseconds, or -1 for default
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, used to return errors if <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> 
 is returned
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>loop</parameter>&#160;:</term>
<listitem><simpara> If not <link linkend="NULL--CAPS"><literal>NULL</literal></link>, set before re-entering 
 the main loop, to point to a <link linkend="GMainLoop"><type>GMainLoop</type></link> 
 which can be used to cancel this call with 
 <link linkend="g-main-loop-quit"><function>g_main_loop_quit()</function></link>, causing a return of 
 <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> with <parameter>error</parameter> set to <link linkend="TP-DBUS-ERROR-CANCELLED--CAPS"><literal>TP_DBUS_ERROR_CANCELLED</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> TRUE on success, FALSE and sets <parameter>error</parameter> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>
<refsect1 id="telepathy-glib-channel.property-details" role="property_details">
<title role="property_details.title">Property Details</title>
<refsect2 id="TpChannel--channel-properties" role="property"><title>The <literal>&quot;channel-properties&quot;</literal> property</title>
<indexterm zone="TpChannel--channel-properties"><primary sortas="TpChannel:channel-properties">TpChannel:channel-properties</primary></indexterm><programlisting>  &quot;channel-properties&quot;       <link linkend="GHashTable-gchararray+GValue-*">GHashTable_gchararray+GValue_*</link>  : Read / Write / Construct Only</programlisting>
<para>
The immutable D-Bus properties of this channel, represented by a
<link linkend="GHashTable"><type>GHashTable</type></link> where the keys are D-Bus interface name + "." + property
name, and the values are <link linkend="GValue"><type>GValue</type></link> instances.
</para>
<para>
Read-only except during construction. If this is not provided
during construction, a reasonable (but possibly incomplete) version
will be made up from the values of individual properties; reading this
property repeatedly may yield progressively more complete values until
<link linkend="TpChannel--channel-ready"><type>"channel-ready"</type></link> becomes <link linkend="TRUE--CAPS"><literal>TRUE</literal></link>.</para>
<para>
</para></refsect2>
<refsect2 id="TpChannel--channel-ready" role="property"><title>The <literal>&quot;channel-ready&quot;</literal> property</title>
<indexterm zone="TpChannel--channel-ready"><primary sortas="TpChannel:channel-ready">TpChannel:channel-ready</primary></indexterm><programlisting>  &quot;channel-ready&quot;            <link linkend="gboolean">gboolean</link>              : Read</programlisting>
<para>
Initially <link linkend="FALSE--CAPS"><literal>FALSE</literal></link>; changes to <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> when introspection of the channel
has finished and it's ready for use.
</para>
<para>
By the time this property becomes <link linkend="TRUE--CAPS"><literal>TRUE</literal></link>, the following will be true:
</para>
<para>
- <link linkend="TpChannel--channel-type"><type>"channel-type"</type></link> set, unless introspection failed
- <link linkend="TpChannel--handle-type"><type>"handle-type"</type></link> and <link linkend="TpChannel--handle"><type>"handle"</type></link> set, unless introspection
  failed
- any extra interfaces will have been set up in TpProxy (i.e.
  <link linkend="TpProxy--interfaces"><type>"interfaces"</type></link> contains at least all extra Channel interfaces)
</para>
<para>
In addition, if <link linkend="TpProxy--interfaces"><type>"interfaces"</type></link> includes the Group interface:
</para>
<para>
- the initial value of the <link linkend="TpChannel--group-self-handle"><type>"group-self-handle"</type></link> property will
  have been fetched and change notification will have been set up
- the initial value of the <link linkend="TpChannel--group-flags"><type>"group-flags"</type></link> property will
  have been fetched and change notification will have been set up
</para>
<para>
Change notification is via notify::channel-ready.</para>
<para>
</para><para>Default value: FALSE</para>
</refsect2>
<refsect2 id="TpChannel--connection" role="property"><title>The <literal>&quot;connection&quot;</literal> property</title>
<indexterm zone="TpChannel--connection"><primary sortas="TpChannel:connection">TpChannel:connection</primary></indexterm><programlisting>  &quot;connection&quot;               <link linkend="TpConnection">TpConnection</link>*         : Read / Write / Construct Only</programlisting>
<para>
The <link linkend="TpConnection"><type>TpConnection</type></link> to which this <link linkend="TpChannel"><type>TpChannel</type></link> belongs. Used for e.g.
handle manipulation.</para>
<para>
</para></refsect2>
<refsect2 id="TpChannel--group-flags" role="property"><title>The <literal>&quot;group-flags&quot;</literal> property</title>
<indexterm zone="TpChannel--group-flags" role="0.7.12"><primary sortas="TpChannel:group-flags">TpChannel:group-flags</primary></indexterm><programlisting>  &quot;group-flags&quot;              <link linkend="guint">guint</link>                 : Read</programlisting>
<para>
If this channel is ready (<link linkend="TpChannel--channel-ready"><type>"channel-ready"</type></link>) and is a group,
<link linkend="TpChannelGroupFlags"><type>TpChannelGroupFlags</type></link> indicating the capabilities and behaviour of that
group.
</para>
<para>
Otherwise, 0.
</para>
<para>
Change notification is via notify::group-flags or
TpChannel::group-flags-changed.</para>
<para>
</para><para>Default value: 0</para>
<para>Since 0.7.12</para>
</refsect2>
<refsect2 id="TpChannel--group-self-handle" role="property"><title>The <literal>&quot;group-self-handle&quot;</literal> property</title>
<indexterm zone="TpChannel--group-self-handle" role="0.7.12"><primary sortas="TpChannel:group-self-handle">TpChannel:group-self-handle</primary></indexterm><programlisting>  &quot;group-self-handle&quot;        <link linkend="guint">guint</link>                 : Read</programlisting>
<para>
If this channel is ready (<link linkend="TpChannel--channel-ready"><type>"channel-ready"</type></link>) and is a group, and
the user is a member of it, the <link linkend="TpHandle"><type>TpHandle</type></link> representing them in this group.
</para>
<para>
Otherwise, either a handle representing the user, or 0.
</para>
<para>
Change notification is via notify::group-self-handle.</para>
<para>
</para><para>Default value: 0</para>
<para>Since 0.7.12</para>
</refsect2>
<refsect2 id="TpChannel--identifier" role="property"><title>The <literal>&quot;identifier&quot;</literal> property</title>
<indexterm zone="TpChannel--identifier"><primary sortas="TpChannel:identifier">TpChannel:identifier</primary></indexterm><programlisting>  &quot;identifier&quot;               <link linkend="gchar">gchar</link>*                : Read</programlisting>
<para>
This channel's associated identifier, or NULL if no identifier or unknown.
</para>
<para>
The identifier is the result of inspecting <link linkend="TpChannel--handle"><type>"handle"</type></link>.</para>
<para>
</para><para>Default value: NULL</para>
</refsect2>
</refsect1>

<refsect1 id="telepathy-glib-channel.signal-details" role="signals">
<title role="signals.title">Signal Details</title>
<refsect2 id="TpChannel-group-flags-changed" role="signal"><title>The <literal>&quot;group-flags-changed&quot;</literal> signal</title>
<indexterm zone="TpChannel-group-flags-changed" role="0.7.12"><primary sortas="TpChannel::group-flags-changed">TpChannel::group-flags-changed</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="TpChannel">TpChannel</link> *self,
                                                        <link linkend="guint">guint</link>      added,
                                                        <link linkend="guint">guint</link>      removed,
                                                        <link linkend="gpointer">gpointer</link>   user_data)      : Run Last / Has Details</programlisting>
<para>
Emitted when the <link linkend="TpChannel--group-flags"><type>"group-flags"</type></link> property changes while the
channel is ready.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>added</parameter>&#160;:</term>
<listitem><simpara> <link linkend="TpChannelGroupFlags"><type>TpChannelGroupFlags</type></link> which are newly set
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>removed</parameter>&#160;:</term>
<listitem><simpara> <link linkend="TpChannelGroupFlags"><type>TpChannelGroupFlags</type></link> which are no longer set
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist><para>Since 0.7.12</para></refsect2><refsect2 id="TpChannel-group-members-changed" role="signal"><title>The <literal>&quot;group-members-changed&quot;</literal> signal</title>
<indexterm zone="TpChannel-group-members-changed" role="0.7.12"><primary sortas="TpChannel::group-members-changed">TpChannel::group-members-changed</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="TpChannel">TpChannel</link>     *self,
                                                        <link linkend="gchar">gchar</link>         *message,
                                                        <link linkend="GArray-guint-">GArray_guint_</link> *added,
                                                        <link linkend="GArray-guint-">GArray_guint_</link> *removed,
                                                        <link linkend="GArray-guint-">GArray_guint_</link> *local_pending,
                                                        <link linkend="GArray-guint-">GArray_guint_</link> *remote_pending,
                                                        <link linkend="guint">guint</link>          actor,
                                                        <link linkend="guint">guint</link>          reason,
                                                        <link linkend="gpointer">gpointer</link>       user_data)           : Run Last / Has Details</programlisting>
<para>
Emitted when the group members change in a Group channel that is ready.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message</parameter>&#160;:</term>
<listitem><simpara> an optional textual message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>added</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="GArray"><type>GArray</type></link> of <link linkend="guint"><type>guint</type></link> containing the full members added
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>removed</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="GArray"><type>GArray</type></link> of <link linkend="guint"><type>guint</type></link> containing the members (full,
 local-pending or remote-pending) removed
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>local_pending</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="GArray"><type>GArray</type></link> of <link linkend="guint"><type>guint</type></link> containing the local-pending
 members added
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>remote_pending</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="GArray"><type>GArray</type></link> of <link linkend="guint"><type>guint</type></link> containing the remote-pending
 members added
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>actor</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="TpHandle"><type>TpHandle</type></link> of the contact causing the change, or 0
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>reason</parameter>&#160;:</term>
<listitem><simpara> the reason for the change as a <link linkend="TpChannelGroupChangeReason"><type>TpChannelGroupChangeReason</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist><para>Since 0.7.12</para></refsect2><refsect2 id="TpChannel-group-members-changed-detailed" role="signal"><title>The <literal>&quot;group-members-changed-detailed&quot;</literal> signal</title>
<indexterm zone="TpChannel-group-members-changed-detailed" role="0.7.21"><primary sortas="TpChannel::group-members-changed-detailed">TpChannel::group-members-changed-detailed</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="TpChannel">TpChannel</link>     *self,
                                                        <link linkend="GArray-guint-">GArray_guint_</link> *added,
                                                        <link linkend="GArray-guint-">GArray_guint_</link> *removed,
                                                        <link linkend="GArray-guint-">GArray_guint_</link> *local_pending,
                                                        <link linkend="GArray-guint-">GArray_guint_</link> *remote_pending,
                                                        <link linkend="gpointer">gpointer</link>       user_data)           : Run Last / Has Details</programlisting>
<para>
Emitted when the group members change in a Group channel that is ready.
Contains a superset of the information in the
TpChannel::group-members-changed signal, and is emitted at the same time;
applications can connect to this signal and ignore the other.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>self</parameter>&#160;:</term>
<listitem><simpara> a channel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>added</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="GArray"><type>GArray</type></link> of <link linkend="guint"><type>guint</type></link> containing the full members added
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>removed</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="GArray"><type>GArray</type></link> of <link linkend="guint"><type>guint</type></link> containing the members (full,
 local-pending or remote-pending) removed
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>local_pending</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="GArray"><type>GArray</type></link> of <link linkend="guint"><type>guint</type></link> containing the local-pending
 members added
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>remote_pending</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="GArray"><type>GArray</type></link> of <link linkend="guint"><type>guint</type></link> containing the remote-pending
 members added
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>details</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="GHashTable"><type>GHashTable</type></link> mapping (gchar *) to <link linkend="GValue"><type>GValue</type></link> containing details
 about the change, as described in the specification of the
 MembersChangedDetailed signal.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist><para>Since 0.7.21</para></refsect2>
</refsect1>


<refsect1 id="telepathy-glib-channel.see-also">
<title>See Also</title>
#TpConnection, channel-group, channel-text, channel-media
</refsect1>

</refentry>
