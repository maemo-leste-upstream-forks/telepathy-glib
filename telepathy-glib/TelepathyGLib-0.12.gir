<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="telepathy-glib"/>
  <c:include name="telepathy-glib/telepathy-glib.h"/>
  <namespace name="TelepathyGLib"
             version="0.12"
             shared-library="libtelepathy-glib.so.0"
             c:identifier-prefixes="Tp"
             c:symbol-prefixes="tp">
    <alias name="Handle" c:type="TpHandle">
      <doc xml:whitespace="preserve">Type representing Telepathy handles within telepathy-glib.

This is guint despite the wire protocol having 32-bit integers, because
dbus-glib expects GArrays of guint and so on. If the dbus-glib ABI changes
in future, telepathy-glib is likely to have a matching ABI change.</doc>
      <type name="guint" c:type="guint"/>
    </alias>
    <alias name="IntSet" c:type="TpIntSet" introspectable="0">
      <doc xml:whitespace="preserve">Before 0.11.16, this was the name for &lt;type&gt;TpIntset&lt;/type&gt;, but it's
now just a backwards compatibility typedef.</doc>
      <type name="Intset" c:type="TpIntset"/>
    </alias>
    <alias name="IntSetFastIter"
           c:type="TpIntSetFastIter"
           introspectable="0"
           deprecated="since 0.19.0. Use #TpIntsetFastIter instead">
      <doc xml:whitespace="preserve">Before 0.11.16, this was the name for &lt;type&gt;TpIntsetFastIter&lt;/type&gt;,
but it's now just a backwards compatibility typedef.</doc>
      <type name="IntsetFastIter" c:type="TpIntsetFastIter"/>
    </alias>
    <alias name="IntSetIter"
           c:type="TpIntSetIter"
           introspectable="0"
           deprecated="since 0.19.0. Use #TpIntsetFastIter instead">
      <doc xml:whitespace="preserve">Before 0.11.16, this was the name for &lt;type&gt;TpIntsetIter&lt;/type&gt;, but
it's now just a backwards compatibility typedef.</doc>
      <type name="IntsetIter" c:type="TpIntsetIter"/>
    </alias>
    <constant name="ACCOUNT_MANAGER_BUS_NAME"
              value="org.freedesktop.Telepathy.AccountManager"
              c:type="TP_ACCOUNT_MANAGER_BUS_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCOUNT_MANAGER_OBJECT_PATH"
              value="/org/freedesktop/Telepathy/AccountManager"
              c:type="TP_ACCOUNT_MANAGER_OBJECT_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCOUNT_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/Account/"
              c:type="TP_ACCOUNT_OBJECT_PATH_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="AccessControlType" c:type="TpAccessControlType">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A type for communication access control. These control           policies are used in           CommunicationPolicy.DRAFT           as well as most rich presence interfaces.          New interfaces should use this type, and NOT           Rich_Presence_Access_Control_Type.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="whitelist"
              value="0"
              c:identifier="TP_ACCESS_CONTROL_TYPE_WHITELIST"/>
      <member name="publish_list"
              value="1"
              c:identifier="TP_ACCESS_CONTROL_TYPE_PUBLISH_LIST"/>
      <member name="group"
              value="2"
              c:identifier="TP_ACCESS_CONTROL_TYPE_GROUP"/>
      <member name="open"
              value="3"
              c:identifier="TP_ACCESS_CONTROL_TYPE_OPEN"/>
      <member name="subscribe_or_publish_list"
              value="4"
              c:identifier="TP_ACCESS_CONTROL_TYPE_SUBSCRIBE_OR_PUBLISH_LIST"/>
      <member name="closed"
              value="5"
              c:identifier="TP_ACCESS_CONTROL_TYPE_CLOSED"/>
      <member name="not_understood"
              value="6"
              c:identifier="TP_ACCESS_CONTROL_TYPE_NOT_UNDERSTOOD"/>
    </enumeration>
    <class name="Account"
           c:symbol-prefix="account"
           c:type="TpAccount"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpAccount"
           glib:get-type="tp_account_get_type"
           glib:type-struct="AccountClass">
      <doc xml:whitespace="preserve">The Telepathy Account Manager stores the user's configured real-time
communication accounts. This object represents a stored account.

If this account is deleted from the account manager, the
#TpProxy::invalidated signal will be emitted
with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.

One can connect to the #GObject::notify signal to get change notifications
for many of the properties on this object. Refer to each property's
documentation for whether it can be used in this way.</doc>
      <constructor name="new"
                   c:identifier="tp_account_new"
                   deprecated="Use tp_simple_client_factory_ensure_account() instead."
                   throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new account proxy. The returned #TpAccount
is not guaranteed to be ready at the point of return.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account proxy, or %NULL if @object_path is not valid</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The non-NULL object path of this account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_addressing"
                c:identifier="tp_account_get_feature_quark_addressing">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_connection"
                c:identifier="tp_account_get_feature_quark_connection"
                version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for representing the connection feature of a #TpAccount</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_account_get_feature_quark_core"
                version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for representing the core feature of a #TpAccount</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_storage"
                c:identifier="tp_account_get_feature_quark_storage"
                version="0.13.2">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for representing the storage interface of a #TpAccount</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_account_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpAccount have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_ACCOUNT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="parse_object_path"
                c:identifier="tp_account_parse_object_path"
                version="0.9.0"
                deprecated="Use tp_account_get_protocol() and tp_account_get_connection_manager() instead."
                throws="1">
        <doc xml:whitespace="preserve">Validates and parses a Telepathy Account's object path, extracting the
connection manager's name, the protocol, and the account's unique identifier
from the path. This includes replacing underscores with hyphens in the
protocol name, as defined in the Account specification.

Any of the out parameters may be %NULL if not needed. If %TRUE is returned,
the caller is responsible for freeing the strings stored in any non-%NULL
out parameters, using g_free().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @object_path was successfully parsed; %FALSE and sets @error otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">a Telepathy Account's object path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cm"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location at which to store the account's connection manager's name</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="protocol"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location at which to store the account's protocol</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="account_id"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location at which to store the account's unique identifier</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </function>
      <method name="associated_with_uri_scheme"
              c:identifier="tp_account_associated_with_uri_scheme"
              version="0.13.8">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the result of tp_account_get_uri_schemes() would include @scheme</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">a URI scheme such as "tel", "sip" or "xmpp"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_connection_status_to_property"
              c:identifier="tp_account_bind_connection_status_to_property"
              version="0.13.16">
        <doc xml:whitespace="preserve">Binds the :connection-status of @self to the boolean property of another
object using a #GBinding such that the @target_property will be set to
%TRUE when @self is connected (and @invert is %FALSE).

@target_property will be synchronised immediately (%G_BINDING_SYNC_CREATE).
@invert can be interpreted as analogous to %G_BINDING_INVERT_BOOLEAN.

For instance, this function can be used to bind the GtkWidget:sensitive
property to only make a widget sensitive when the account is connected.

See g_object_bind_property() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GBinding instance representing the binding between the @self and the @target. The binding is released whenever the #GBinding reference count reaches zero.</doc>
          <type name="GObject.Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @target to bind (must be %G_TYPE_BOOLEAN)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="invert" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if you wish to invert the value of @target_property (i.e. %FALSE if connected)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_detailed_error_vardict"
              c:identifier="tp_account_dup_detailed_error_vardict"
              version="0.17.6">
        <doc xml:whitespace="preserve">If the account's connection is not connected, return the D-Bus error name
with which it last disconnected or failed to connect (in particular, this
is %TP_ERROR_STR_CANCELLED if it was disconnected by a user request).
This is the same as #TpAccount:connection-error.

If @details is not %NULL, it will be used to return additional details about
the error (the same as #TpAccount:connection-error-details).

Otherwise, return %NULL, without altering @details.

The returned string and @details may become invalid when the main loop is
re-entered or the account is destroyed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">optionally used to return a variant of type %G_VARIANT_TYPE_VARDICT, which must be unreffed by the caller with g_variant_unref()</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_parameters_vardict"
              c:identifier="tp_account_dup_parameters_vardict"
              version="0.17.6">
        <doc xml:whitespace="preserve">Returns the parameters of the account, in a variant of type
%G_VARIANT_TYPE_VARDICT where the keys
are parameter names (account, password, require-encryption etc.).
Use g_variant_lookup() or g_variant_lookup_value() for convenient
access to the values.

The allowed parameters depend on the connection manager, and can be found
via tp_connection_manager_get_protocol() and
tp_connection_manager_protocol_get_param(). Well-known parameters are
listed
&lt;ulink url="http://telepathy.freedesktop.org/spec/org.freedesktop.Telepathy.ConnectionManager.html#org.freedesktop.Telepathy.ConnectionManager.RequestConnection"&gt;in
the Telepathy D-Bus Interface Specification&lt;/ulink&gt;.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the dictionary of parameters on @account, of type %G_VARIANT_TYPE_VARDICT</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="dup_storage_identifier_variant"
              c:identifier="tp_account_dup_storage_identifier_variant"
              version="0.13.2">
        <doc xml:whitespace="preserve">Return provider-specific information used to identify this
account. Use g_variant_get_type() to check that the type
is what you expect; for instance, if the
#TpAccount:storage-provider has string-based user identifiers,
this variant should have type %G_VARIANT_TYPE_STRING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the same as the #TpAccount:storage-identifier-variant property</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="dup_storage_specific_information_vardict_async"
              c:identifier="tp_account_dup_storage_specific_information_vardict_async"
              version="0.17.6">
        <doc xml:whitespace="preserve">Makes an asynchronous request of @self's StorageSpecificInformation
property (part of the Account.Interface.Storage interface).

When the operation is finished, @callback will be called. You must then
call tp_account_dup_storage_specific_information_vardict_finish() to get the
result of the request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_storage_specific_information_vardict_finish"
              c:identifier="tp_account_dup_storage_specific_information_vardict_finish"
              version="0.17.6"
              throws="1">
        <doc xml:whitespace="preserve">Retrieve the value of the request begun with
tp_account_dup_storage_specific_information_vardict_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a map from strings to variants, of type %G_VARIANT_TYPE_VARDICT</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_connection"
              c:identifier="tp_account_ensure_connection"
              version="0.9.0"
              deprecated="New code should use tp_simple_client_factory_ensure_connection() instead.">
        <doc xml:whitespace="preserve">Set the connection of the account by specifying the connection object path.
This function does not return a new ref and it is not guaranteed that the
returned #TpConnection object is ready.

The use-case for this function is in a HandleChannels callback and you
already know the object path for the connection, so you can let @account
create its #TpConnection and return it for use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection of the account, or %NULL if either the object path @path is invalid or it is the null-value "/"</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path to connection object for #TpAccount</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_automatic_presence"
              c:identifier="tp_account_get_automatic_presence"
              version="0.13.8">
        <doc xml:whitespace="preserve">Gets the automatic presence, status and status message of @account. These
values are the same as the #TpAccount:automatic-presence-type,
#TpAccount:automatic-status and #TpAccount:automatic-status-message
properties, and are the values that will be used if the account should
be put online automatically.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:automatic-presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">return location for the presence status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the user-defined message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_async"
              c:identifier="tp_account_get_avatar_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous get of @account's avatar. When
the operation is finished, @callback will be called. You can then call
tp_account_get_avatar_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_finish"
              c:identifier="tp_account_get_avatar_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async get operation of @account's avatar.

Beware that the returned value is only valid until @result is freed.
Copy it with g_array_ref() if you need to keep it for longer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GArray of #guchar containing the bytes of the account's avatar, or %NULL on failure</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_changing_presence"
              c:identifier="tp_account_get_changing_presence"
              version="0.11.6">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:changing-presence property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_cm_name"
              c:identifier="tp_account_get_cm_name"
              version="0.19.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:cm-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_connect_automatically"
              c:identifier="tp_account_get_connect_automatically"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connect-automatically property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_connection"
              c:identifier="tp_account_get_connection"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connection property</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="get_connection_manager"
              c:identifier="tp_account_get_connection_manager"
              version="0.9.0"
              deprecated="Use tp_account_get_cm_name() instead.">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connection-manager property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_connection_status"
              c:identifier="tp_account_get_connection_status"
              version="0.9.0">
        <doc xml:whitespace="preserve">Gets the connection status and reason from @account. The two values
are the same as the #TpAccount:connection-status and
#TpAccount:connection-status-reason properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connection-status property</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #TpConnectionStatusReason to fill, or %NULL</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_current_presence"
              c:identifier="tp_account_get_current_presence"
              version="0.9.0">
        <doc xml:whitespace="preserve">Gets the current presence, status and status message of @account. These
values are the same as the #TpAccount:current-presence-type,
#TpAccount:current-status and #TpAccount:current-status-message properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:current-presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the current status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the current status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_detailed_error"
              c:identifier="tp_account_get_detailed_error"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">If the account's connection is not connected, return the D-Bus error name
with which it last disconnected or failed to connect (in particular, this
is %TP_ERROR_STR_CANCELLED if it was disconnected by a user request).
This is the same as #TpAccount:connection-error.

If @details is not %NULL, it will be used to return additional details about
the error (the same as #TpAccount:connection-error-details).

Otherwise, return %NULL, without altering @details.

The returned string and @details may become invalid when the main loop is
re-entered or the account is destroyed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optionally used to return a map from string to #GValue, which must not be modified, destroyed or unreffed by the caller</doc>
            <type name="GLib.HashTable" c:type="const GHashTable**">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_display_name"
              c:identifier="tp_account_get_display_name"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:display-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_has_been_online"
              c:identifier="tp_account_get_has_been_online"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:has-been-online property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_icon_name"
              c:identifier="tp_account_get_icon_name"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:icon-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_nickname"
              c:identifier="tp_account_get_nickname"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:nickname property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_normalized_name"
              c:identifier="tp_account_get_normalized_name"
              version="0.13.8">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:normalized-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_parameters"
              c:identifier="tp_account_get_parameters"
              version="0.9.0">
        <doc xml:whitespace="preserve">Returns the parameters of the account, in a hash table where each string
is the parameter name (account, password, require-encryption etc.), and
each value is a #GValue. Using the tp_asv_get family of functions
(tp_asv_get_uint32(), tp_asv_get_string() etc.) to access the parameters is
recommended.

The allowed parameters depend on the connection manager, and can be found
via tp_connection_manager_get_protocol() and
tp_connection_manager_protocol_get_param(). Well-known parameters are
listed
&lt;ulink url="http://telepathy.freedesktop.org/spec/org.freedesktop.Telepathy.ConnectionManager.html#org.freedesktop.Telepathy.ConnectionManager.RequestConnection"&gt;in
the Telepathy D-Bus Interface Specification&lt;/ulink&gt;.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hash table of parameters on @account</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_path_suffix"
              c:identifier="tp_account_get_path_suffix"
              version="0.13.9">
        <doc xml:whitespace="preserve">Returns the portion of @account's object path after the standard
#TP_ACCOUNT_OBJECT_PATH_BASE prefix, of the form "cm/protocol/acct". This
string uniquely identifies the account.

This function is only intended to be used when printing debug messages or in
tools for developer. For a string suitable for displaying to the user, see
tp_account_get_display_name(). To retrieve the connection manager and
protocol name parts of the object path, see
tp_account_get_connection_manager() and tp_account_get_protocol(). For
persistent identification of the account, use tp_proxy_get_object_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a suffix of @account's object path, for debugging purposes.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_protocol"
              c:identifier="tp_account_get_protocol"
              version="0.9.0"
              deprecated="Use tp_account_get_cm_name() instead.">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:protocol property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_protocol_name"
              c:identifier="tp_account_get_protocol_name"
              version="0.19.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:protocol-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_requested_presence"
              c:identifier="tp_account_get_requested_presence"
              version="0.9.0">
        <doc xml:whitespace="preserve">Gets the requested presence, status and status message of @account. These
values are the same as the #TpAccount:requested-presence-type,
#TpAccount:requested-status and #TpAccount:requested-status-message
properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:requested-presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">return location for the requested status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the requested status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_service"
              c:identifier="tp_account_get_service"
              version="0.11.9">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:service property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_storage_identifier"
              c:identifier="tp_account_get_storage_identifier"
              version="0.13.2">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:storage-identifier property</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
      </method>
      <method name="get_storage_provider"
              c:identifier="tp_account_get_storage_provider"
              version="0.13.2">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:storage-provider property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_storage_restrictions"
              c:identifier="tp_account_get_storage_restrictions"
              version="0.13.2">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:storage-restrictions property</doc>
          <type name="StorageRestrictionFlags"
                c:type="TpStorageRestrictionFlags"/>
        </return-value>
      </method>
      <method name="get_storage_specific_information_async"
              c:identifier="tp_account_get_storage_specific_information_async"
              version="0.13.2">
        <doc xml:whitespace="preserve">Makes an asynchronous request of @self's StorageSpecificInformation
property (part of the Account.Interface.Storage interface).

When the operation is finished, @callback will be called. You must then
call tp_account_get_storage_specific_information_finish() to get the
result of the request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_storage_specific_information_finish"
              c:identifier="tp_account_get_storage_specific_information_finish"
              version="0.13.2"
              throws="1">
        <doc xml:whitespace="preserve">Retrieve the value of the request begun with
tp_account_get_storage_specific_information_async().

Beware that the returned value is only valid until @result is freed.
Copy it with g_hash_table_ref() if you need to keep it for longer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable of strings to GValues representing the D-Bus type a{sv}.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_supersedes"
              c:identifier="tp_account_get_supersedes"
              version="0.17.5">
        <doc xml:whitespace="preserve">Return the same thing as the #TpAccount:supersedes property, in a way
that may be more convenient for C code.

The returned pointers are not guaranteed to remain valid after the
main loop has been re-entered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:supersedes property</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_uri_schemes"
              c:identifier="tp_account_get_uri_schemes"
              version="0.13.8">
        <doc xml:whitespace="preserve">If the %TP_ACCOUNT_FEATURE_ADDRESSING feature has been prepared
successfully, return a list of additional URI schemes for which this
account should be used if possible. Otherwise return %NULL.

For instance, a SIP or Skype account might have "tel" in this list if the
user would like to use that account to call phone numbers.

This list should not contain the primary URI scheme(s) for the account's
protocol (for instance, "xmpp" for XMPP, or "sip" or "sips" for SIP),
since it should be assumed to be useful for those schemes in any case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a list of URI schemes, or %NULL</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="is_enabled"
              c:identifier="tp_account_is_enabled"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:enabled property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_prepared"
              c:identifier="tp_account_is_prepared"
              version="0.9.0"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same thing as tp_proxy_is_prepared()</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a feature which is required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_valid"
              c:identifier="tp_account_is_valid"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:valid property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="prepare_async"
              c:identifier="tp_account_prepare_async"
              version="0.9.0"
              introspectable="0"
              deprecated="since 0.15.6, use tp_proxy_prepare_async() instead.">
        <doc xml:whitespace="preserve">Requests an asynchronous preparation of @account with the features specified
by @features. When the operation is finished, @callback will be called. You
can then call tp_account_prepare_finish() to get the result of the
operation.

If @features is %NULL, then @callback will be called when the implied
%TP_ACCOUNT_FEATURE_CORE feature is ready.

If %NULL is given to @callback, then no callback will be called when the
operation is finished. Instead, it will simply set @features on @manager.
Note that if @callback is %NULL, then @user_data must also be %NULL.

Since 0.11.3, this is equivalent to calling the new function
tp_proxy_prepare_async() with the same arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">a 0-terminated list of features, or %NULL</doc>
            <type name="GLib.Quark" c:type="const GQuark*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish"
              c:identifier="tp_account_prepare_finish"
              version="0.9.0"
              introspectable="0"
              deprecated="since 0.15.6, use tp_proxy_prepare_finish() instead."
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async preparation of the account @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the preparation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_async"
              c:identifier="tp_account_reconnect_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous reconnect of @account. When the operation is
finished, @callback will be called. You can then call
tp_account_reconnect_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_finish"
              c:identifier="tp_account_reconnect_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async reconnect of @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the reconnect call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_async"
              c:identifier="tp_account_remove_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous removal of @account. When the operation is
finished, @callback will be called. You can then call
tp_account_remove_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish"
              c:identifier="tp_account_remove_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async removal of @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_async"
              c:identifier="tp_account_request_presence_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous change of presence on @account. When the
operation is finished, @callback will be called. You can then call
tp_account_request_presence_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested presence</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status message to set, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message for the change, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_finish"
              c:identifier="tp_account_request_presence_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async presence change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_automatic_presence_async"
              c:identifier="tp_account_set_automatic_presence_async"
              version="0.13.8">
        <doc xml:whitespace="preserve">Requests an asynchronous change of @account's automatic presence. When the
operation is finished, @callback will be called. You can then call
tp_account_set_automatic_presence_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested presence</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status message to set, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message for the change, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_automatic_presence_finish"
              c:identifier="tp_account_set_automatic_presence_finish"
              version="0.13.8"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous request to change the automatic presence of
@account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_async"
              c:identifier="tp_account_set_avatar_async"
              version="0.11.1">
        <doc xml:whitespace="preserve">Requests an asynchronous change of the Avatar parameter on @self. When
the operation is finished, @callback will be called. You can then call
tp_account_set_avatar_finish() to get the result of the operation.

If @len equals 0, the avatar is cleared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="avatar" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a new avatar to set; can be %NULL only if @len equals 0</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the new avatar</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="mime_type" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the MIME type of the new avatar; can be %NULL only if @len equals 0</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_finish"
              c:identifier="tp_account_set_avatar_finish"
              version="0.11.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async avatar change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically_async"
              c:identifier="tp_account_set_connect_automatically_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the ConnectAutomatically property of
@account. When the operation is finished, @callback will be called. You can
then call tp_account_set_display_name_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connect_automatically" transfer-ownership="none">
            <doc xml:whitespace="preserve">new value for the parameter</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically_finish"
              c:identifier="tp_account_set_connect_automatically_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the ConnectAutomatically property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_async"
              c:identifier="tp_account_set_display_name_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the DisplayName property of @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_display_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new display name, or %NULL to unset the display name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_finish"
              c:identifier="tp_account_set_display_name_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the DisplayName property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_async"
              c:identifier="tp_account_set_enabled_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the Enabled property of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_set_enabled_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new enabled value of @account</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_finish"
              c:identifier="tp_account_set_enabled_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the Enabled property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the set was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_async"
              c:identifier="tp_account_set_icon_name_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the Icon property of @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_icon_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="icon_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new icon name, or %NULL to unset the icon name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_finish"
              c:identifier="tp_account_set_icon_name_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the Icon parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname_async"
              c:identifier="tp_account_set_nickname_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous change of the Nickname parameter on @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_nickname_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nickname" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new nickname to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname_finish"
              c:identifier="tp_account_set_nickname_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async nickname change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service_async"
              c:identifier="tp_account_set_service_async"
              version="0.11.9">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the Service property on @self. When
the operation is finished, @callback will be called. You can then call
tp_account_set_service_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new service name, or %NULL or the empty string to unset the service name (which will result in the #TpAccount:service property becoming the same as #TpAccount:protocol)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service_finish"
              c:identifier="tp_account_set_service_finish"
              version="0.11.9"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the Service parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri_scheme_association_async"
              c:identifier="tp_account_set_uri_scheme_association_async"
              version="0.13.8">
        <doc xml:whitespace="preserve">Add @scheme to the list of additional URI schemes that would be returned
by tp_account_get_uri_schemes(), or remove it from that list.

@scheme should not be the primary URI scheme for the account's
protocol (for instance, "xmpp" for XMPP, or "sip" or "sips" for SIP),
since the account should be assumed to be useful for those schemes
regardless of the contents of the list.

Calling this method does not require the %TP_ACCOUNT_FEATURE_ADDRESSING
feature to be enabled, but the change will not be reflected in the result
of tp_account_get_uri_schemes() or tp_account_associated_with_uri_scheme()
unless that feature has been enabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">a non-%NULL URI scheme such as "tel"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="associate" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to use this account for @scheme, or %FALSE to not use it</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri_scheme_association_finish"
              c:identifier="tp_account_set_uri_scheme_association_finish"
              version="0.13.8"
              throws="1">
        <doc xml:whitespace="preserve">Interpret the result of tp_account_set_uri_scheme_association_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_async"
              c:identifier="tp_account_update_parameters_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous update of parameters of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_update_parameters_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">new parameters to set on @account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="unset_parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">list of parameters to unset on @account</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_finish"
              c:identifier="tp_account_update_parameters_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async update of the parameters on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request succeeded, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="reconnect_required"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GStrv to fill with properties that need a reconnect to take effect</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_vardict_async"
              c:identifier="tp_account_update_parameters_vardict_async"
              version="0.17.6">
        <doc xml:whitespace="preserve">Requests an asynchronous update of parameters of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_update_parameters_finish() to get the result of the operation.

If @parameters is a floating reference (see g_variant_ref_sink()),
ownership of @parameters is taken by this function. This means
you can pass the result of g_variant_new() or g_variant_new_parsed()
directly to this function without additional reference-count management.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">a variant of type %G_VARIANT_TYPE_VARDICT containing new parameters to set on @account</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="unset_parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">list of parameters to unset on @account</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_vardict_finish"
              c:identifier="tp_account_update_parameters_vardict_finish"
              version="0.17.6"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async update of the parameters on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request succeeded, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="reconnect_required"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GStrv to fill with properties that need a reconnect to take effect</doc>
            <type name="GObject.Strv" c:type="gchar***"/>
          </parameter>
        </parameters>
      </method>
      <property name="automatic-presence-type"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's automatic presence type (a #TpConnectionPresenceType).

When the account is put online automatically, for instance to make a
channel request or because network connectivity becomes available,
the automatic presence type, status and message will be copied to
their "requested" counterparts.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for automatic-presence-type,
automatic-status and automatic-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <type name="guint"/>
      </property>
      <property name="automatic-status"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The string status name to use in conjunction with the
#TpAccount:automatic-presence-type.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for automatic-presence-type,
automatic-status and automatic-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="automatic-status-message"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-defined message to use in conjunction with the
#TpAccount:automatic-presence-type.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for automatic-presence-type,
automatic-status and automatic-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="changing-presence"
                version="0.11.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if an attempt is currently being made to change the account's
presence (#TpAccount:current-presence-type, #TpAccount:current-status
and #TpAccount:current-status-message) to match its requested presence
(#TpAccount:requested-presence-type, #TpAccount:requested-status
and #TpAccount:requested-status-message).

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="cm-name" version="0.19.3" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection manager name.</doc>
        <type name="utf8"/>
      </property>
      <property name="connect-automatically"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the account should connect automatically or not. To change this
property, use tp_account_set_connect_automatically_async().

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="connection" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The connection of the account, or %NULL if account is offline.
Note that the returned #TpConnection is not guaranteed to have any
features pre-prepared (not even %TP_CONNECTION_FEATURE_CORE) unless
%TP_ACCOUNT_FEATURE_CONNECTION has been prepared on the account

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. If %TP_ACCOUNT_FEATURE_CONNECTION has been prepared, this signal
will be delayed until the connection is ready.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="connection-error"
                version="0.11.7"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus error name for the last disconnection or connection failure,
(in particular, %TP_ERROR_STR_CANCELLED if it was disconnected by user
request), or %NULL if the account is connected.

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="connection-error-details"
                version="0.11.7"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A map from string to #GValue containing extensible error details
related to #TpAccount:connection-error. Functions like tp_asv_get_string()
can be used to read from this map.

The keys for this map are defined by
&lt;ulink url="http://telepathy.freedesktop.org/spec/"&gt;the Telepathy D-Bus
Interface Specification&lt;/ulink&gt;. They will typically include
&lt;literal&gt;debug-message&lt;/literal&gt;, which is a debugging message in the C
locale, analogous to #GError&lt;!-- --&gt;.message.

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
an empty map.</doc>
        <type name="GLib.HashTable">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </property>
      <property name="connection-manager"
                version="0.9.0"
                deprecated="Use #TpAccount:cm-name instead."
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection manager name.</doc>
        <type name="utf8"/>
      </property>
      <property name="connection-status"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection status type (a %TpConnectionStatus).

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_STATUS_DISCONNECTED.</doc>
        <type name="guint"/>
      </property>
      <property name="connection-status-reason"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection status reason (a %TpConnectionStatusReason).

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED.</doc>
        <type name="guint"/>
      </property>
      <property name="current-presence-type"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account connection's current presence type
(a %TpConnectionPresenceType).

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for current-presence-type,
current-status and current-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <type name="guint"/>
      </property>
      <property name="current-status"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The current Status string of the account.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for current-presence-type,
current-status and current-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="current-status-message"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The current status message message of the account.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for current-presence-type,
current-status and current-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="display-name" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's display name, from the DisplayName property.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="enabled" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this account is enabled or not.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="has-been-online"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this account has been online or not.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="icon-name" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's icon name. To change this propery, use
tp_account_set_icon_name_async().

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="nickname" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The nickname that should be set for the user on this account.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="normalized-name"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The normalized form of the user's own unique identifier on this
protocol. For example, on XMPP accounts this is the user's JID; on
ICQ this is the user's UIN; and so on.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="protocol"
                version="0.9.0"
                deprecated="Use #TpAccount:protocol-name instead."
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's machine-readable protocol name, such as "jabber", "msn" or
"local-xmpp". Recommended names for most protocols can be found in the
Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8"/>
      </property>
      <property name="protocol-name"
                version="0.19.3"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's machine-readable protocol name, such as "jabber", "msn" or
"local-xmpp". Recommended names for most protocols can be found in the
Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8"/>
      </property>
      <property name="requested-presence-type"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's requested presence type (a #TpConnectionPresenceType).

Since 0.13.8,
one can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for requested-presence-type,
requested-status and requested-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="guint"/>
      </property>
      <property name="requested-status"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The requested Status string of the account.

Since 0.13.8,
one can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for requested-presence-type,
requested-status and requested-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="requested-status-message"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The requested status message message of the account.

Since 0.13.8,
one can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for requested-presence-type,
requested-status and requested-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="service" version="0.11.9" transfer-ownership="none">
        <doc xml:whitespace="preserve">A machine-readable name identifying a specific service to which this
account connects, or a copy of #TpAccount:protocol if there is no more
specific service.

Well-known names for various services can be found in the Telepathy D-Bus
Interface Specification.

For instance, accounts for the "jabber" protocol should have the service
names "google-talk", "ovi-chat", "facebook" and "lj-talk" for accounts
that connect to Google Talk, Ovi Chat, Facebook and Livejournal,
respectively, and this property will be "jabber" for accounts that
connect to a generic Jabber server.

To change this property, use
tp_account_set_service_async().</doc>
        <type name="utf8"/>
      </property>
      <property name="storage-identifier"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The storage identifier for this account.

A provider-specific variant type used to identify this account with the
provider. This value will be %NULL if #TpAccount:storage-provider is
an empty string.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is %NULL.</doc>
        <type name="GObject.Value"/>
      </property>
      <property name="storage-identifier-variant"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Provider-specific information used to identify this
account. Use g_variant_get_type() to check that the type
is what you expect. For instance, if you use a
#TpAccount:storage-provider with numeric identifiers for accounts,
this variant might have type %G_VARIANT_TYPE_UINT32;
if the storage provider has string-based identifiers, it should
have type %G_VARIANT_TYPE_STRING.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is %NULL.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="storage-provider"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The storage provider for this account.

The name of the account storage implementation. When this
is the empty string the account is internally stored.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is %NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="storage-restrictions"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The storage restrictions for this account.

A bitfield of #TpStorageRestrictionFlags that give the limitations of
this account imposed by the storage provider. This value will be 0
if #TpAccount:storage-provider is an empty string.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is 0.</doc>
        <type name="guint"/>
      </property>
      <property name="supersedes" version="0.17.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">The object paths of previously-active accounts superseded by this one.
For instance, this can be used in a logger to read old logs for an
account that has been migrated from one connection manager to another.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_CORE feature has been prepared; until then,
the value is NULL.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="valid" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this account is valid.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountPrivate" c:type="TpAccountPrivate*"/>
      </field>
      <glib:signal name="presence-changed" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the presence of the account changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new presence</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new presence status</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="status_message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new presence status message</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="status-changed" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the connection status on the account changes.

The @dbus_error_name and @details parameters were present, but
non-functional (always %NULL), in older versions. They have been
available with their current behaviour since version 0.11.7.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="old_status" transfer-ownership="none">
            <doc xml:whitespace="preserve">old #TpAccount:connection-status</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="new_status" transfer-ownership="none">
            <doc xml:whitespace="preserve">new #TpAccount:connection-status</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccount:connection-status-reason</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="dbus_error_name"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the #TpAccount:connection-error</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccount:connection-error-details</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="AccountChannelRequest"
           c:symbol-prefix="account_channel_request"
           c:type="TpAccountChannelRequest"
           version="0.11.12"
           parent="GObject.Object"
           glib:type-name="TpAccountChannelRequest"
           glib:get-type="tp_account_channel_request_get_type"
           glib:type-struct="AccountChannelRequestClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpAccountChannelRequest object.</doc>
      <constructor name="new"
                   c:identifier="tp_account_channel_request_new"
                   version="0.11.12">
        <doc xml:whitespace="preserve">Convenience function to create a new #TpAccountChannelRequest object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested properties of the channel (see #TpAccountChannelRequest:request)</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time of the user action that caused this request, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_audio_call"
                   c:identifier="tp_account_channel_request_new_audio_call"
                   version="0.19.0">
        <doc xml:whitespace="preserve">Convenience function to create a new #TpAccountChannelRequest object
which will yield a Call channel, initially carrying audio only.

After creating the request, you will usually also need to set the "target"
of the channel by calling one of the following functions:

- tp_account_channel_request_set_target_contact()
- tp_account_channel_request_set_target_id()

To call a contact, either use
tp_account_channel_request_set_target_contact() or one of the generic
methods that takes a handle type argument. To check whether this
is possible, use tp_capabilities_supports_audio_call() with
@handle_type set to %TP_HANDLE_TYPE_CONTACT.

&lt;!-- reinstate this when we have CMs that actually allow it:
In some protocols it is possible to create a conference call which
takes place in a named chatroom, by calling
tp_account_channel_request_set_target_id() with @handle_type
set to %TP_HANDLE_TYPE_ROOM. To test whether this is possible, use
tp_capabilities_supports_audio_call() with @handle_type set to
%TP_HANDLE_TYPE_ROOM.
--&gt;

In some protocols, it is possible to create a Call channel without
setting a target at all, which will result in a new, empty
conference call. To test whether this is possible, use
tp_capabilities_supports_audio_call() with @handle_type set to
%TP_HANDLE_TYPE_NONE.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time of the user action that caused this request, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_audio_video_call"
                   c:identifier="tp_account_channel_request_new_audio_video_call"
                   version="0.19.0">
        <doc xml:whitespace="preserve">Convenience function to create a new #TpAccountChannelRequest object
which will yield a Call channel, initially carrying both audio
and video.

This is the same as tp_account_channel_request_new_audio_call(),
except that the channel will initially carry video as well as audio,
and instead of using tp_capabilities_supports_audio_call()
you should test capabilities with
tp_capabilities_supports_audio_video_call().

See the documentation of tp_account_channel_request_new_audio_call()
for details of how to set the target (contact, chatroom etc.) for the call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time of the user action that caused this request, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_file_transfer"
                   c:identifier="tp_account_channel_request_new_file_transfer"
                   version="0.19.0">
        <doc xml:whitespace="preserve">Convenience function to create a new #TpAccountChannelRequest object,
which will yield a FileTransfer channel to send a file to a contact.

After creating the request, you will also need to set the "target"
of the channel by calling one of the following functions:

- tp_account_channel_request_set_target_contact()
- tp_account_channel_request_set_target_id()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">a suggested name for the file, which should not contain directories or directory separators (for example, if you are sending a file called /home/user/monkey.pdf, set this to monkey.pdf)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="mime_type" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the MIME type (content-type) of the file; a %NULL value is allowed, and is treated as "application/octet-stream"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the file's size in bytes</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time of the user action that caused this request, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_text"
                   c:identifier="tp_account_channel_request_new_text"
                   version="0.19.0">
        <doc xml:whitespace="preserve">Convenience function to create a new #TpAccountChannelRequest object
which will yield a Text channel.

After creating the request, you will also need to set the "target"
of the channel by calling one of the following functions:

- tp_account_channel_request_set_target_contact()
- tp_account_channel_request_set_target_id()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time of the user action that caused this request, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_vardict"
                   c:identifier="tp_account_channel_request_new_vardict"
                   version="0.19.10">
        <doc xml:whitespace="preserve">Convenience function to create a new #TpAccountChannelRequest object.

If @request is a floating reference, this function will
take ownership of it, much like g_variant_ref_sink(). See documentation of
that function for details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested properties of the channel (see #TpAccountChannelRequest:request) as a %G_VARIANT_TYPE_VARDICT</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time of the user action that caused this request, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="create_and_handle_channel_async"
              c:identifier="tp_account_channel_request_create_and_handle_channel_async"
              version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
that you are going to handle yourself.
When the operation is finished, @callback will be called. You can then call
tp_account_channel_request_create_and_handle_channel_finish() to get the
result of the operation.

(Behind the scenes, this works by creating a temporary #TpBaseClient, then
acting like tp_account_channel_request_create_channel_async() with the
temporary #TpBaseClient as the @preferred_handler.)

The caller is responsible for closing the channel with
tp_cli_channel_call_close() when it has finished handling it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_handle_channel_finish"
              c:identifier="tp_account_channel_request_create_and_handle_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_handle_channel_async().

See tp_account_channel_request_ensure_and_handle_channel_finish()
for details of how @context can be used.

The caller is responsible for closing the channel with
tp_cli_channel_call_close() when it has finished handling it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference on a #TpChannel if the channel was successfully created and you are handling it, otherwise %NULL.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="context"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer used to return a reference to the context of the HandleChannels() call, or %NULL</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext**"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_observe_channel_async"
              c:identifier="tp_account_channel_request_create_and_observe_channel_async"
              version="0.13.14">
        <doc xml:whitespace="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
@callback will be called when the channel has been created and dispatched,
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation and a #TpChannel representing the channel
which has been created. Note that you are &lt;emphasis&gt;not&lt;/emphasis&gt; handling
this channel and so should interact with the channel as an Observer.
See &lt;ulink url="http://telepathy.freedesktop.org/doc/book/sect.channel-dispatcher.clients.html"&gt;
the Telepathy book&lt;/ulink&gt; for details about how clients should interact
with channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_observe_channel_finish"
              c:identifier="tp_account_channel_request_create_and_observe_channel_finish"
              version="0.13.14"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_observe_channel_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpChannel if the channel was successfully created and dispatched, otherwise %NULL.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_channel_async"
              c:identifier="tp_account_channel_request_create_channel_async"
              version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
@callback will be called when the channel has been created and dispatched,
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_channel_finish"
              c:identifier="tp_account_channel_request_create_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_channel_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel was successfully created and dispatched, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_request"
              c:identifier="tp_account_channel_request_dup_request"
              version="0.19.10">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:request-vardict construct-only
property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the value of #TpAccountChannelRequest:request-vardict</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="ensure_and_handle_channel_async"
              c:identifier="tp_account_channel_request_ensure_and_handle_channel_async"
              version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
that you are going to handle yourself.
When the operation is finished, @callback will be called. You can then call
tp_account_channel_request_ensure_and_handle_channel_finish() to get the
result of the operation.

If the channel already exists and is already being handled, or if a
newly created channel is sent to a different handler, this operation
will fail with the error %TP_ERROR_NOT_YOURS. The other handler
will be notified that the channel was requested again (for instance
with #TpAccountChannelRequest::re-handled,
#TpBaseClientClassHandleChannelsImpl or #TpSimpleHandler:callback),
and can move its window to the foreground, if applicable.

(Behind the scenes, this works by creating a temporary #TpBaseClient, then
acting like tp_account_channel_request_ensure_channel_async() with the
temporary #TpBaseClient as the @preferred_handler.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_handle_channel_finish"
              c:identifier="tp_account_channel_request_ensure_and_handle_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_ensure_and_handle_channel_async().

If the channel already exists and is already being handled, or if a
newly created channel is sent to a different handler, this operation
will fail with the error %TP_ERROR_NOT_YOURS.

@context can be used to obtain extensible information about the channel
via tp_handle_channels_context_get_handler_info(), and any similar methods
that are added in future. It is not valid for the caller of this method
to call tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference on a #TpChannel if the channel was successfully created and you are handling it, otherwise %NULL.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="context"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer used to return a reference to the context of the HandleChannels() call, or %NULL</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext**"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_observe_channel_async"
              c:identifier="tp_account_channel_request_ensure_and_observe_channel_async"
              version="0.13.14">
        <doc xml:whitespace="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
@callback will be called when the channel has been created and dispatched,
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation and a #TpChannel representing the channel
which has been created. Note that you are &lt;emphasis&gt;not&lt;/emphasis&gt; handling
this channel and so should interact with the channel as an Observer.
See &lt;ulink url="http://telepathy.freedesktop.org/doc/book/sect.channel-dispatcher.clients.html"&gt;
the Telepathy book&lt;/ulink&gt; for details about how clients should interact
with channels.

If a suitable channel already existed, its handler will be notified that
the channel was requested again (for instance with
#TpAccountChannelRequest::re-handled, #TpBaseClientClassHandleChannelsImpl
or #TpSimpleHandler:callback, if it is implemented using Telepathy-GLib),
so that it can re-present the window to the user, for example.
Otherwise, a new channel will be created and dispatched to a handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_observe_channel_finish"
              c:identifier="tp_account_channel_request_ensure_and_observe_channel_finish"
              version="0.13.14"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_observe_channel_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpChannel if the channel was successfully ensure and (re-)dispatched, otherwise %NULL.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel_async"
              c:identifier="tp_account_channel_request_ensure_channel_async"
              version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.

If a suitable channel already existed, its handler will be notified that
the channel was requested again (for instance with
#TpAccountChannelRequest::re-handled, #TpBaseClientClassHandleChannelsImpl
or #TpSimpleHandler:callback, if it is implemented using Telepathy-GLib),
so that it can re-present the window to the user, for example.
Otherwise, a new channel will be created and dispatched to a handler.

@callback will be called when an existing channel's handler has been
notified, a new channel has been created and dispatched, or the request
has failed.
You can then call tp_account_channel_request_ensure_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel_finish"
              c:identifier="tp_account_channel_request_ensure_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_ensure_channel_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel was successfully ensured and (re-)dispatched, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_account"
              c:identifier="tp_account_channel_request_get_account"
              version="0.11.12">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:account construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpAccountChannelRequest:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_channel_request"
              c:identifier="tp_account_channel_request_get_channel_request"
              version="0.13.13">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:channel-request property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpAccountChannelRequest:channel-request</doc>
          <type name="ChannelRequest" c:type="TpChannelRequest*"/>
        </return-value>
      </method>
      <method name="get_request"
              c:identifier="tp_account_channel_request_get_request"
              version="0.11.12">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:request construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpAccountChannelRequest:request</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="get_user_action_time"
              c:identifier="tp_account_channel_request_get_user_action_time"
              version="0.11.12">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:user-action-time construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpAccountChannelRequest:user-action-time</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="set_channel_factory"
              c:identifier="tp_account_channel_request_set_channel_factory"
              version="0.13.2"
              deprecated="since 0.15.5. The factory is taken from #TpAccountChannelRequest:account.">
        <doc xml:whitespace="preserve">Set @factory as the #TpClientChannelFactory that will be used to
create the channel requested by @self.
By default #TpAutomaticProxyFactory is used.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpClientChannelFactory</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delegate_to_preferred_handler"
              c:identifier="tp_account_channel_request_set_delegate_to_preferred_handler"
              version="0.15.3">
        <doc xml:whitespace="preserve">If @delegate is %TRUE, asks to the client currently handling the channels to
delegate them to the preferred handler (passed when calling
tp_account_channel_request_ensure_channel_async() for example).

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delegate" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to request to delegate channels</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delegated_channel_callback"
              c:identifier="tp_account_channel_request_set_delegated_channel_callback"
              version="0.15.3">
        <doc xml:whitespace="preserve">Turn on support for
the org.freedesktop.Telepathy.ChannelRequest.DelegateToPreferredHandler
hint.

When receiving a request containing this hint, @self will automatically
delegate the channel to the preferred handler of the request and then call
@callback to inform the client that it is no longer handling this channel.

@callback may be called any time after (and only after) requesting and
handling the channel (i.e. you have called create_and_handle or
ensure_and_handle).

This function can't be called once @self has been used to request a
channel.

See also: tp_base_client_set_delegated_channels_callback()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">function called the channel requested using @self is delegated, may not be %NULL</doc>
            <type name="AccountChannelRequestDelegatedChannelCb"
                  c:type="TpAccountChannelRequestDelegatedChannelCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the @user_data as argument, when @self is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_transfer_description"
              c:identifier="tp_account_channel_request_set_file_transfer_description"
              version="0.19.0">
        <doc xml:whitespace="preserve">Configure this channel request to provide the recipient of the file
with the given description.

If file descriptions are not supported by the protocol, or if this
method is used on a request that is not actually a file transfer, the
channel request will fail. Use
tp_capabilities_supports_file_transfer_description() to determine
whether outgoing file transfers can have a description.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">a description of the file</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_transfer_initial_offset"
              c:identifier="tp_account_channel_request_set_file_transfer_initial_offset"
              version="0.19.0">
        <doc xml:whitespace="preserve">Configure this channel request to inform the recipient of the file
that this channel will not send the first @offset bytes of the file.
In some protocols, this can be used to resume an interrupted transfer.

If this method is not called, the default is to start from the
beginning of the file (equivalent to @offset = 0).

If offsets greater than 0 are not supported by the protocol, or if this
method is used on a request that is not actually a file transfer, the
channel request will fail. Use
tp_capabilities_supports_file_transfer_initial_offset() to determine
whether offsets greater than 0 are available.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset into the file at which the transfer will start</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_transfer_timestamp"
              c:identifier="tp_account_channel_request_set_file_transfer_timestamp"
              version="0.19.0">
        <doc xml:whitespace="preserve">Configure this channel request to accompany the file transfer with
the given modification timestamp for the file.

If file timestamps are not supported by the protocol, or if this
method is used on a request that is not actually a file transfer, the
channel request will fail. Use
tp_capabilities_supports_file_transfer_date() to determine
whether outgoing file transfers can have a timestamp.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the modification timestamp of the file, in seconds since the Unix epoch (the beginning of 1970 in the UTC time zone), as returned by g_date_time_to_unix()</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_transfer_uri"
              c:identifier="tp_account_channel_request_set_file_transfer_uri"
              version="0.19.0">
        <doc xml:whitespace="preserve">Configure this channel request to provide other local Telepathy
components with the URI of the file being sent. Unlike most
properties on a file transfer channel, this information is not
sent to the recipient of the file; instead, it is signalled on
D-Bus for use by other Telepathy components.

The URI should usually be a &lt;code&gt;file&lt;/code&gt; URI as defined by
&lt;ulink url="http://www.apps.ietf.org/rfc/rfc1738.html#sec-3.10"&gt;RFC 1738
§3.10&lt;/ulink&gt; (for instance, &lt;code&gt;file:///path/to/file&lt;/code&gt; or
&lt;code&gt;file://localhost/path/to/file&lt;/code&gt;). If a remote resource
is being transferred to a contact, it may have a different scheme,
such as &lt;code&gt;http&lt;/code&gt;.

Even if this method is used, the connection manager will not read
the file from disk: the handler for the channel is still
responsible for streaming the file. However, providing the URI
allows a local logger to log which file was transferred, for instance.

If this functionality is not supported by the connection manager, or
if this method is used on a request that is not actually a file transfer,
the channel request will fail. Use
tp_capabilities_supports_file_transfer_uri() to determine
whether outgoing file transfers can have a URI.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source URI for the file</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hint"
              c:identifier="tp_account_channel_request_set_hint"
              version="0.19.8">
        <doc xml:whitespace="preserve">Set additional information about the channel request, which will be used
in the resulting request's #TpChannelRequest:hints property.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key used for the hint</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a variant containting the hint value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hints"
              c:identifier="tp_account_channel_request_set_hints"
              version="0.13.14">
        <doc xml:whitespace="preserve">Set additional information about the channel request, which will be used
as the value for the resulting request's #TpChannelRequest:hints property.

This function can't be called once @self has been used to request a
channel.

In high-level language bindings, use tp_account_channel_request_set_hint()
instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TP_HASH_TYPE_STRING_VARIANT_MAP</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_request_property"
              c:identifier="tp_account_channel_request_set_request_property"
              version="0.19.0">
        <doc xml:whitespace="preserve">Configure this channel request to include the given property, as
documented in the Telepathy D-Bus API Specification or an
implementation-specific extension.

Using this method is not recommended, but it can be necessary for
experimental or implementation-specific interfaces.

If the property is not supported by the protocol or channel type, the
channel request will fail. Use #TpCapabilities and the Telepathy
D-Bus API Specification to determine which properties are available.

If @value is a floating reference, this method takes ownership of it
by using g_variant_ref_sink(). This allows convenient inline use of
#GVariant constructors:

|[
tp_account_channel_request_set_request_property (acr, "com.example.Int",
    g_variant_new_int32 (17));
tp_account_channel_request_set_request_property (acr, "com.example.String",
    g_variant_new_string ("ferret"));
]|

It is an error to provide a @value which contains types not supported by
D-Bus.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus property name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">an arbitrary value for the property</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_target_contact"
              c:identifier="tp_account_channel_request_set_target_contact"
              version="0.19.0">
        <doc xml:whitespace="preserve">Configure this request to create a peer-to-peer channel with @contact as
the other peer.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">the contact to be contacted</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_target_id"
              c:identifier="tp_account_channel_request_set_target_id"
              version="0.19.0">
        <doc xml:whitespace="preserve">Configure this request to create a channel with @identifier,
an identifier of type @handle_type.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of @identifier, typically %TP_HANDLE_TYPE_CONTACT or %TP_HANDLE_TYPE_ROOM</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:whitespace="preserve">the unique identifier of the contact, room etc. to be contacted</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.12"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccount used to request the channel.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channel-request" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpChannelRequest used to request the channel, or %NULL if the
channel has not be requested yet.

This can be useful for example to compare with the #TpChannelRequest
objects received from the requests_satisfied argument of
#TpSimpleHandlerHandleChannelsImpl to check if the client is asked to
handle the channel it just requested.

Note that the #TpChannelRequest objects may be different while still
representing the same ChannelRequest on D-Bus. You have to compare
them using their object paths (tp_proxy_get_object_path()).

Since 0.13.13</doc>
        <type name="ChannelRequest"/>
      </property>
      <property name="request"
                version="0.11.12"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The desired D-Bus properties for the channel, represented as a
#GHashTable where the keys are strings and the values are #GValue.

When constructing a new object, one of
#TpAccountChannelRequest:request or
#TpAccountChannelRequest:request-vardict must be set to a non-%NULL
value, and the other must remain unspecified.</doc>
        <type/>
      </property>
      <property name="request-vardict"
                version="0.19.10"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The desired D-Bus properties for the channel.

When constructing a new object, one of
#TpAccountChannelRequest:request or
#TpAccountChannelRequest:request-vardict must be set to a non-%NULL
value, and the other must remain unspecified.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="user-action-time"
                version="0.11.12"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user action time that will be passed to the channel dispatcher when
requesting the channel.

This may be the time at which user action occurred, or one of the special
values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
%TP_USER_ACTION_TIME_CURRENT_TIME.

If %TP_USER_ACTION_TIME_NOT_USER_ACTION, the action doesn't involve any
user action. Clients should avoid stealing focus when presenting the
channel.

If %TP_USER_ACTION_TIME_CURRENT_TIME, clients SHOULD behave as though the
user action happened at the current time, e.g. a client may
request that its window gains focus.

On X11-based systems, GDK 2, GDK 3, Clutter 1.0 etc.,
tp_user_action_time_from_x11() can be used to convert an X11 timestamp to
a Telepathy user action time.

If the channel request succeeds, this user action time will be passed on
to the channel's handler. If the handler is a GUI, it may use
tp_user_action_time_should_present() to decide whether to bring its
window to the foreground.</doc>
        <type name="gint64"/>
      </property>
      <glib:signal name="re-handled"
                   when="last"
                   detailed="1"
                   version="0.11.12">
        <doc xml:whitespace="preserve">Emitted when the channel created using @self has been "re-handled".

This means that a Telepathy client has made another request for a
matching channel using an "ensure" API like
tp_account_channel_request_ensure_channel_async(), while the channel
still exists. Instead of creating a new channel, the channel dispatcher
notifies the existing handler of @channel, resulting in this signal.

Most GUI handlers should respond to this signal by checking
@user_action_time, and if appropriate, moving to the foreground.

@context can be used to obtain extensible information about the channel
via tp_handle_channels_context_get_handler_info(), and any similar methods
that are added in future. It is not valid for the receiver of this signal
to call tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannel being re-handled</doc>
            <type name="Channel"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME; see #TpAccountChannelRequest:user-action-time</doc>
            <type name="gint64"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpHandleChannelsContext representing the context of the HandleChannels() call.</doc>
            <type name="HandleChannelsContext"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountChannelRequestClass"
            c:type="TpAccountChannelRequestClass"
            disguised="1"
            glib:is-gtype-struct-for="AccountChannelRequest"
            version="0.11.12">
      <doc xml:whitespace="preserve">The class of a #TpAccountChannelRequest.</doc>
    </record>
    <callback name="AccountChannelRequestDelegatedChannelCb"
              c:type="TpAccountChannelRequestDelegatedChannelCb"
              version="0.15.3">
      <doc xml:whitespace="preserve">Called when a client asked us to delegate @channel to another Handler.
When this function is called you are no longer handling @channel.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="request" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccountChannelRequest instance</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </parameter>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpChannel</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_account_channel_request_set_delegated_channel_callback()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AccountChannelRequestPrivate"
            c:type="TpAccountChannelRequestPrivate"
            disguised="1">
    </record>
    <record name="AccountClass"
            c:type="TpAccountClass"
            glib:is-gtype-struct-for="Account">
      <doc xml:whitespace="preserve">The class of a #TpAccount.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountClassPrivate" c:type="TpAccountClassPrivate*"/>
      </field>
    </record>
    <record name="AccountClassPrivate"
            c:type="TpAccountClassPrivate"
            disguised="1">
    </record>
    <class name="AccountManager"
           c:symbol-prefix="account_manager"
           c:type="TpAccountManager"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpAccountManager"
           glib:get-type="tp_account_manager_get_type"
           glib:type-struct="AccountManagerClass">
      <doc xml:whitespace="preserve">The Telepathy Account Manager stores real-time communication accounts and
their configuration, places accounts online on request, and manipulates
accounts' presence, nicknames and avatars.

#TpAccountManager is the "top level" object, its #TpProxy:factory will be
propagated to all other objects like #TpAccountManager -&gt; #TpAccount -&gt;
#TpConnection -&gt; #TpContact and #TpChannel. This means that desired features
set on that factory will be prepared on all those objects.

&lt;example id="account-manager"&gt;&lt;title&gt;TpAccountManager example&lt;/title&gt;&lt;programlisting&gt;&lt;xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="../../../examples/client/contact-list.c"&gt;&lt;xi:fallback&gt;FIXME: MISSING XINCLUDE CONTENT&lt;/xi:fallback&gt;&lt;/xi:include&gt;&lt;/programlisting&gt;&lt;/example&gt;</doc>
      <constructor name="new" c:identifier="tp_account_manager_new">
        <doc xml:whitespace="preserve">Convenience function to create a new account manager proxy. The returned
#TpAccountManager is not guaranteed to be ready on return.

Use tp_account_manager_dup() instead if you want an account manager proxy
on the starter or session bus (which is almost always the right thing for
Telepathy).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account manager proxy</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_account_manager_new_with_factory">
        <doc xml:whitespace="preserve">Convenience function to create a new account manager proxy. The returned
#TpAccountManager is not guaranteed to be ready on return.

Should be used only by applications having their own #TpSimpleClientFactory
subclass. Usually this should be done at application startup and followed by
a call to tp_account_manager_set_default() to ensure other libraries/plugins
will use this custom factory as well.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account manager proxy</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSimpleClientFactory</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="can_set_default"
                c:identifier="tp_account_manager_can_set_default"
                version="0.19.6">
        <doc xml:whitespace="preserve">Check if tp_account_manager_set_default() has already successfully been
called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if tp_account_manager_set_default() has already successfully been called in this process, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <function name="dup"
                c:identifier="tp_account_manager_dup"
                version="0.9.0">
        <doc xml:whitespace="preserve">Returns an account manager proxy on the D-Bus daemon on which this
process was activated (if it was launched by D-Bus service activation), or
the session bus (otherwise).

The returned #TpAccountManager is cached; the same #TpAccountManager object
will be returned by this function repeatedly, as long as at least one
reference exists. Note that the returned #TpAccountManager is not guaranteed
to be ready on return.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an account manager proxy on the starter or session bus, or %NULL if it wasn't possible to get a dbus daemon proxy for the appropriate bus</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_account_manager_get_feature_quark_core"
                version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for representing the core feature of a #TpAccountManager</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_account_manager_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpAccountManager have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_ACCOUNT_MANAGER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="create_account_async"
              c:identifier="tp_account_manager_create_account_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous create of an account on the account manager
@manager. When the operation is finished, @callback will be called. You can
then call tp_account_manager_create_account_finish() to get the result of
the operation.

@callback will only be called when the newly created #TpAccount has the
%TP_ACCOUNT_FEATURE_CORE feature ready on it, so when calling
tp_account_manager_create_account_finish(), one can guarantee this feature
will be ready.

It is usually better to use #TpAccountRequest instead, particularly when
using high-level language bindings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a connection manager</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the display name for the account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">parameters for the new account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">properties for the new account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_finish"
              c:identifier="tp_account_manager_create_account_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async create account operation, and returns a new #TpAccount
object, with the %TP_ACCOUNT_FEATURE_CORE feature ready on it.

The caller must keep a ref to the returned object using g_object_ref() if
it is to be kept beyond the lifetime of @result.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #TpAccount which was just created on success, otherwise %NULL</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_valid_accounts"
              c:identifier="tp_account_manager_dup_valid_accounts"
              version="0.19.9">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of reffed valid accounts in @manager.
The list must be freed with g_list_free_full() and g_object_unref() after
used.

The returned #TpAccount&lt;!-- --&gt;s are guaranteed to have
%TP_ACCOUNT_FEATURE_CORE prepared, along with all features previously passed
to tp_simple_client_factory_add_account_features().

The list of valid accounts returned is not guaranteed to have been retrieved
until %TP_ACCOUNT_MANAGER_FEATURE_CORE is prepared
(tp_proxy_prepare_async() has returned). Until this feature has
been prepared, an empty list (%NULL) will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GList of reffed valid accounts in @manager</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Account"/>
          </type>
        </return-value>
      </method>
      <method name="enable_restart"
              c:identifier="tp_account_manager_enable_restart">
        <doc xml:whitespace="preserve">Enable autostarting the account manager D-Bus service. This means
that the account manager will be restarted if it disappears from
the bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="ensure_account"
              c:identifier="tp_account_manager_ensure_account"
              version="0.9.0"
              deprecated="New code should use tp_simple_client_factory_ensure_account() instead.">
        <doc xml:whitespace="preserve">Lookup an account in the account manager @manager. If the desired account
has already been ensured then the same object will be returned, otherwise
it will create a new #TpAccount and add it to @manager. As a result, if
@manager thinks that the account doesn't exist, this will still add it to
@manager to avoid races. Note that the returned #TpAccount is not guaranteed
to be ready on return.

The caller must keep a ref to the returned object using g_object_ref() if
it is to be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #TpAccount at @path, or %NULL if @path is not a valid account path.</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path for an account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_most_available_presence"
              c:identifier="tp_account_manager_get_most_available_presence"
              version="0.9.0">
        <doc xml:whitespace="preserve">Gets the most available presence over all accounts in @manager. This
function does not average presences across all accounts, but it merely
finds the "most available" presence. As a result, there is a guarantee
that there exists at least one account in @manager with the returned
presence.

If no accounts are enabled or valid the output will be
(%TP_CONNECTION_PRESENCE_TYPE_OFFLINE, "offline", "").

Since 0.17.5, if the only connected accounts does not implement
%TP_IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE, the output will be
(%TP_CONNECTION_PRESENCE_TYPE_AVAILABLE, "available", "").

The return value of this function is not guaranteed to have been retrieved
until tp_proxy_prepare_async() has finished; until then, the
value will be the same as if no accounts are enabled or valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the most available presence across all accounts</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a string to fill with the actual status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a string to fill with the actual status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valid_accounts"
              c:identifier="tp_account_manager_get_valid_accounts"
              version="0.9.0"
              deprecated="Since 0.19.9. New code should use tp_account_manager_dup_valid_accounts() instead.">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of valid accounts in @manager. The list
must be freed with g_list_free() after used. None of the accounts in the
returned list are guaranteed to be ready.

Note that the #TpAccount&lt;!-- --&gt;s in the returned #GList are not reffed
before returning from this function. One could ref every item in the list
like the following example:
|[
GList *accounts;
account = tp_account_manager_get_valid_accounts (manager);
g_list_foreach (accounts, (GFunc) g_object_ref, NULL);
]|

The returned #TpAccount&lt;!-- --&gt;s are guaranteed to have
%TP_ACCOUNT_FEATURE_CORE prepared, along with all features previously passed
to tp_simple_client_factory_add_account_features().

The list of valid accounts returned is not guaranteed to have been retrieved
until %TP_ACCOUNT_MANAGER_FEATURE_CORE is prepared
(tp_proxy_prepare_async() has returned). Until this feature has
been prepared, an empty list (%NULL) will be returned.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a newly allocated #GList of valid accounts in @manager</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Account"/>
          </type>
        </return-value>
      </method>
      <method name="is_prepared"
              c:identifier="tp_account_manager_is_prepared"
              version="0.9.0"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same thing as tp_proxy_is_prepared()</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a feature which is required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async"
              c:identifier="tp_account_manager_prepare_async"
              version="0.9.0"
              introspectable="0"
              deprecated="since 0.15.6, use tp_proxy_prepare_async() instead.">
        <doc xml:whitespace="preserve">Requests an asynchronous preparation of @manager with
%TP_ACCOUNT_MANAGER_FEATURE_CORE, plus any features specified
by @features. When the operation is finished, @callback will be called. You
can then call tp_account_manager_prepare_finish() to get the result of the
operation.

If %NULL is given to @callback, then no callback will be called when the
operation is finished. Instead, it will simply set @features on @manager.
Note that if @callback is %NULL, then @user_data must also be %NULL.

In version 0.11.3 or later, this is equivalent to calling
tp_proxy_prepare_async() with the same arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">a 0-terminated list of features, or %NULL</doc>
            <type name="GLib.Quark" c:type="const GQuark*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish"
              c:identifier="tp_account_manager_prepare_finish"
              version="0.9.0"
              introspectable="0"
              deprecated="since 0.15.6, use tp_proxy_prepare_finish() instead."
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async preparation of the account manager @manager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the preparation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_all_requested_presences"
              c:identifier="tp_account_manager_set_all_requested_presences"
              version="0.9.0">
        <doc xml:whitespace="preserve">Iterates through the accounts in @manager and requests the presence
(@type, @status and @message). Note that the presence requested here is
merely a request, and if might not be satisfiable.

You can find the most available presence across all accounts by calling
tp_account_manager_get_most_available_presence().

Setting a requested presence on all accounts will have no effect
until tp_proxy_prepare_async()
(or the older tp_account_manager_prepare_async()) has finished.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a presence type to request</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status to request</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status message to request</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default"
              c:identifier="tp_account_manager_set_default"
              version="0.15.5">
        <doc xml:whitespace="preserve">Define the #TpAccountManager singleton that will be returned by
tp_account_manager_dup().

This function may only be called before the first call to
tp_account_manager_dup(), and may not be called more than once. Applications
which use a custom #TpSimpleClientFactory and want the default
#TpAccountManager to use that factory should call this after calling
tp_account_manager_new_with_factory().

Unlike tp_account_manager_dup(), this function will keep an internal
reference to @manager, so it will never be destroyed.

Note that @manager must use the default #TpDBusDaemon as returned by
tp_dbus_daemon_dup()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountManagerPrivate" c:type="TpAccountManagerPrivate*"/>
      </field>
      <glib:signal name="account-disabled" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when an account from @manager is disabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-enabled" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when an account from @manager is enabled.

@account is guaranteed to have %TP_ACCOUNT_FEATURE_CORE prepared, along
with all features previously passed to
tp_simple_client_factory_add_account_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-removed" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when an account is removed from @manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-validity-changed" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the validity on @account changes.

This signal is also used to indicate a new account that did not
previously exist has been added (with @valid set to %TRUE).

@account is guaranteed to have %TP_ACCOUNT_FEATURE_CORE prepared, along
with all features previously passed to
tp_simple_client_factory_add_account_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
          <parameter name="valid" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the account is now valid</doc>
            <type name="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="most-available-presence-changed"
                   when="last"
                   version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the most available presence on @manager changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">new presence type</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">new status</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">new status message</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountManagerClass"
            c:type="TpAccountManagerClass"
            glib:is-gtype-struct-for="AccountManager">
      <doc xml:whitespace="preserve">The class of a #TpAccount.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountManagerClassPrivate"
              c:type="TpAccountManagerClassPrivate*"/>
      </field>
    </record>
    <record name="AccountManagerClassPrivate"
            c:type="TpAccountManagerClassPrivate"
            disguised="1">
    </record>
    <record name="AccountManagerPrivate"
            c:type="TpAccountManagerPrivate"
            disguised="1">
    </record>
    <record name="AccountPrivate" c:type="TpAccountPrivate" disguised="1">
    </record>
    <class name="AccountRequest"
           c:symbol-prefix="account_request"
           c:type="TpAccountRequest"
           version="0.19.1"
           parent="GObject.Object"
           glib:type-name="TpAccountRequest"
           glib:get-type="tp_account_request_get_type"
           glib:type-struct="AccountRequestClass">
      <doc xml:whitespace="preserve">An object for representing a currently non-existent account which
is to be created on a #TpAccountManager.</doc>
      <constructor name="new"
                   c:identifier="tp_account_request_new"
                   version="0.19.1">
        <doc xml:whitespace="preserve">Convenience function to create a new account request object which
will assist in the creation of a new account on @account_manager,
using connection manager @manager, and protocol @protocol.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account request object, or %NULL if any argument is incorrect</doc>
          <type name="AccountRequest" c:type="TpAccountRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccountManager to create the account on</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the connection manager</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the protocol on @manager</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the user-visible name of this account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_protocol"
                   c:identifier="tp_account_request_new_from_protocol"
                   version="0.19.1">
        <doc xml:whitespace="preserve">Convenience function to create a new #TpAccountRequest object using
a #TpProtocol instance, instead of specifying connection manager
and protocol name specifically. See tp_account_request_new() for
more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account request object, or %NULL if any argument is incorrect</doc>
          <type name="AccountRequest" c:type="TpAccountRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccountManager to create the account on</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpProtocol</doc>
            <type name="Protocol" c:type="TpProtocol*"/>
          </parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the user-visible name of this account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_supersedes"
              c:identifier="tp_account_request_add_supersedes"
              version="0.19.1">
        <doc xml:whitespace="preserve">Add an account object path to the list of superseded accounts which
this new account will supersede. Use the
#TpAccountRequest:supersedes property to read the current list of
superseded accounts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="superseded_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account object path to add to the supersedes list</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_async"
              c:identifier="tp_account_request_create_account_async"
              version="0.19.1">
        <doc xml:whitespace="preserve">Start an asynchronous operation to create the account @self on the
account manager.

@callback will only be called when the newly created #TpAccount has
the %TP_ACCOUNT_FEATURE_CORE feature ready on it, so when calling
tp_account_request_create_account_finish(), one can guarantee this
feature.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a function to call when the account has been created</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_finish"
              c:identifier="tp_account_request_create_account_finish"
              version="0.19.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous account creation operation and returns a
new ref to a #TpAccount object. The returned account will have the
features listed in tp_simple_client_factory_dup_account_features()
(with the proxy factory from #TpAccountRequest:account-manager)
prepared on it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new ref to a #TpAccount, or %NULL</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_automatic_presence"
              c:identifier="tp_account_request_set_automatic_presence"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set the automatic presence for the new account, @self, to the type
(@presence, @status), with message @message. Use the
#TpAccountRequest:automatic-presence-type,
#TpAccountRequest:automatic-status, and
#TpAccountRequest:automatic-status-message properties to read the
current automatic presence.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">the automatic presence type</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">the automatic presence status</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the automatic presence message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar"
              c:identifier="tp_account_request_set_avatar"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set the avatar of the account @self to @avatar. Use the
#TpAccountRequest:avatar and #TpAccountRequest:avatar-mime-type
properties to read the current avatar.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="avatar" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a new avatar to set; can be %NULL only if %len equals 0</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the new avatar</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="mime_type" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the MIME type of the new avatar; can be %NULL only if @len equals 0</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically"
              c:identifier="tp_account_request_set_connect_automatically"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set the connect automatically property of the account on creation
to @connect_automatically so that the account is brought online to
the automatic presence. Use the
#TpAccountRequest:connect-automatically property to read the current
connect automatically value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connect_automatically" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the account is to connect automatically</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name"
              c:identifier="tp_account_request_set_display_name"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set the display name for the new account, @self, to @name. Use the
#TpAccountRequest:display-name property to read the current display
name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a display name for the account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled"
              c:identifier="tp_account_request_set_enabled"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set the enabled property of the account on creation to
@enabled. Use the #TpAccountRequest:enabled property to read the
current enabled value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the account is to be enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name"
              c:identifier="tp_account_request_set_icon_name"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set the icon name for the new account, @self, to @icon. Use the
#TpAccountRequest:icon-name property to read the current icon name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:whitespace="preserve">an icon name for the account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname"
              c:identifier="tp_account_request_set_nickname"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set the nickname for the new account, @self, to @nickname. Use the
#TpAccountRequest:nickname property to read the current nickname.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nickname" transfer-ownership="none">
            <doc xml:whitespace="preserve">a nickname for the account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parameter"
              c:identifier="tp_account_request_set_parameter"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set an account parameter, @key, to @value. Use the
#TpAccountRequest:parameters property to read the current list of
set parameters.

Parameters can be unset using tp_account_request_unset_parameter().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a variant containing the parameter value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parameter_string"
              c:identifier="tp_account_request_set_parameter_string"
              version="0.19.1"
              introspectable="0">
        <doc xml:whitespace="preserve">Convenience function to set an account parameter string value. See
tp_account_request_set_parameter() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_requested_presence"
              c:identifier="tp_account_request_set_requested_presence"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set the requested presence for the new account, @self, to the type
(@presence, @status), with message @message. Use the
#TpAccountRequest:requested-presence-type,
#TpAccountRequest:requested-status, and
#TpAccountRequest:requested-status-message properties to read the
current requested presence.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested presence type</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested presence status</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested presence message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service"
              c:identifier="tp_account_request_set_service"
              version="0.19.1">
        <doc xml:whitespace="preserve">Set the service property of the account to @service. Use the
#TpAccountRequest:service property to read the current value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">the service name for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_storage_provider"
              c:identifier="tp_account_request_set_storage_provider"
              version="0.19.4">
        <doc xml:whitespace="preserve">Set the account storage to use when creating the account. Use the
#TpAccountRequest:storage-provider property to read the current value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="provider" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of an account storage implementation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unset_parameter"
              c:identifier="tp_account_request_unset_parameter"
              version="0.19.1">
        <doc xml:whitespace="preserve">Unset the account parameter @key which has previously been set
using tp_account_request_set_parameter() or another convenience
function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account-manager"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccountManager to create the account on.</doc>
        <type name="AccountManager"/>
      </property>
      <property name="automatic-presence-type"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's automatic presence type (a
#TpConnectionPresenceType). To change this property use
tp_account_request_set_automatic_presence().

When the account is put online automatically, for instance to
make a channel request or because network connectivity becomes
available, the automatic presence type, status and message will
be copied to their "requested" counterparts.</doc>
        <type name="guint"/>
      </property>
      <property name="automatic-status"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The string status name to use in conjunction with the
#TpAccountRequest:automatic-presence-type. To change this property
use tp_account_request_set_automatic_presence().</doc>
        <type name="utf8"/>
      </property>
      <property name="automatic-status-message"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-defined message to use in conjunction with the
#TpAccount:automatic-presence-type. To change this property use
tp_account_request_set_automatic_presence().</doc>
        <type name="utf8"/>
      </property>
      <property name="avatar" version="0.19.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The avatar set on the account. The avatar's mime type can be read
in the #TpAccountRequest:avatar-mime-type property. To change this
property, use tp_account_request_set_avatar().</doc>
        <array name="GLib.Array">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="avatar-mime-type"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The mime type of the #TpAccountRequest:avatar property. To change
this property, use tp_account_request_set_avatar().</doc>
        <type name="utf8"/>
      </property>
      <property name="connect-automatically"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the account should connect automatically or not. To change this
property, use tp_account_request_set_connect_automatically().</doc>
        <type name="gboolean"/>
      </property>
      <property name="connection-manager"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection manager name.</doc>
        <type name="utf8"/>
      </property>
      <property name="display-name"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's display name. To change this property use
tp_account_request_set_display_name().</doc>
        <type name="utf8"/>
      </property>
      <property name="enabled" version="0.19.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the account is enabled or not. To change this property
use tp_account_request_set_enabled().</doc>
        <type name="gboolean"/>
      </property>
      <property name="icon-name" version="0.19.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's icon name. To change this propery, use
tp_account_request_set_icon_name().</doc>
        <type name="utf8"/>
      </property>
      <property name="nickname" version="0.19.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's nickname. To change this property use
tp_account_request_set_nickname().</doc>
        <type name="utf8"/>
      </property>
      <property name="parameters" version="0.19.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection parameters. To add a parameter, use
tp_account_request_set_parameter() or another convience function.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="properties" version="0.19.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's properties.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="protocol"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's machine-readable protocol name, such as "jabber", "msn" or
"local-xmpp". Recommended names for most protocols can be found in the
Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8"/>
      </property>
      <property name="requested-presence-type"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's requested presence type (a
#TpConnectionPresenceType). To change this property use
tp_account_request_set_requested_presence().</doc>
        <type name="guint"/>
      </property>
      <property name="requested-status"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The requested Status string of the account. To change this
property use tp_account_request_set_requested_presence().</doc>
        <type name="utf8"/>
      </property>
      <property name="requested-status-message"
                version="0.19.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The requested status message message of the account. To change
this property use tp_account_request_set_requested_presence().</doc>
        <type name="utf8"/>
      </property>
      <property name="service" version="0.19.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string describing the service of the account, which must
consist only of ASCII letters, numbers and hyphen/minus signs,
and start with a letter (matching the requirements for
Protocol). To change this property, use
tp_account_request_set_service().</doc>
        <type name="utf8"/>
      </property>
      <property name="storage-provider"
                version="0.19.4"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's storage provider. To change this property use
tp_account_request_set_storage_provider().</doc>
        <type name="utf8"/>
      </property>
      <property name="supersedes" version="0.19.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The object paths of previously-active accounts superseded by this one.
For instance, this can be used in a logger to read old logs for an
account that has been migrated from one connection manager to another.

To add to this property use tp_account_request_add_supersedes().</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountRequestPrivate" c:type="TpAccountRequestPrivate*"/>
      </field>
    </class>
    <record name="AccountRequestClass"
            c:type="TpAccountRequestClass"
            glib:is-gtype-struct-for="AccountRequest">
      <doc xml:whitespace="preserve">The class of a #TpAccountRequest.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="AccountRequestPrivate"
            c:type="TpAccountRequestPrivate"
            disguised="1">
    </record>
    <class name="AddDispatchOperationContext"
           c:symbol-prefix="add_dispatch_operation_context"
           c:type="TpAddDispatchOperationContext"
           version="0.11.5"
           parent="GObject.Object"
           glib:type-name="TpAddDispatchOperationContext"
           glib:get-type="tp_add_dispatch_operation_context_get_type"
           glib:type-struct="AddDispatchOperationContextClass">
      <doc xml:whitespace="preserve">Data structure representing the context of a Approver.AddDispatchOperation()
call.</doc>
      <method name="accept"
              c:identifier="tp_add_dispatch_operation_context_accept"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl when it's done so
the D-Bus method can return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="delay"
              c:identifier="tp_add_dispatch_operation_context_delay"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpAddDispatchOperationContext before calling this function, and
is responsible for calling either
tp_add_dispatch_operation_context_accept() or
tp_add_dispatch_operation_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fail"
              c:identifier="tp_add_dispatch_operation_context_fail"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAccount object representing the Account of the DispatchOperation
that has been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channels"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection object representing the Connection of the DispatchOperation
that has been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="dbus-context"
                version="0.11.5"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
AddDispatchOperation call.
Can only be written during construction.</doc>
        <type name="gpointer"/>
      </property>
      <property name="dispatch-operation"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpChannelDispatchOperation object representing the
ChannelDispatchOperation that has been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="ChannelDispatchOperation"/>
      </property>
    </class>
    <record name="AddDispatchOperationContextClass"
            c:type="TpAddDispatchOperationContextClass"
            disguised="1"
            glib:is-gtype-struct-for="AddDispatchOperationContext"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpAddDispatchOperationContext.</doc>
    </record>
    <record name="AddDispatchOperationContextPrivate"
            c:type="TpAddDispatchOperationContextPrivate"
            disguised="1">
    </record>
    <bitfield name="AnonymityModeFlags" c:type="TpAnonymityModeFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Flags for the various types of anonymity modes.  These modes are solely to         inform the CM of the desired anonymous settings.  It is up to the         CM to determine whether the anonymity modes should be handled within         the CM itself, or whether the network that a CM might be talking to         should be enforcing anonymity.          CMs MAY support only a subset of these modes, and specific         connections MAY support none at all.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="client_info"
              value="1"
              c:identifier="TP_ANONYMITY_MODE_CLIENT_INFO"/>
      <member name="show_client_info"
              value="2"
              c:identifier="TP_ANONYMITY_MODE_SHOW_CLIENT_INFO"/>
      <member name="network_info"
              value="4"
              c:identifier="TP_ANONYMITY_MODE_NETWORK_INFO"/>
    </bitfield>
    <class name="AutomaticClientFactory"
           c:symbol-prefix="automatic_client_factory"
           c:type="TpAutomaticClientFactory"
           version="0.15.5"
           parent="SimpleClientFactory"
           glib:type-name="TpAutomaticClientFactory"
           glib:get-type="tp_automatic_client_factory_get_type"
           glib:type-struct="AutomaticClientFactoryClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpAutomaticClientFactory</doc>
      <constructor name="new"
                   c:identifier="tp_automatic_client_factory_new"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Returns a new #TpAutomaticClientFactory instance. If @dbus is %NULL,
tp_dbus_daemon_dup() will be used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAutomaticClientFactory</doc>
          <type name="AutomaticClientFactory"
                c:type="TpAutomaticClientFactory*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a #TpDBusDaemon, or %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="SimpleClientFactory" c:type="TpSimpleClientFactory"/>
      </field>
    </class>
    <record name="AutomaticClientFactoryClass"
            c:type="TpAutomaticClientFactoryClass"
            glib:is-gtype-struct-for="AutomaticClientFactory"
            version="0.15.5">
      <doc xml:whitespace="preserve">The class of a #TpAutomaticClientFactory.</doc>
      <field name="parent_class">
        <type name="SimpleClientFactoryClass"
              c:type="TpSimpleClientFactoryClass"/>
      </field>
    </record>
    <class name="AutomaticProxyFactory"
           c:symbol-prefix="automatic_proxy_factory"
           c:type="TpAutomaticProxyFactory"
           version="0.13.2"
           parent="GObject.Object"
           glib:type-name="TpAutomaticProxyFactory"
           glib:get-type="tp_automatic_proxy_factory_get_type"
           glib:type-struct="AutomaticProxyFactoryClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpAutomaticProxyFactory</doc>
      <implements name="ClientChannelFactory"/>
      <constructor name="new"
                   c:identifier="tp_automatic_proxy_factory_new"
                   version="0.13.2"
                   deprecated="New code should use #TpAutomaticClientFactory instead">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpAutomaticProxyFactory instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAutomaticProxyFactory</doc>
          <type name="AutomaticProxyFactory"
                c:type="TpAutomaticProxyFactory*"/>
        </return-value>
      </constructor>
      <function name="dup"
                c:identifier="tp_automatic_proxy_factory_dup"
                version="0.13.2"
                deprecated="New code should use #TpAutomaticClientFactory instead">
        <doc xml:whitespace="preserve">Returns a cached #TpAutomaticProxyFactory; the same
#TpAutomaticProxyFactory object will be returned by this function repeatedly,
as long as at least one reference exists.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #TpAutomaticProxyFactory</doc>
          <type name="AutomaticProxyFactory"
                c:type="TpAutomaticProxyFactory*"/>
        </return-value>
      </function>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="AutomaticProxyFactoryClass"
            c:type="TpAutomaticProxyFactoryClass"
            glib:is-gtype-struct-for="AutomaticProxyFactory"
            version="0.13.2">
      <doc xml:whitespace="preserve">The class of a #TpAutomaticProxyFactory.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="AvatarRequirements"
            c:type="TpAvatarRequirements"
            version="0.11.4"
            glib:type-name="TpAvatarRequirements"
            glib:get-type="tp_avatar_requirements_get_type"
            c:symbol-prefix="avatar_requirements">
      <doc xml:whitespace="preserve">The requirements for setting an avatar on a particular protocol.</doc>
      <field name="supported_mime_types" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="minimum_width" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="minimum_height" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="recommended_width" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="recommended_height" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum_width" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum_height" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum_bytes" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new"
                   c:identifier="tp_avatar_requirements_new"
                   version="0.11.4">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpAvatarRequirements, free it with tp_avatar_requirements_destroy()</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
        <parameters>
          <parameter name="supported_mime_types" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of supported MIME types (e.g. "image/jpeg") Clients MAY assume that the first type in this array is preferred</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="minimum_width" transfer-ownership="none">
            <doc xml:whitespace="preserve">The minimum width in pixels of an avatar, which MAY be 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="minimum_height" transfer-ownership="none">
            <doc xml:whitespace="preserve">The minimum height in pixels of an avatar, which MAY be 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="recommended_width" transfer-ownership="none">
            <doc xml:whitespace="preserve">The recommended width in pixels of an avatar, or 0 if there is no preferred width.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="recommended_height" transfer-ownership="none">
            <doc xml:whitespace="preserve">The recommended height in pixels of an avatar, or 0 if there is no preferred height</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_width" transfer-ownership="none">
            <doc xml:whitespace="preserve">The maximum width in pixels of an avatar on this protocol, or 0 if there is no limit.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_height" transfer-ownership="none">
            <doc xml:whitespace="preserve">The maximum height in pixels of an avatar, or 0 if there is no limit.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_bytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">he maximum size in bytes of an avatar, or 0 if there is no limit.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy"
              c:identifier="tp_avatar_requirements_copy"
              version="0.11.4"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpAvatarRequirements, free it with tp_avatar_requirements_destroy()</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
      </method>
      <method name="destroy"
              c:identifier="tp_avatar_requirements_destroy"
              version="0.11.4"
              introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #TpAvatarRequirements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <class name="BaseClient"
           c:symbol-prefix="base_client"
           c:type="TpBaseClient"
           version="0.11.5"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TpBaseClient"
           glib:get-type="tp_base_client_get_type"
           glib:type-struct="BaseClientClass">
      <doc xml:whitespace="preserve">Data structure representing a generic #TpSvcClient implementation.</doc>
      <function name="implement_add_dispatch_operation"
                c:identifier="tp_base_client_implement_add_dispatch_operation"
                version="0.11.5"
                introspectable="0">
        <doc xml:whitespace="preserve">Called by subclasses to define the actual implementation of the
AddDispatchOperation() D-Bus method.

Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.add_dispatch_operation function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClassAddDispatchOperationImpl function implementing AddDispatchOperation()</doc>
            <type name="BaseClientClassAddDispatchOperationImpl"
                  c:type="TpBaseClientClassAddDispatchOperationImpl"/>
          </parameter>
        </parameters>
      </function>
      <function name="implement_handle_channels"
                c:identifier="tp_base_client_implement_handle_channels"
                version="0.11.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Called by subclasses to define the actual implementation of the
HandleChannels() D-Bus method.

Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.handle_channels function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClassHandleChannelsImpl function implementing HandleCHannels()</doc>
            <type name="BaseClientClassHandleChannelsImpl"
                  c:type="TpBaseClientClassHandleChannelsImpl"/>
          </parameter>
        </parameters>
      </function>
      <function name="implement_observe_channels"
                c:identifier="tp_base_client_implement_observe_channels"
                version="0.11.5"
                introspectable="0">
        <doc xml:whitespace="preserve">Called by subclasses to define the actual implementation of the
ObserveChannels() D-Bus method.

Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.observe_channels function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClassObserveChannelsImpl function implementing ObserveChannels()</doc>
            <type name="BaseClientClassObserveChannelsImpl"
                  c:type="TpBaseClientClassObserveChannelsImpl"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_account_features"
              c:identifier="tp_base_client_add_account_features"
              version="0.11.14"
              deprecated="New code should use tp_simple_client_factory_add_account_features() instead.">
        <doc xml:whitespace="preserve">Request that the given features are prepared on each #TpAccount (in
addition to %TP_ACCOUNT_FEATURE_CORE) before calling
#TpBaseClientClass.observe_channels,
#TpBaseClientClass.add_dispatch_operation or
#TpBaseClientClass.handle_channels, or emitting
#TpBaseClient::request-added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">the features</doc>
            <array length="1" zero-terminated="0" c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_account_features_varargs"
              c:identifier="tp_base_client_add_account_features_varargs"
              version="0.11.14"
              introspectable="0"
              deprecated="New code should use tp_simple_client_factory_add_account_features_varargs() instead.">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_account_features(), but with a more
convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_approver_filter"
              c:identifier="tp_base_client_add_approver_filter"
              version="0.11.5">
        <doc xml:whitespace="preserve">Register a new channel class as Approver.ApproverChannelFilter.
The #TpBaseClientClass.add_dispatch_operation virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.add_dispatch_operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="add_approver_filter_vardict"
              c:identifier="tp_base_client_add_approver_filter_vardict"
              version="0.19.10">
        <doc xml:whitespace="preserve">Register a new channel class as Approver.ApproverChannelFilter.
The #TpBaseClientClass.add_dispatch_operation virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.add_dispatch_operation.

If the variant is floating (see g_variant_ref_sink()), ownership
will be taken. See tp_base_client_add_observer_filter_vardict() for
more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a variant of type %G_VARIANT_TYPE_VARDICT</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features"
              c:identifier="tp_base_client_add_channel_features"
              version="0.11.14"
              deprecated="New code should use tp_simple_client_factory_add_channel_features() instead.">
        <doc xml:whitespace="preserve">Request that the given features are prepared on each #TpChannel (in
addition to %TP_CHANNEL_FEATURE_CORE) before calling
#TpBaseClientClass.observe_channels,
#TpBaseClientClass.add_dispatch_operation or
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">the features</doc>
            <array length="1" zero-terminated="0" c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features_varargs"
              c:identifier="tp_base_client_add_channel_features_varargs"
              version="0.11.14"
              introspectable="0"
              deprecated="New code should use tp_simple_client_factory_add_channel_features_varargs() instead.">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_channel_features(), but with a more
convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features"
              c:identifier="tp_base_client_add_connection_features"
              version="0.11.14"
              deprecated="New code should use tp_simple_client_factory_add_connection_features() instead.">
        <doc xml:whitespace="preserve">Request that the given features are prepared on each #TpConnection (in
addition to %TP_CONNECTION_FEATURE_CORE) before calling
#TpBaseClientClass.observe_channels,
#TpBaseClientClass.add_dispatch_operation or
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">the features</doc>
            <array length="1" zero-terminated="0" c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features_varargs"
              c:identifier="tp_base_client_add_connection_features_varargs"
              version="0.11.14"
              introspectable="0"
              deprecated="New code should use tp_simple_client_factory_add_connection_features_varargs() instead.">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_connection_features(), but with a more
convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capabilities"
              c:identifier="tp_base_client_add_handler_capabilities"
              version="0.11.6">
        <doc xml:whitespace="preserve">Add several capability tokens to this client. These are used to signal
that Telepathy connection managers should advertise certain capabilities
to other contacts, such as the ability to receive audio/video calls using
particular streaming protocols and codecs.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tokens" transfer-ownership="none">
            <doc xml:whitespace="preserve">capability tokens as defined by the Telepathy D-Bus API Specification</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capabilities_varargs"
              c:identifier="tp_base_client_add_handler_capabilities_varargs"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Convenience C API equivalent to calling
tp_base_client_add_handler_capability() for each capability token.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a capability token from the Telepathy D-Bus API Specification</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capability"
              c:identifier="tp_base_client_add_handler_capability"
              version="0.11.6">
        <doc xml:whitespace="preserve">Add one capability token to this client, as if via
tp_base_client_add_handler_capabilities().

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a capability token as defined by the Telepathy D-Bus API Specification</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_filter"
              c:identifier="tp_base_client_add_handler_filter"
              version="0.11.6">
        <doc xml:whitespace="preserve">Register a new channel class as Handler.HandlerChannelFilter.
The #TpBaseClientClass.handle_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_filter_vardict"
              c:identifier="tp_base_client_add_handler_filter_vardict"
              version="0.19.10">
        <doc xml:whitespace="preserve">Register a new channel class as Handler.HandlerChannelFilter.
The #TpBaseClientClass.handle_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.

If the variant is floating (see g_variant_ref_sink()), ownership
will be taken. See tp_base_client_add_observer_filter_vardict() for
more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a variant of type %G_VARIANT_TYPE_VARDICT</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_observer_filter"
              c:identifier="tp_base_client_add_observer_filter"
              version="0.11.5">
        <doc xml:whitespace="preserve">Register a new channel class as Observer.ObserverChannelFilter.
The #TpBaseClientClass.observe_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="add_observer_filter_vardict"
              c:identifier="tp_base_client_add_observer_filter_vardict"
              version="0.19.10">
        <doc xml:whitespace="preserve">Register a new channel class as Observer.ObserverChannelFilter.
The #TpBaseClientClass.observe_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.

If the variant is floating (see g_variant_ref_sink()), ownership
will be taken, allowing for uses like this:

|[
tp_base_client_add_observer_filter_vardict (client,
   g_variant_new_parsed ("{ %s: &lt;%s&gt;, %s: &lt;%u&gt;, ... }",
       TP_PROP_CHANNEL_CHANNEL_TYPE, TP_IFACE_CHANNEL_TYPE_TEXT,
       TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, (guint32) TP_HANDLE_TYPE_CONTACT,
       ...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a variant of type %G_VARIANT_TYPE_VARDICT</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="be_a_handler"
              c:identifier="tp_base_client_be_a_handler"
              version="0.11.6">
        <doc xml:whitespace="preserve">Register @self as a Client.Handler with an empty list of filters.
This is useful if you want to create a client that only handle channels
for which it's the PreferredHandler.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="delegate_channels_async"
              c:identifier="tp_base_client_delegate_channels_async"
              version="0.15.0">
        <doc xml:whitespace="preserve">Asynchronously calls DelegateChannels on the ChannelDispatcher to try
stopping handling @channels and pass them to another Handler.
You can then call tp_base_client_delegate_channels_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpChannel handled by @self</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Channel"/>
            </type>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or #TP_USER_ACTION_TIME_NOT_USER_ACTION if this delegation request is for some reason not involving user action.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channels, or %NULL to indicate that any handler but @self would be acceptable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delegate_channels_finish"
              c:identifier="tp_base_client_delegate_channels_finish"
              version="0.15.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channels delegation request started using
tp_base_client_delegate_channels_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation succeed, @delegated and @not_delegated can be used to know the channels that @self is not handling any more, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="delegated"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container">
            <doc xml:whitespace="preserve">if not %NULL, used to return a #GPtrArray containing the #TpChannel&lt;!-- --&gt;s which have been properly delegated</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="Channel"/>
            </array>
          </parameter>
          <parameter name="not_delegated"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container">
            <doc xml:whitespace="preserve">if not not %NULL, used to return a #GHashTable mapping #TpChannel&lt;!-- --&gt;s which have not been delegated to a #GError explaining the reason of the failure</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="Channel"/>
              <type name="GLib.Error"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="dup_handled_channels"
              c:identifier="tp_base_client_dup_handled_channels"
              version="0.19.9">
        <doc xml:whitespace="preserve">Returns the set of channels currently handled by this base client or by any
other #TpBaseClient with which it shares a unique name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the handled channels</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </return-value>
      </method>
      <method name="dup_pending_requests"
              c:identifier="tp_base_client_dup_pending_requests"
              version="0.19.9">
        <doc xml:whitespace="preserve">Only works if tp_base_client_set_handler_request_notification() has been
called.
Returns the list of requests @self is likely be asked to handle.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
      </method>
      <method name="get_account_manager"
              c:identifier="tp_base_client_get_account_manager"
              version="0.11.14"
              introspectable="0"
              deprecated="New code should not use this function, it may return %NULL in the case @self was constructed with a #TpSimpleClientFactory.">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:account-manager construct-only property, which
is the account manager used to look up or create #TpAccount objects.

The returned object's reference count is not incremented, so it is not
necessarily valid after @self is destroyed.

It is not guaranteed that any particular features are prepared on this
object; enable and wait for features with tp_proxy_prepare_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:account-manager</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
      </method>
      <method name="get_bus_name"
              c:identifier="tp_base_client_get_bus_name"
              version="0.11.5">
        <doc xml:whitespace="preserve">Return the bus name of @self. Note that doesn't mean the client is
actually owning this name; for example if tp_base_client_register()
has not been called yet or failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the bus name of the client</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_channel_factory"
              c:identifier="tp_base_client_get_channel_factory"
              version="0.13.2"
              introspectable="0"
              deprecated="since 0.15.5. The factory is taken from #TpBaseClient:account-manager.">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:channel-factory property.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the value of #TpBaseClient:channel-factory</doc>
          <type name="ClientChannelFactory" c:type="TpClientChannelFactory*"/>
        </return-value>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_base_client_get_dbus_daemon"
              version="0.11.11">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:dbus-daemon construct-only property, which
represents the D-Bus connection used to export this client object.

The returned object's reference count is not incremented, so it is not
necessarily valid after @self is destroyed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:dbus-daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="get_handled_channels"
              c:identifier="tp_base_client_get_handled_channels"
              version="0.11.6"
              deprecated="Since 0.19.9. New code should use tp_base_client_dup_handled_channels() instead.">
        <doc xml:whitespace="preserve">Returns the set of channels currently handled by this base client or by any
other #TpBaseClient with which it shares a unique name.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">the handled channels</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </return-value>
      </method>
      <method name="get_name"
              c:identifier="tp_base_client_get_name"
              version="0.11.11">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:name construct-only property, which is used as
part of the bus name and object path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_object_path"
              c:identifier="tp_base_client_get_object_path"
              version="0.11.5">
        <doc xml:whitespace="preserve">Return the object path of @self. Note that doesn't mean the client is
actually registered on this path; for example if tp_base_client_register()
has not been called yet or failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the object path of the client</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_pending_requests"
              c:identifier="tp_base_client_get_pending_requests"
              version="0.11.6"
              deprecated="Since 0.19.9. New code should use tp_base_client_dup_pending_requests() instead.">
        <doc xml:whitespace="preserve">Only works if tp_base_client_set_handler_request_notification() has been
called.
Returns the list of requests @self is likely be asked to handle.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
      </method>
      <method name="get_uniquify_name"
              c:identifier="tp_base_client_get_uniquify_name"
              version="0.11.11">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:uniquify-name construct-only property; if this
is true, the bus name and object path will be made unique by appending
a suffix that includes the D-Bus unique name and a per-process counter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:uniquify-name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_handling_channel"
              c:identifier="tp_base_client_is_handling_channel"
              version="0.14.5">
        <doc xml:whitespace="preserve">Check if @self is currently handling @channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @self is handling @channel, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register"
              c:identifier="tp_base_client_register"
              version="0.11.5"
              throws="1">
        <doc xml:whitespace="preserve">Publish @self as an available client. After this method is called, as long
as it continues to exist, it will receive and process whatever events were
requested via the various filters.

Methods that set the filters and other immutable state, such as
tp_base_client_add_observer_filter(), cannot be called after this one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the client was registered successfully</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_channel_factory"
              c:identifier="tp_base_client_set_channel_factory"
              version="0.13.2"
              deprecated="since 0.15.5. The factory is taken from #TpBaseClient:account-manager.">
        <doc xml:whitespace="preserve">Change the value of the #TpBaseClient:channel-factory property.
It can't be changed once @self has been registered.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object implementing the #TpClientChannelFactoryInterface interface</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delegated_channels_callback"
              c:identifier="tp_base_client_set_delegated_channels_callback"
              version="0.15.3">
        <doc xml:whitespace="preserve">Turn on support for
the org.freedesktop.Telepathy.ChannelRequest.DelegateToPreferredHandler
hint.

When receiving a request containing this hint, @self will automatically
delegate the channels to the preferred handler of the request and then call
@callback to inform the client that it is no longer handling those
channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">function called when channels currently handled by @self are delegated, may not be %NULL</doc>
            <type name="BaseClientDelegatedChannelsCb"
                  c:type="TpBaseClientDelegatedChannelsCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the @user_data as argument, when @self is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handler_bypass_approval"
              c:identifier="tp_base_client_set_handler_bypass_approval"
              version="0.11.6">
        <doc xml:whitespace="preserve">Set whether the channels destined for this handler are automatically
handled, without invoking approvers.
(This is implemented by setting the value of its BypassApproval
D-Bus property.)

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handler_request_notification"
              c:identifier="tp_base_client_set_handler_request_notification"
              version="0.11.6">
        <doc xml:whitespace="preserve">Indicate that @self is a Handler willing to be notified about requests for
channels that it is likely to be asked to handle. This means that the
#TpBaseClient::request-added and #TpBaseClient::request-removed signals will
be fired and tp_base_client_get_pending_requests() will return the list of
pending requests.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_observer_delay_approvers"
              c:identifier="tp_base_client_set_observer_delay_approvers"
              version="0.13.16">
        <doc xml:whitespace="preserve">Set whether the channel dispatcher should wait for
tp_observe_channels_context_accept() or tp_observe_channels_context_fail()
to be called before calling
#TpBaseClientClass.add_dispatch_operation on appropriate Approvers.

This is implemented by setting the value of the DelayApprovers
D-Bus property.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delay" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.DelayApprovers property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_observer_recover"
              c:identifier="tp_base_client_set_observer_recover"
              version="0.11.5">
        <doc xml:whitespace="preserve">Set whether the channel dispatcher should attempt to recover
this Observer if it crashes. (This is implemented by setting
the value of its Recover D-Bus property.)

Normally, Observers are only notified when new channels
appear. If an Observer is set to recover, when it registers with
tp_base_client_register(), it will also be told about any channels
that already existed before it started.

For Observers that are activatable as a D-Bus service, if the
Observer exits or crashes while there are any channels that match
its filter, it will automatically be restarted by service-activation.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_approver_filter"
              c:identifier="tp_base_client_take_approver_filter"
              version="0.11.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_approver_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():

|[
tp_base_client_take_approver_filter (client,
   tp_asv_new (
       TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
           TP_IFACE_CHANNEL_TYPE_TEXT,
       TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
           TP_HANDLE_TYPE_CONTACT,
       ...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="take_handler_filter"
              c:identifier="tp_base_client_take_handler_filter"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_handler_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():

|[
tp_base_client_take_handler_filter (client,
   tp_asv_new (
       TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
           TP_IFACE_CHANNEL_TYPE_TEXT,
       TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
           TP_HANDLE_TYPE_CONTACT,
       ...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="take_observer_filter"
              c:identifier="tp_base_client_take_observer_filter"
              version="0.11.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_observer_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():

|[
tp_base_client_take_observer_filter (client,
   tp_asv_new (
       TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
           TP_IFACE_CHANNEL_TYPE_TEXT,
       TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
           TP_HANDLE_TYPE_CONTACT,
       ...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="unregister"
              c:identifier="tp_base_client_unregister"
              version="0.11.6">
        <doc xml:whitespace="preserve">Remove this client object from D-Bus, if tp_base_client_register()
has already been called.

If the object is not registered, this method may be called, but has
no effect.

Releasing the last reference to the object also has the same effect
as calling this method, but this method should be preferred, as it
has more deterministic behaviour.

If the object still exists, tp_base_client_register() may be used to
attempt to register it again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="account-manager"
                version="0.11.14"
                deprecated="New code should not use this property, it may be %NULL in the case @self was constructed with a #TpSimpleClientFactory."
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Account manager for this base client, used to look up or create
#TpAccount objects. This may be specified in the constructor in order
to get existing #TpAccount objects.

It is not guaranteed that any of its features have been prepared, and
it is not necessary to wait for any features before specifying this
property in the constructor.

Clients that interact with the #TpAccount should usually
set this property instead of #TpBaseClient:dbus-daemon. Doing this
will ensure that each account, connection or contact is represented by
a single #TpAccount, #TpConnection or #TpContact object, shared between
all the cooperating modules that have the same #TpAccountManager.

If the #TpBaseClient:dbus-daemon is set to the result of
tp_dbus_daemon_dup(), then this property defaults to
the result of tp_account_manager_dup().

This property may be %NULL initially, but will always be non-%NULL
after the #TpBaseClient has been constructed.

It is an error to specify both a non-%NULL account manager, and a
non-%NULL #TpBaseClient:dbus-daemon that is not the same as the
account manager's #TpProxy:dbus-daemon.</doc>
        <type name="AccountManager"/>
      </property>
      <property name="channel-factory"
                version="0.13.2"
                deprecated="since 0.15.5. The factory is taken from #TpBaseClient:account-manager."
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The object implementing the #TpClientChannelFactoryInterface interface
that will be used to create channel proxies. While
tp_base_client_register() has not yet been called, this property can be
changed using tp_base_client_set_channel_factory().

If no channel factory is specified then #TpAutomaticProxyFactory is used.</doc>
        <type name="GObject.Object"/>
      </property>
      <property name="dbus-daemon"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">#TpDBusDaemon object encapsulating this object's connection to D-Bus.
Read-only except during construction.

This property can't be %NULL after construction.

Since 0.11.14 this property may be %NULL or unspecified in
g_object_new(), but only if #TpBaseClient:account-manager is provided
instead, in which case its #TpProxy:dbus-daemon property will be
used.</doc>
        <type name="DBusDaemon"/>
      </property>
      <property name="factory"
                version="0.15.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Factory for this base client, used to look up or create
#TpAccount objects.</doc>
        <type name="SimpleClientFactory"/>
      </property>
      <property name="name"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the client. This is used to register the D-Bus service name
and object path of the service.

This property can't be %NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="uniquify-name"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, tp_base_client_register() will append an unique token to the
service bus name and object path to ensure they are unique.</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseClientPrivate" c:type="TpBaseClientPrivate*"/>
      </field>
      <glib:signal name="request-added"
                   when="last"
                   detailed="1"
                   version="0.11.6">
        <doc xml:whitespace="preserve">Emitted when a channels have been requested, and that if the
request is successful, they will probably be handled by this Handler.

This signal is only fired if
tp_base_client_set_handler_request_notification() has been called
on @self previously.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccount on which the request was made, with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features() or tp_simple_client_factory_add_account_features(), prepared if possible</doc>
            <type name="Account"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannelRequest having its object-path defined but is not guaranteed to be prepared.</doc>
            <type name="ChannelRequest"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-removed"
                   when="last"
                   detailed="1"
                   version="0.11.6">
        <doc xml:whitespace="preserve">Emitted when a request has failed and should be disregarded.

This signal is only fired if
tp_base_client_set_handler_request_notification() has been called
on @self previously.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannelRequest being removed</doc>
            <type name="ChannelRequest"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the D-Bus error with which the request failed.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">any message supplied with the D-Bus error.</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BaseClientClass"
            c:type="TpBaseClientClass"
            glib:is-gtype-struct-for="BaseClient"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpBaseClient.

The virtual methods @observe_channels, @add_dispatch_operation and
@handle_channels can be also implemented by calling
tp_base_client_implement_observe_channels(),
tp_base_client_implement_add_dispatch_operation() and
tp_base_client_implement_handle_channels(). This is compatible with
telepathy-glib versions older than 0.11.13.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="observe_channels">
        <type name="BaseClientClassObserveChannelsImpl"
              c:type="TpBaseClientClassObserveChannelsImpl"/>
      </field>
      <field name="add_dispatch_operation">
        <type name="BaseClientClassAddDispatchOperationImpl"
              c:type="TpBaseClientClassAddDispatchOperationImpl"/>
      </field>
      <field name="handle_channels">
        <type name="BaseClientClassHandleChannelsImpl"
              c:type="TpBaseClientClassHandleChannelsImpl"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="4">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="dbus_properties_class"
             introspectable="0"
             readable="0"
             private="1">
        <type c:type="TpDBusPropertiesMixinClass"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseClientClassPrivate"
              c:type="TpBaseClientClassPrivate*"/>
      </field>
    </record>
    <callback name="BaseClientClassAddDispatchOperationImpl"
              c:type="TpBaseClientClassAddDispatchOperationImpl"
              version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the AddDispatchOperation method.

This function must call either tp_add_dispatch_operation_context_accept(),
tp_add_dispatch_operation_context_delay() or
tp_add_dispatch_operation_context_fail() on @context before it returns.

The implementation can then use
tp_channel_dispatch_operation_handle_with_async() to approve handling of the
channels, or tp_channel_dispatch_operation_claim_async() to take
responsibility for handling or closing them".</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features() or tp_simple_client_factory_add_account_features(), prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE, and any other features added via tp_base_client_add_connection_features(), or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, each with %TP_CHANNEL_FEATURE_CORE, and any other features added via tp_base_client_add_channel_features() or tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation having %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE prepared if possible</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpObserveChannelsContext representing the context of this D-Bus call</doc>
          <type name="AddDispatchOperationContext"
                c:type="TpAddDispatchOperationContext*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseClientClassHandleChannelsImpl"
              c:type="TpBaseClientClassHandleChannelsImpl"
              version="0.11.6">
      <doc xml:whitespace="preserve">Signature of the implementation of the HandleChannels method.

This function must call either tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features() or tp_simple_client_factory_add_account_features(), prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE, and any other features added via tp_base_client_add_connection_features(), or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, each with %TP_CHANNEL_FEATURE_CORE, and any other features added via tp_base_client_add_channel_features() or tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="requests_satisfied" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time for details)</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpHandleChannelsContext representing the context of this D-Bus call</doc>
          <type name="HandleChannelsContext"
                c:type="TpHandleChannelsContext*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseClientClassObserveChannelsImpl"
              c:type="TpBaseClientClassObserveChannelsImpl"
              version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the ObserveChannels method.

This function must call either tp_observe_channels_context_accept(),
tp_observe_channels_context_delay() or tp_observe_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features() or tp_simple_client_factory_add_account_features(), prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE, and any other features added via tp_base_client_add_connection_features(), or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, each with %TP_CHANNEL_FEATURE_CORE, and any other features added via tp_base_client_add_channel_features() or tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation or %NULL; the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="requests" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpObserveChannelsContext representing the context of this D-Bus call</doc>
          <type name="ObserveChannelsContext"
                c:type="TpObserveChannelsContext*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseClientClassPrivate"
            c:type="TpBaseClientClassPrivate"
            disguised="1">
    </record>
    <callback name="BaseClientDelegatedChannelsCb"
              c:type="TpBaseClientDelegatedChannelsCb"
              version="0.15.3">
      <doc xml:whitespace="preserve">Called when a client asked us to delegate @channels to another Handler.
When this function is called @client is not longer handling @channels.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GPtrArray of #TpChannel</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Channel"/>
          </array>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_base_client_set_delegated_channels_callback()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseClientPrivate"
            c:type="TpBaseClientPrivate"
            disguised="1">
    </record>
    <class name="BaseConnection"
           c:symbol-prefix="base_connection"
           c:type="TpBaseConnection"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TpBaseConnection"
           glib:get-type="tp_base_connection_get_type"
           glib:type-struct="BaseConnectionClass">
      <doc xml:whitespace="preserve">Data structure representing a generic #TpSvcConnection implementation.

Since 0.19.1, accessing the fields of this structure is deprecated.
Use tp_base_connection_get_bus_name(), tp_base_connection_get_object_path(),
tp_base_connection_get_status(), tp_base_connection_get_self_handle()
instead.</doc>
      <function name="channel_manager_iter_init"
                c:identifier="tp_base_connection_channel_manager_iter_init"
                version="0.7.15"
                introspectable="0">
        <doc xml:whitespace="preserve">Initializes an iterator over the #TpChannelManager objects known to
@self.  It is intended to be used as followed:

&lt;informalexample&gt;&lt;programlisting&gt;
TpChannelManagerIter iter;
TpChannelManager *manager;

tp_base_connection_channel_manager_iter_init (&amp;amp;iter, base_conn);
while (tp_base_connection_channel_manager_iter_next (&amp;amp;iter, &amp;amp;manager))
  {
    ...do something with manager...
  }
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:whitespace="preserve">an uninitialized #TpChannelManagerIter</doc>
            <type name="ChannelManagerIter" c:type="TpChannelManagerIter*"/>
          </parameter>
          <parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </parameter>
        </parameters>
      </function>
      <function name="channel_manager_iter_next"
                c:identifier="tp_base_connection_channel_manager_iter_next"
                version="0.7.15"
                introspectable="0">
        <doc xml:whitespace="preserve">Advances @iter, and retrieves the #TpChannelManager it now points to.  If
there are no more channel managers, @manager_out is not set and %FALSE is
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE if there are no more channel managers; else %TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:whitespace="preserve">an initialized #TpChannelManagerIter</doc>
            <type name="ChannelManagerIter" c:type="TpChannelManagerIter*"/>
          </parameter>
          <parameter name="manager_out" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the channel manager, or %NULL.</doc>
            <type c:type="TpChannelManager**"/>
          </parameter>
        </parameters>
      </function>
      <function name="dbus_request_handles"
                c:identifier="tp_base_connection_dbus_request_handles"
                introspectable="0"
                deprecated="0.19.0">
        <doc xml:whitespace="preserve">Implements D-Bus method RequestHandles on interface
org.freedesktop.Telepathy.Connection.

This was exported so subclasses could use it as a basis for their
reimplementations, but reimplementing the method is now deprecated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to #TpBaseConnection, cast to a pointer to #TpSvcConnection</doc>
            <type c:type="TpSvcConnection*"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle type (#TpHandleType) as a guint</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:whitespace="preserve">A strv of handle names</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:whitespace="preserve">The dbus-glib method invocation context</doc>
            <type c:type="DBusGMethodInvocation*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_client_interest"
              c:identifier="tp_base_connection_add_client_interest">
        <doc xml:whitespace="preserve">Add a "client interest" for @token on behalf of the given client.

This emits #TpBaseConnection::clients-interested if this was the first
time a client expressed an interest in this token.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="unique_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the unique bus name of a D-Bus client</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus interface or a token representing part of an interface, added with tp_base_connection_add_possible_client_interest()</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="only_if_uninterested" transfer-ownership="none">
            <doc xml:whitespace="preserve">only add to the interest count if the client is not already interested (appropriate for APIs that implicitly subscribe on first use if this has not been done already, like Location)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_interfaces"
              c:identifier="tp_base_connection_add_interfaces"
              introspectable="0">
        <doc xml:whitespace="preserve">Add some interfaces to the list supported by this Connection. If you're
going to call this function at all, you must do so before moving to state
CONNECTED (or DISCONNECTED); if you don't call it, only the set of
interfaces always present (@get_interfaces_always_present in
#TpBaseConnectionClass) will be supported.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">A %NULL-terminated array of D-Bus interface names, which must remain valid at least until the connection enters state #TP_CONNECTION_STATUS_DISCONNECTED (in practice, you should either use static strings, or use strdup'd strings and free them in the dispose callback).</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_possible_client_interest"
              c:identifier="tp_base_connection_add_possible_client_interest">
        <doc xml:whitespace="preserve">Add @token to the set of tokens for which this connection will emit
#TpBaseConnection::clients-interested and
#TpBaseConnection::clients-uninterested.

This method must be called from the #GObjectClass&lt;!--
--&gt;.constructed or #GObjectClass&lt;!-- --&gt;.constructor callback
(otherwise, it will run too late to be useful).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a quark corresponding to a D-Bus interface, or a token representing part of a D-Bus interface, for which this connection wishes to be notified when clients register an interest</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_status"
              c:identifier="tp_base_connection_change_status">
        <doc xml:whitespace="preserve">Change the status of the connection. The allowed state transitions are:

&lt;itemizedlist&gt;
&lt;listitem&gt;#TP_INTERNAL_CONNECTION_STATUS_NEW →
   #TP_CONNECTION_STATUS_CONNECTING&lt;/listitem&gt;
&lt;listitem&gt;#TP_CONNECTION_STATUS_CONNECTING →
   #TP_CONNECTION_STATUS_CONNECTED&lt;/listitem&gt;
&lt;listitem&gt;#TP_INTERNAL_CONNECTION_STATUS_NEW →
   #TP_CONNECTION_STATUS_CONNECTED (exactly equivalent to both of the above
   one after the other; see below)&lt;/listitem&gt;
&lt;listitem&gt;anything except #TP_CONNECTION_STATUS_DISCONNECTED →
   #TP_CONNECTION_STATUS_DISCONNECTED&lt;/listitem&gt;
&lt;/itemizedlist&gt;

Before the transition to #TP_CONNECTION_STATUS_CONNECTED, the implementation
must have discovered the handle for the local user and passed it to
tp_base_connection_set_self_handle().

Changing from NEW to CONNECTED is implemented by doing the transition from
NEW to CONNECTING, followed by the transition from CONNECTING to CONNECTED;
it's exactly equivalent to calling tp_base_connection_change_status for
those two transitions one after the other.

Any other valid transition does the following, in this order:

&lt;itemizedlist&gt;
&lt;listitem&gt;Update #TpBaseConnection&lt;!-- --&gt;.status;&lt;/listitem&gt;
&lt;listitem&gt;If the new state is #TP_CONNECTION_STATUS_DISCONNECTED, call
   tp_channel_factory_iface_close_all() on all channel factories&lt;/listitem&gt;
&lt;listitem&gt;Emit the D-Bus StatusChanged signal;&lt;/listitem&gt;
&lt;listitem&gt;Call #TpBaseConnectionClass.connecting,
   #TpBaseConnectionClass.connected or #TpBaseConnectionClass.disconnected
   as appropriate;&lt;/listitem&gt;
&lt;listitem&gt;Call the channel factories' status change callbacks;&lt;/listitem&gt;
&lt;listitem&gt;If the new state is #TP_CONNECTION_STATUS_DISCONNECTED, call the
   subclass' #TpBaseConnectionClass.shut_down callback.&lt;/listitem&gt;
&lt;/itemizedlist&gt;

To provide more details about what happened when moving to @status
#TP_CONNECTION_STATUS_DISCONNECTED due to an error, consider calling
tp_base_connection_disconnect_with_dbus_error() instead of this function.

Changed in 0.7.35: the @self_handle member of #TpBaseConnection was
previously set to 0 at this stage. It now remains non-zero until the object
is disposed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new status</doc>
            <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">The reason for the status change</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connected"
              c:identifier="tp_base_connection_check_connected"
              version="0.19.1"
              throws="1">
        <doc xml:whitespace="preserve">Return whether this connection is fully active and connected.
If it is not, raise %TP_ERROR_DISCONNECTED.

This is equivalent to checking whether tp_base_connection_get_status()
returns %TP_CONNECTION_STATUS_CONNECTED; it is provided because methods
on the connection often need to make this check, and return a
#GError if it fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this connection is connected</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="disconnect_with_dbus_error"
              c:identifier="tp_base_connection_disconnect_with_dbus_error"
              version="0.7.24"
              introspectable="0">
        <doc xml:whitespace="preserve">Changes the #TpBaseConnection&lt;!-- --&gt;.status of @self to
%TP_CONNECTION_STATUS_DISCONNECTED, as if by a call to
tp_base_connection_change_status(), but additionally emits the
&lt;code&gt;ConnectionError&lt;/code&gt; D-Bus signal to provide more details about the
error.

Well-known keys for @details are documented in the Telepathy specification's
&lt;ulink url='http://telepathy.freedesktop.org/spec/Connection.html#Signal:ConnectionError'&gt;definition
of the ConnectionError signal&lt;/ulink&gt;, and include:

&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;code&gt;"debug-message"&lt;/code&gt;, whose value should have type
   #G_TYPE_STRING, for debugging information about the
   disconnection which should not be shown to the user&lt;/listitem&gt;
&lt;listitem&gt;&lt;code&gt;"server-message"&lt;/code&gt;, whose value should also have type
   #G_TYPE_STRING, for a human-readable error message from the server (in an
   unspecified language) explaining why the user was
   disconnected.&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The D-Bus error with which the connection changed status to Disconnected</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">Further details of the error, as a hash table where the keys are strings as defined in the Telepathy specification, and the values are #GValue&lt;!-- --&gt;s. %NULL is allowed, and treated as an empty hash table.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">The reason code to use in the StatusChanged signal (a less specific, non-extensible version of @error_name)</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_with_dbus_error_vardict"
              c:identifier="tp_base_connection_disconnect_with_dbus_error_vardict"
              version="0.7.24"
              introspectable="0">
        <doc xml:whitespace="preserve">Changes the #TpBaseConnection&lt;!-- --&gt;.status of @self to
%TP_CONNECTION_STATUS_DISCONNECTED, as if by a call to
tp_base_connection_change_status(), but additionally emits the
&lt;code&gt;ConnectionError&lt;/code&gt; D-Bus signal to provide more details about the
error.

Well-known keys for @details are documented in the Telepathy specification's
&lt;ulink url='http://telepathy.freedesktop.org/spec/Connection.html#Signal:ConnectionError'&gt;definition
of the ConnectionError signal&lt;/ulink&gt;, and include:

&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;code&gt;"debug-message"&lt;/code&gt;, whose value should have type
   #G_TYPE_STRING, for debugging information about the
   disconnection which should not be shown to the user&lt;/listitem&gt;
&lt;listitem&gt;&lt;code&gt;"server-message"&lt;/code&gt;, whose value should also have type
   #G_TYPE_STRING, for a human-readable error message from the server (in an
   unspecified language) explaining why the user was
   disconnected.&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The D-Bus error with which the connection changed status to Disconnected</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">Further details of the error, as a variant of type %G_VARIANT_TYPE_VARDICT. The keys are strings as defined in the Telepathy specification, and the values are of type %G_VARIANT_TYPE_VARIANT. %NULL is allowed, and treated as an empty dictionary.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">The reason code to use in the StatusChanged signal (a less specific, non-extensible version of @error_name)</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish_shutdown"
              c:identifier="tp_base_connection_finish_shutdown"
              introspectable="0">
        <doc xml:whitespace="preserve">Tell the connection manager that this Connection has been disconnected,
has emitted StatusChanged and is ready to be removed from D-Bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_bus_name"
              c:identifier="tp_base_connection_get_bus_name"
              version="0.19.1">
        <doc xml:whitespace="preserve">Return the bus name starting with %TP_CONN_BUS_NAME_BASE that represents
this connection on D-Bus.

The returned string belongs to the #TpBaseConnection and must be copied
by the caller if it will be kept.

If this connection has never been present on D-Bus
(tp_base_connection_register() has never been called), return %NULL
instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the bus name of this connection, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_base_connection_get_dbus_daemon"
              version="0.11.3"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpBaseConnectionManager:dbus-daemon property. The caller must reference the returned object with g_object_ref() if it will be kept.</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="get_handles" c:identifier="tp_base_connection_get_handles">
        <doc xml:whitespace="preserve">&lt;!----&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle repository corresponding to the given handle type, or #NULL if it's unsupported or invalid.</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_object_path"
              c:identifier="tp_base_connection_get_object_path"
              version="0.19.1">
        <doc xml:whitespace="preserve">Return the object path starting with %TP_CONN_OBJECT_PATH_BASE that
represents this connection on D-Bus.

The returned string belongs to the #TpBaseConnection and must be copied
by the caller if it will be kept.

If this connection has never been present on D-Bus
(tp_base_connection_register() has never been called), return %NULL
instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the object path of this connection, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_self_handle"
              c:identifier="tp_base_connection_get_self_handle"
              version="0.7.15"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns the #TpBaseConnection:self-handle property, which is guaranteed not
to be 0 once the connection has moved to the CONNECTED state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current self handle of the connection.</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_status"
              c:identifier="tp_base_connection_get_status"
              version="0.19.1">
        <doc xml:whitespace="preserve">Return the status of this connection, as set by
tp_base_connection_change_status() or similar functions like
tp_base_connection_disconnect_with_dbus_error().

Like the corresponding D-Bus property, this method returns
%TP_CONNECTION_STATUS_DISCONNECTED in two situations:
either the connection is newly-created (and has never emitted
#TpSvcConnection::status-changed), or D-Bus clients have already been
told that it has been destroyed (by the Disconnect D-Bus method,
a failed attempt to connect, or loss of an established connection).
Use tp_base_connection_is_destroyed() to distinguish between the two.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseConnection:dbus-status</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
      </method>
      <method name="is_destroyed"
              c:identifier="tp_base_connection_is_destroyed"
              version="0.19.1">
        <doc xml:whitespace="preserve">Return whether this connection has already emitted the D-Bus signal
indicating that it has been destroyed.

In particular, this can be used to distinguish between the two reasons
why tp_base_connection_get_status() would return
%TP_CONNECTION_STATUS_DISCONNECTED: it will return %FALSE if the
connection is newly-created, and %TRUE if the Disconnect D-Bus method
has been called, an attempt to connect has failed, or an established
connection has encountered an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this connection is disappearing from D-Bus</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="register"
              c:identifier="tp_base_connection_register"
              throws="1">
        <doc xml:whitespace="preserve">Make the connection object appear on the bus, returning the bus
name and object path used. If %TRUE is returned, the connection owns the
bus name, and will release it when destroyed.

Since 0.11.11, @bus_name and @object_path may be %NULL if the
strings are not needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cm_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the connection manager in the Telepathy protocol</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="bus_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Used to return the bus name corresponding to the connection if %TRUE is returned. To be freed by the caller.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="object_path"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Used to return the object path of the connection if %TRUE is returned. To be freed by the caller.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_with_contacts_mixin"
              c:identifier="tp_base_connection_register_with_contacts_mixin"
              introspectable="0">
        <doc xml:whitespace="preserve">Register the Connection interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_self_handle"
              c:identifier="tp_base_connection_set_self_handle"
              version="0.7.15">
        <doc xml:whitespace="preserve">Sets the #TpBaseConnection:self-handle property.  self_handle may not be 0
once the connection has moved to the CONNECTED state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="self_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new self handle for the connection.</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <property name="dbus-daemon"
                version="0.11.3"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">#TpDBusDaemon object encapsulating this object's connection to D-Bus.
Read-only except during construction.

If this property is %NULL or omitted during construction, the object will
automatically attempt to connect to the starter or session bus with
tp_dbus_daemon_dup() just after it is constructed; if this fails, this
property will remain %NULL, and tp_base_connection_register() will fail.</doc>
        <type name="DBusDaemon"/>
      </property>
      <property name="dbus-status"
                version="0.11.3"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The Connection.Status as visible on D-Bus, which is the same as
#TpBaseConnection&lt;!-- --&gt;.status except that
%TP_INTERNAL_CONNECTION_STATUS_NEW is replaced by
%TP_CONNECTION_STATUS_DISCONNECTED.

The #GObject::notify signal is not currently emitted for this property.</doc>
        <type name="guint"/>
      </property>
      <property name="has-immortal-handles"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">This property is not useful to use directly. Its value is %TRUE, to
indicate that this version of telepathy-glib never unreferences handles
until the connection becomes disconnected.</doc>
        <type name="gboolean"/>
      </property>
      <property name="interfaces"
                version="0.11.3"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The set of D-Bus interfaces available on this Connection, other than
Connection itself.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="protocol"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Identifier used in the Telepathy protocol when this connection's protocol
name is required.</doc>
        <type name="utf8"/>
      </property>
      <property name="self-handle"
                version="0.7.15"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The handle of type %TP_HANDLE_TYPE_CONTACT representing the local user.
Must be set nonzero by the subclass before moving to state CONNECTED.</doc>
        <type name="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="bus_name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="object_path" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="status" readable="0" private="1">
        <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
      </field>
      <field name="self_handle" readable="0" private="1">
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseConnectionPrivate" c:type="TpBaseConnectionPrivate*"/>
      </field>
      <glib:signal name="clients-interested" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when a client becomes interested in any token that was added with
tp_base_connection_add_possible_client_interest().

The "signal detail" is a GQuark representing @token. Modules implementing
an interface (Location, say) should typically connect to a detailed signal
like
"clients-interested::org.freedesktop.Telepathy.Connection.Interface.Location"
rather than receiving all emissions of this signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">the interface or part of an interface in which clients are newly interested</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="clients-uninterested" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when no more clients are interested in an interface added with
tp_base_connection_add_possible_client_interest(), for which
#TpBaseConnection::clients-interested was previously emitted.

As with #TpBaseConnection::clients-interested, the "signal detail" is a
GQuark representing @token. Modules implementing an interface (Location,
say) should typically connect to a detailed signal like
"clients-uninterested::org.freedesktop.Telepathy.Connection.Interface.Location"
rather than receiving all emissions of this signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">the interface or part of an interface in which clients are no longer interested</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="shutdown-finished"
                   when="last"
                   detailed="1"
                   introspectable="0">
        <doc xml:whitespace="preserve">Emitted by tp_base_connection_finish_shutdown() when the underlying
network connection has been closed; #TpBaseConnectionManager listens
for this signal and removes connections from its table of active
connections when it is received.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="BaseConnectionClass"
            c:type="TpBaseConnectionClass"
            glib:is-gtype-struct-for="BaseConnection">
      <doc xml:whitespace="preserve">The class of a #TpBaseConnection. Many members are virtual methods etc.
to be filled in in the subclass' class_init function.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_internal_create_handle_repos" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="create_channel_factories">
        <type name="BaseConnectionCreateChannelFactoriesImpl"
              c:type="TpBaseConnectionCreateChannelFactoriesImpl"/>
      </field>
      <field name="get_unique_connection_name">
        <type name="BaseConnectionGetUniqueConnectionNameImpl"
              c:type="TpBaseConnectionGetUniqueConnectionNameImpl"/>
      </field>
      <field name="connecting">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="connected">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="disconnected">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="shut_down">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="start_connecting">
        <type name="BaseConnectionStartConnectingImpl"
              c:type="TpBaseConnectionStartConnectingImpl"/>
      </field>
      <field name="interfaces_always_present" readable="0" private="1">
        <type name="utf8" c:type="const gchar**"/>
      </field>
      <field name="create_channel_managers">
        <type name="BaseConnectionCreateChannelManagersImpl"
              c:type="TpBaseConnectionCreateChannelManagersImpl"/>
      </field>
      <field name="get_interfaces_always_present">
        <type name="BaseConnectionGetInterfacesImpl"
              c:type="TpBaseConnectionGetInterfacesImpl"/>
      </field>
      <field name="_future3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <callback name="BaseConnectionCreateChannelFactoriesImpl"
              c:type="TpBaseConnectionCreateChannelFactoriesImpl">
      <doc xml:whitespace="preserve">Signature of an implementation of the create_channel_factories method
of #TpBaseConnection.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a GPtrArray of objects implementing #TpChannelFactoryIface which, between them, implement all channel types this Connection supports.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionCreateChannelManagersImpl"
              c:type="TpBaseConnectionCreateChannelManagersImpl">
      <doc xml:whitespace="preserve">Signature of an implementation of the create_channel_managers method
of #TpBaseConnection.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a GPtrArray of objects implementing #TpChannelManager which, between them, implement all channel types this Connection supports.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionCreateHandleReposImpl"
              c:type="TpBaseConnectionCreateHandleReposImpl"
              introspectable="0">
      <doc xml:whitespace="preserve">Signature of an implementation of the create_handle_repos method
of #TpBaseConnection.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
        <parameter name="repos" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of pointers to be filled in; the implementation may assume all are initially NULL.</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionGetInterfacesImpl"
              c:type="TpBaseConnectionGetInterfacesImpl"
              version="0.19.4">
      <doc xml:whitespace="preserve">Signature of an implementation of
#TpBaseConnectionClass.get_interfaces_always_present virtual
function.

Implementation must first chainup on parent class implementation and then
add extra interfaces into the #GPtrArray.

|[
static GPtrArray *
my_connection_get_interfaces_always_present (TpBaseConnection *self)
{
  GPtrArray *interfaces;

  interfaces = TP_BASE_CONNECTION_CLASS (
      my_connection_parent_class)-&gt;get_interfaces_always_present (self);

  g_ptr_array_add (interfaces, TP_IFACE_BADGERS);

  return interfaces;
}
]|</doc>
      <return-value transfer-ownership="container">
        <doc xml:whitespace="preserve">a #GPtrArray of static strings for D-Bus interfaces implemented by this client.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionGetUniqueConnectionNameImpl"
              c:type="TpBaseConnectionGetUniqueConnectionNameImpl">
      <doc xml:whitespace="preserve">Signature of the @get_unique_connection_name virtual method
on #TpBaseConnection.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a name for this connection which will be unique within this connection manager process, as a string which the caller must free with #g_free.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseConnectionPrivate"
            c:type="TpBaseConnectionPrivate"
            disguised="1">
    </record>
    <callback name="BaseConnectionProc" c:type="TpBaseConnectionProc">
      <doc xml:whitespace="preserve">Signature of a virtual method on #TpBaseConnection that takes no
additional parameters and returns nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionStartConnectingImpl"
              c:type="TpBaseConnectionStartConnectingImpl"
              throws="1">
      <doc xml:whitespace="preserve">Signature of an implementation of the start_connecting method
of #TpBaseConnection.

On entry, the implementation may assume that it is in state NEW.

If %TRUE is returned, the Connect D-Bus method succeeds; the
implementation must either have already set the status to CONNECTED by
calling tp_base_connection_change_status(), or have arranged for a
status change to either state DISCONNECTED or CONNECTED to be signalled by
calling tp_base_connection_change_status() at some later time.
If the status is still NEW after returning %TRUE, #TpBaseConnection will
automatically change it to CONNECTING for reason REQUESTED.

If %FALSE is returned, the error will be raised from Connect as an
exception. If the status is not DISCONNECTED after %FALSE is returned,
#TpBaseConnection will automatically change it to DISCONNECTED
with a reason appropriate to the error; NetworkError results in
NETWORK_ERROR, PermissionDenied results in AUTHENTICATION_FAILED, and all
other errors currently result in NONE_SPECIFIED.

All except the simplest connection managers are expected to implement this
asynchronously, returning %TRUE in most cases and changing the status
to CONNECTED or DISCONNECTED later.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE if failure has already occurred, else %TRUE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="BasicProxyFactory"
           c:symbol-prefix="basic_proxy_factory"
           c:type="TpBasicProxyFactory"
           version="0.13.2"
           parent="GObject.Object"
           glib:type-name="TpBasicProxyFactory"
           glib:get-type="tp_basic_proxy_factory_get_type"
           glib:type-struct="BasicProxyFactoryClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpBasicProxyFactory</doc>
      <implements name="ClientChannelFactory"/>
      <constructor name="new"
                   c:identifier="tp_basic_proxy_factory_new"
                   version="0.13.2"
                   deprecated="New code should use #TpSimpleClientFactory instead">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpBasicProxyFactory instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpBasicProxyFactory</doc>
          <type name="BasicProxyFactory" c:type="TpBasicProxyFactory*"/>
        </return-value>
      </constructor>
      <function name="dup"
                c:identifier="tp_basic_proxy_factory_dup"
                version="0.13.2"
                deprecated="New code should use #TpSimpleClientFactory instead">
        <doc xml:whitespace="preserve">Returns a cached #TpBasicProxyFactory; the same #TpBasicProxyFactory object
will be returned by this function repeatedly, as long as at least one
reference exists.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #TpBasicProxyFactory</doc>
          <type name="BasicProxyFactory" c:type="TpBasicProxyFactory*"/>
        </return-value>
      </function>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="BasicProxyFactoryClass"
            c:type="TpBasicProxyFactoryClass"
            glib:is-gtype-struct-for="BasicProxyFactory"
            version="0.13.2">
      <doc xml:whitespace="preserve">The class of a #TpBasicProxyFactory.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <constant name="CHANNEL_DISPATCHER_BUS_NAME"
              value="org.freedesktop.Telepathy.ChannelDispatcher"
              c:type="TP_CHANNEL_DISPATCHER_BUS_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CHANNEL_DISPATCHER_OBJECT_PATH"
              value="/org/freedesktop/Telepathy/ChannelDispatcher"
              c:type="TP_CHANNEL_DISPATCHER_OBJECT_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_BUS_NAME_BASE"
              value="org.freedesktop.Telepathy.Client."
              c:type="TP_CLIENT_BUS_NAME_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/Client/"
              c:type="TP_CLIENT_OBJECT_PATH_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="CMInfoSource" version="0.7.1" c:type="TpCMInfoSource">
      <doc xml:whitespace="preserve">Describes possible sources of information on connection managers'
supported protocols.

Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_CM_INFO_SOURCE.</doc>
      <member name="none" value="0" c:identifier="TP_CM_INFO_SOURCE_NONE"/>
      <member name="file" value="1" c:identifier="TP_CM_INFO_SOURCE_FILE"/>
      <member name="live" value="2" c:identifier="TP_CM_INFO_SOURCE_LIVE"/>
    </enumeration>
    <constant name="CM_BUS_NAME_BASE"
              value="org.freedesktop.Telepathy.ConnectionManager."
              c:type="TP_CM_BUS_NAME_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CM_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/ConnectionManager/"
              c:type="TP_CM_OBJECT_PATH_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONN_BUS_NAME_BASE"
              value="org.freedesktop.Telepathy.Connection."
              c:type="TP_CONN_BUS_NAME_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONN_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/Connection/"
              c:type="TP_CONN_OBJECT_PATH_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="CallChannel"
           c:symbol-prefix="call_channel"
           c:type="TpCallChannel"
           version="0.17.5"
           parent="Channel"
           glib:type-name="TpCallChannel"
           glib:get-type="tp_call_channel_get_type"
           glib:type-struct="CallChannelClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpCallChannel.</doc>
      <function name="get_feature_quark_core"
                c:identifier="tp_call_channel_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="accept_async"
              c:identifier="tp_call_channel_accept_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">For incoming calls with #TpCallChannel:state set to
%TP_CALL_STATE_INITIALISED, accept the incoming call. This changes
#TpCallChannel:state to %TP_CALL_STATE_ACCEPTED.

For outgoing calls with #TpCallChannel:state set to
%TP_CALL_STATE_PENDING_INITIATOR, actually call the remote contact; this
changes #TpCallChannel:state to
%TP_CALL_STATE_INITIALISING.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="tp_call_channel_accept_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_channel_accept_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_content_async"
              c:identifier="tp_call_channel_add_content_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Request that a new Content of type @type is added to @self. Callers should
check the value of the #TpCallChannel:mutable-contents property before trying
to add another content as it might not be allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the suggested name of the content to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the media stream type of the content to be added to the call, from #TpMediaStreamType</doc>
            <type name="MediaStreamType" c:type="TpMediaStreamType"/>
          </parameter>
          <parameter name="initial_direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">The initial direction of the content</doc>
            <type name="MediaStreamDirection" c:type="TpMediaStreamDirection"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_content_finish"
              c:identifier="tp_call_channel_add_content_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_channel_add_content_async().

The returned #TpCallContent is NOT guaranteed to have
%TP_CALL_CONTENT_FEATURE_CORE prepared.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">reference to the new #TpCallContent.</doc>
          <type name="CallContent" c:type="TpCallContent*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contents"
              c:identifier="tp_call_channel_get_contents"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallChannel:contents</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="CallContent"/>
          </array>
        </return-value>
      </method>
      <method name="get_members"
              c:identifier="tp_call_channel_get_members"
              version="0.17.5">
        <doc xml:whitespace="preserve">Get the members of this call.

The #TpContact objects are guaranteed to have all of the features
previously passed to tp_simple_client_factory_add_contact_features()
prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GHashTable mapping #TpContact to its new #TpCallMemberFlags</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="Contact"/>
            <type name="guint"/>
          </type>
        </return-value>
      </method>
      <method name="get_state"
              c:identifier="tp_call_channel_get_state"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallChannel:state</doc>
          <type name="CallState" c:type="TpCallState"/>
        </return-value>
        <parameters>
          <parameter name="flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a place to set the value of #TpCallChannel:flags</doc>
            <type name="CallFlags" c:type="TpCallFlags*"/>
          </parameter>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a place to set the value of #TpCallChannel:state-details</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a place to set the value of #TpCallChannel:state-reason</doc>
            <type name="CallStateReason" c:type="TpCallStateReason**"/>
          </parameter>
        </parameters>
      </method>
      <method name="hangup_async"
              c:identifier="tp_call_channel_hangup_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Request that the call is ended. All contents will be removed from @self so
that the #TpCallChannel:contents property will be the empty list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">a TpCallStateChangeReason</doc>
            <type name="CallStateChangeReason"
                  c:type="TpCallStateChangeReason"/>
          </parameter>
          <parameter name="detailed_reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">a more specific reason for the call hangup, if one is available, or an empty or %NULL string otherwise</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a human-readable message to be sent to the remote contact(s)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="hangup_finish"
              c:identifier="tp_call_channel_hangup_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_channel_hangup_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_dtmf"
              c:identifier="tp_call_channel_has_dtmf"
              version="0.17.5">
        <doc xml:whitespace="preserve">Whether or not @self can send DTMF tones using
tp_call_channel_send_tones_async(). To be able to send DTMF tones, at least
one of @self's #TpCallChannel:contents must implement
%TP_IFACE_CALL_CONTENT_INTERFACE_DTMF interface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether or not @self can send DTMF tones.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="has_hardware_streaming"
              c:identifier="tp_call_channel_has_hardware_streaming"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallChannel:hardware-streaming</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="has_hold"
              c:identifier="tp_call_channel_has_hold"
              version="0.17.6">
        <doc xml:whitespace="preserve">Whether or not @self has the %TP_IFACE_CHANNEL_INTERFACE_HOLD
interfaces</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether or not @self supports Hold</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="has_initial_audio"
              c:identifier="tp_call_channel_has_initial_audio"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallChannel:initial-audio</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="initial_audio_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a place to set the value of #TpCallChannel:initial-audio-name</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_initial_video"
              c:identifier="tp_call_channel_has_initial_video"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallChannel:initial-video</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="initial_video_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a place to set the value of #TpCallChannel:initial-video-name</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_mutable_contents"
              c:identifier="tp_call_channel_has_mutable_contents"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallChannel:mutable-contents</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="request_hold_async"
              c:identifier="tp_call_channel_request_hold_async"
              version="0.17.6">
        <doc xml:whitespace="preserve">Requests that the connection manager holds or unholds the call. Watch
#TpCallChannel:hold-state property to know when the channel goes on
hold or is unheld. Unholding may fail if the streaming implementation
can not obtain all the resources needed to restart the call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hold" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether to request a hold or a unhold</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_hold_finish"
              c:identifier="tp_call_channel_request_hold_finish"
              version="0.17.6"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_channel_request_hold_async</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_tones_async"
              c:identifier="tp_call_channel_send_tones_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Send @tones on every of @self's contents which have the
%TP_IFACE_CALL_CONTENT_INTERFACE_DTMF interface.

For more details, see tp_call_content_send_tones_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tones" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string representation of one or more DTMF events.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_tones_finish"
              c:identifier="tp_call_channel_send_tones_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_channel_send_tones_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_queued_async"
              c:identifier="tp_call_channel_set_queued_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Notifies the CM that the local user is already in a call, so this call has
been put in a call-waiting style queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_queued_finish"
              c:identifier="tp_call_channel_set_queued_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_channel_set_queued_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ringing_async"
              c:identifier="tp_call_channel_set_ringing_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Indicate that the local user has been alerted about the incoming call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ringing_finish"
              c:identifier="tp_call_channel_set_ringing_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_channel_set_ringing_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="contents" version="0.17.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">#GPtrArray of #TpCallContent objects. The list of content objects that are
part of this call.

It is NOT guaranteed that %TP_CALL_CONTENT_FEATURE_CORE is prepared on
those objects.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="flags" version="0.17.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpCallFlags specifying the flags of the call state.</doc>
        <type name="guint"/>
      </property>
      <property name="hardware-streaming"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether or not the streaming is done by dedicated hardware.</doc>
        <type name="gboolean"/>
      </property>
      <property name="hold-state" version="0.17.6" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpLocalHoldState specifying if the Call is currently held</doc>
        <type name="guint"/>
      </property>
      <property name="hold-state-reason"
                version="0.17.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpLocalHoldStateReason specifying why the Call is currently held.</doc>
        <type name="guint"/>
      </property>
      <property name="initial-audio"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether or not the Call was started with audio.</doc>
        <type name="gboolean"/>
      </property>
      <property name="initial-audio-name"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If #TpCallChannel:initial-audio is set to %TRUE, then this property will
is the name of the intial audio content, %NULL otherwise.</doc>
        <type name="utf8"/>
      </property>
      <property name="initial-video"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether or not the Call was started with video.</doc>
        <type name="gboolean"/>
      </property>
      <property name="initial-video-name"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If #TpCallChannel:initial-video is set to %TRUE, then this property will
is the name of the intial video content, %NULL otherwise.</doc>
        <type name="utf8"/>
      </property>
      <property name="mutable-contents"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether or not call contents can be added or removed.</doc>
        <type name="gboolean"/>
      </property>
      <property name="state" version="0.17.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpCallState specifying the state of the call.</doc>
        <type name="guint"/>
      </property>
      <property name="state-details"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Detailed infoermation about #TpCallChannel:state. It is a #GHashTable
mapping gchar*-&gt;GValue, it can be accessed using the tp_asv_* functions.</doc>
        <type name="GLib.HashTable">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </property>
      <property name="state-reason" version="0.17.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">Reason why #TpCallChannel:state last changed.</doc>
        <type name="CallStateReason"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CallChannelPrivate" c:type="TpCallChannelPrivate*"/>
      </field>
      <glib:signal name="content-added" when="last" version="0.17.5">
        <doc xml:whitespace="preserve">The ::content-added signal is emitted whenever a
#TpCallContent is added to @self.

It is NOT guaranteed that %TP_CALL_CONTENT_FEATURE_CORE is prepared on
@content.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="content" transfer-ownership="none">
            <doc xml:whitespace="preserve">the newly added #TpCallContent</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="content-removed" when="last" version="0.17.5">
        <doc xml:whitespace="preserve">The ::content-removed signal is emitted whenever a
#TpCallContent is removed from @self.

It is NOT guaranteed that %TP_CALL_CONTENT_FEATURE_CORE is prepared on
@content.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="content" transfer-ownership="none">
            <doc xml:whitespace="preserve">the newly removed #TpCallContent</doc>
            <type name="GObject.Object"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpCallStateReason</doc>
            <type name="CallStateReason"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="members-changed" when="last" version="0.17.5">
        <doc xml:whitespace="preserve">The ::members-changed signal is emitted whenever the call's members
changes.

The #TpContact objects are guaranteed to have all of the features
previously passed to tp_simple_client_factory_add_contact_features()
prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="updates" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GHashTable mapping #TpContact to its new #TpCallMemberFlags</doc>
            <type name="GLib.HashTable">
              <type name="Contact"/>
              <type name="guint"/>
            </type>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GPtrArray of #TpContact removed from the call members</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpCallStateReason for the change</doc>
            <type name="CallStateReason"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="state-changed" when="last" version="0.17.5">
        <doc xml:whitespace="preserve">The ::state-changed signal is emitted whenever the
call state changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new #TpCallState</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new #TpCallFlags</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpCallStateReason for the change</doc>
            <type name="CallStateReason"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">additional details as a #GHashTable readable using the tp_asv_* functions.</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="CallChannelClass"
            c:type="TpCallChannelClass"
            glib:is-gtype-struct-for="CallChannel"
            version="0.17.5">
      <doc xml:whitespace="preserve">The class of a #TpCallChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="CallChannelPrivate"
            c:type="TpCallChannelPrivate"
            disguised="1">
    </record>
    <class name="CallContent"
           c:symbol-prefix="call_content"
           c:type="TpCallContent"
           version="0.17.5"
           parent="Proxy"
           glib:type-name="TpCallContent"
           glib:get-type="tp_call_content_get_type"
           glib:type-struct="CallContentClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpCallContent.</doc>
      <function name="get_feature_quark_core"
                c:identifier="tp_call_content_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_call_content_init_known_interfaces"
                version="0.17.5">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for #TpCallContent have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CALL_CONTENT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="get_disposition"
              c:identifier="tp_call_content_get_disposition"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallContent:disposition</doc>
          <type name="CallContentDisposition"
                c:type="TpCallContentDisposition"/>
        </return-value>
      </method>
      <method name="get_media_type"
              c:identifier="tp_call_content_get_media_type"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallContent:name</doc>
          <type name="MediaStreamType" c:type="TpMediaStreamType"/>
        </return-value>
      </method>
      <method name="get_name"
              c:identifier="tp_call_content_get_name"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallContent:name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_streams"
              c:identifier="tp_call_content_get_streams"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallContent:streams</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="CallStream"/>
          </array>
        </return-value>
      </method>
      <method name="remove_async"
              c:identifier="tp_call_content_remove_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Remove the content from the call. This will cause #TpCallContent::removed
to be emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish"
              c:identifier="tp_call_content_remove_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_content_remove_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_tones_async"
              c:identifier="tp_call_content_send_tones_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Send @tones DTMF code on @self content. @self must have the
%TP_IFACE_CALL_CONTENT_INTERFACE_DTMF interface.

If DTMF tones are already being played, this request is queued.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tones" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string representation of one or more DTMF events.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_tones_finish"
              c:identifier="tp_call_content_send_tones_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_content_send_tones_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="channel"
                version="0.17.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The parent #TpCallChannel of the content.</doc>
        <type name="CallChannel"/>
      </property>
      <property name="connection"
                version="0.17.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection of the call.</doc>
        <type name="Connection"/>
      </property>
      <property name="disposition" version="0.17.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">The disposition of this content, from #TpCallContentDisposition.</doc>
        <type name="guint"/>
      </property>
      <property name="media-type" version="0.17.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">The media type of this content, from #TpMediaStreamType.</doc>
        <type name="guint"/>
      </property>
      <property name="name" version="0.17.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of this content.</doc>
        <type name="utf8"/>
      </property>
      <property name="streams" version="0.17.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">#GPtrArray of #TpCallStream objects. The list of stream objects that are
part of this content.

It is NOT guaranteed that %TP_CALL_STREAM_FEATURE_CORE is prepared on
those objects.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CallContentPrivate" c:type="TpCallContentPrivate*"/>
      </field>
      <glib:signal name="removed" when="last" version="0.17.5">
        <doc xml:whitespace="preserve">The ::removed signal is emitted when @self is removed from
a #TpCallChannel.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="streams-added" when="last" version="0.17.5">
        <doc xml:whitespace="preserve">The ::streams-added signal is emitted whenever
#TpCallStream are added to @self.

It is NOT guaranteed that %TP_CALL_STREAM_FEATURE_CORE is prepared on
stream objects.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="streams" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of newly added #TpCallStream</doc>
            <array name="GLib.PtrArray">
              <type name="CallStream"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="streams-removed" when="last" version="0.17.5">
        <doc xml:whitespace="preserve">The ::streams-removed signal is emitted whenever
#TpCallStreams are removed from @self.

It is NOT guaranteed that %TP_CALL_STREAM_FEATURE_CORE is prepared on
stream objects.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="streams" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of newly removed #TpCallStream</doc>
            <array name="GLib.PtrArray">
              <type name="CallStream"/>
            </array>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpCallStateReason</doc>
            <type name="CallStateReason"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="CallContentClass"
            c:type="TpCallContentClass"
            glib:is-gtype-struct-for="CallContent"
            version="0.17.5">
      <doc xml:whitespace="preserve">The class of a #TpCallContent.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <enumeration name="CallContentDisposition"
                 c:type="TpCallContentDisposition">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The disposition of this content, which defines whether to         automatically start sending data on the streams when         Accept is         called on the channel.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_CALL_CONTENT_DISPOSITION_NONE"/>
      <member name="initial"
              value="1"
              c:identifier="TP_CALL_CONTENT_DISPOSITION_INITIAL"/>
    </enumeration>
    <enumeration name="CallContentPacketizationType"
                 c:type="TpCallContentPacketizationType">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A packetization method that can be used for a content.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="rtp"
              value="0"
              c:identifier="TP_CALL_CONTENT_PACKETIZATION_TYPE_RTP"/>
      <member name="raw"
              value="1"
              c:identifier="TP_CALL_CONTENT_PACKETIZATION_TYPE_RAW"/>
      <member name="msn_webcam"
              value="2"
              c:identifier="TP_CALL_CONTENT_PACKETIZATION_TYPE_MSN_WEBCAM"/>
    </enumeration>
    <record name="CallContentPrivate"
            c:type="TpCallContentPrivate"
            disguised="1">
    </record>
    <bitfield name="CallFlags" c:type="TpCallFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A set of flags representing additional information than is available         in CallState. Many of these flags only make         sense in a particular (or may explain why a call is in a specific         state).       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="locally_held"
              value="1"
              c:identifier="TP_CALL_FLAG_LOCALLY_HELD"/>
      <member name="locally_ringing"
              value="2"
              c:identifier="TP_CALL_FLAG_LOCALLY_RINGING"/>
      <member name="locally_queued"
              value="4"
              c:identifier="TP_CALL_FLAG_LOCALLY_QUEUED"/>
      <member name="forwarded"
              value="8"
              c:identifier="TP_CALL_FLAG_FORWARDED"/>
      <member name="clearing" value="16" c:identifier="TP_CALL_FLAG_CLEARING"/>
    </bitfield>
    <bitfield name="CallMemberFlags" c:type="TpCallMemberFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A set of flags representing the status of a remote contact in a           call.          It is protocol- and client-specific whether a particular contact           will ever have a particular flag set on them, and Telepathy clients           SHOULD NOT assume that a flag will ever be set.                     180 Ringing in SIP, and its equivalent in XMPP, are optional             informational messages, and implementations are not required             to send them. The same applies to the messages used to indicate             hold state.                ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="ringing"
              value="1"
              c:identifier="TP_CALL_MEMBER_FLAG_RINGING"/>
      <member name="held" value="2" c:identifier="TP_CALL_MEMBER_FLAG_HELD"/>
      <member name="conference_host"
              value="4"
              c:identifier="TP_CALL_MEMBER_FLAG_CONFERENCE_HOST"/>
    </bitfield>
    <enumeration name="CallState" c:type="TpCallState">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The state of a call, as a whole.          The allowed transitions are:                     Pending_Initiator → Initialising (for outgoing calls,             when Accept is called)           Initialising → Initialised (for outgoing calls, when             the remote client indicates that the user has been notified about             the call. If the network is known not to provide feedback about whether             the remote side is ringing, then the call should immediately be             set to Ringing.           Initialising → Initialised (for incoming calls, when e.g. the             implementation has been initialised far enough that it is sensible             to notify the user about the call (to reduce the probability that             the user will pick up the call and have it immediately fail).             The UI should then alert the user about the call, and call             SetRinging)           Initialised → Accepted (for outgoing calls to a contact,             when the remote contact accepts the call; for incoming calls, when             Accept is called.)           Accepted → Active (when the local user successfully             joins the call/conference, and media is known to be flowing             successfully; also, when temporary connection problems are             resolved (See below)). If the network is known not to provide             feedback about when the call is properly connected, the call             should immediately be set to Active.           Active → Accepted (when there are temporary connection problems             that the CM is aware of and able to recover from)           any state → Ended (when the call is terminated             normally, or when an error occurs that the CM is unable to recover             from)                   Clients MAY consider unknown values from this enum to be an           error - additional values will not be defined after the Call           specification is declared to be stable.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown" value="0" c:identifier="TP_CALL_STATE_UNKNOWN"/>
      <member name="pending_initiator"
              value="1"
              c:identifier="TP_CALL_STATE_PENDING_INITIATOR"/>
      <member name="initialising"
              value="2"
              c:identifier="TP_CALL_STATE_INITIALISING"/>
      <member name="initialised"
              value="3"
              c:identifier="TP_CALL_STATE_INITIALISED"/>
      <member name="accepted" value="4" c:identifier="TP_CALL_STATE_ACCEPTED"/>
      <member name="active" value="5" c:identifier="TP_CALL_STATE_ACTIVE"/>
      <member name="ended" value="6" c:identifier="TP_CALL_STATE_ENDED"/>
    </enumeration>
    <enumeration name="CallStateChangeReason" c:type="TpCallStateChangeReason">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A simple representation of the reason for a change in the call's         state, which may be used by simple clients, or used as a fallback         when the DBus_Reason member of a Call_State_Reason         struct is not understood.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_UNKNOWN"/>
      <member name="progress_made"
              value="1"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_PROGRESS_MADE"/>
      <member name="user_requested"
              value="2"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_USER_REQUESTED"/>
      <member name="forwarded"
              value="3"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_FORWARDED"/>
      <member name="rejected"
              value="4"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_REJECTED"/>
      <member name="no_answer"
              value="5"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_NO_ANSWER"/>
      <member name="invalid_contact"
              value="6"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_INVALID_CONTACT"/>
      <member name="permission_denied"
              value="7"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_PERMISSION_DENIED"/>
      <member name="busy"
              value="8"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_BUSY"/>
      <member name="internal_error"
              value="9"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_INTERNAL_ERROR"/>
      <member name="service_error"
              value="10"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_SERVICE_ERROR"/>
      <member name="network_error"
              value="11"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_NETWORK_ERROR"/>
      <member name="media_error"
              value="12"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_MEDIA_ERROR"/>
      <member name="connectivity_error"
              value="13"
              c:identifier="TP_CALL_STATE_CHANGE_REASON_CONNECTIVITY_ERROR"/>
    </enumeration>
    <record name="CallStateReason"
            c:type="TpCallStateReason"
            version="0.17.5"
            glib:type-name="TpCallStateReason"
            glib:get-type="tp_call_state_reason_get_type"
            c:symbol-prefix="call_state_reason">
      <doc xml:whitespace="preserve">Data structure representing the reason for a call state change.</doc>
      <field name="actor" writable="1">
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="reason" writable="1">
        <type name="CallStateChangeReason" c:type="TpCallStateChangeReason"/>
      </field>
      <field name="dbus_reason" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="message" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="ref_count" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <class name="CallStream"
           c:symbol-prefix="call_stream"
           c:type="TpCallStream"
           version="0.17.5"
           parent="Proxy"
           glib:type-name="TpCallStream"
           glib:get-type="tp_call_stream_get_type"
           glib:type-struct="CallStreamClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpCallStream.</doc>
      <function name="get_feature_quark_core"
                c:identifier="tp_call_stream_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_call_stream_init_known_interfaces"
                version="0.17.5">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for #TpCallStream have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CALL_STREAM.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="can_request_receiving"
              c:identifier="tp_call_stream_can_request_receiving"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallStream:can-request-receiving</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_local_sending_state"
              c:identifier="tp_call_stream_get_local_sending_state"
              version="0.17.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpCallStream:local-sending-state</doc>
          <type name="SendingState" c:type="TpSendingState"/>
        </return-value>
      </method>
      <method name="get_remote_members"
              c:identifier="tp_call_stream_get_remote_members"
              version="0.17.5">
        <doc xml:whitespace="preserve">Get the remote contacts to who this stream is connected, mapped to their
sending state.

It is NOT guaranteed that #TpContact objects have any feature prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GHashTable mapping #TpContact to its new #TpSendingState</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="Contact"/>
            <type name="guint"/>
          </type>
        </return-value>
      </method>
      <method name="request_receiving_async"
              c:identifier="tp_call_stream_request_receiving_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Request that a remote contact stops or starts sending on this stream.

The #TpCallStream:can-request-receiving property defines whether the protocol
allows the local user to request the other side start sending on this stream.

If @receive is %TRUE, request that the given contact starts to send media.
If @receive is %FALSE, request that the given contact stops sending media.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">contact from which sending is requested</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
          <parameter name="receive" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested receiving state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_receiving_finish"
              c:identifier="tp_call_stream_request_receiving_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_stream_request_receiving_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sending_async"
              c:identifier="tp_call_stream_set_sending_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Set the stream to start or stop sending media from the local user to other
contacts.

If @send is %TRUE, #TpCallStream:local-sending-state should change to
%TP_SENDING_STATE_SENDING, if it isn't already.
If @send is %FALSE, #TpCallStream:local-sending-state should change to
%TP_SENDING_STATE_NONE, if it isn't already.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="send" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested sending state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sending_finish"
              c:identifier="tp_call_stream_set_sending_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_call_stream_set_sending_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="can-request-receiving"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, the user can request that a remote contact starts sending on this
stream.</doc>
        <type name="gboolean"/>
      </property>
      <property name="connection"
                version="0.17.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection of the call.</doc>
        <type name="Connection"/>
      </property>
      <property name="content"
                version="0.17.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The Content that this streams belongs to</doc>
        <type name="CallContent"/>
      </property>
      <property name="local-sending-state"
                version="0.17.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The local user's sending state, from #TpSendingState.</doc>
        <type name="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CallStreamPrivate" c:type="TpCallStreamPrivate*"/>
      </field>
      <glib:signal name="local-sending-state-changed"
                   when="last"
                   version="0.17.5">
        <doc xml:whitespace="preserve">The ::local-sending-state-changed signal is emitted whenever the
stream sending state changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <type name="CallStateReason"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <type name="GLib.HashTable">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="remote-members-changed" when="last" version="0.17.5">
        <doc xml:whitespace="preserve">The ::remote-members-changed signal is emitted whenever the
stream's remote members changes.

It is NOT guaranteed that #TpContact objects have any feature prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="updates" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GHashTable mapping #TpContact to its new #TpSendingState</doc>
            <type name="GLib.HashTable">
              <type name="Contact"/>
              <type name="guint"/>
            </type>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GPtrArray of #TpContact removed from remote contacts</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpCallStateReason for the change</doc>
            <type name="CallStateReason"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <enumeration name="CallStreamCandidateType"
                 c:type="TpCallStreamCandidateType">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The network topology that an IP candidate represents. This can         sometimes be used to infer what kind of performance characteristics         (latency, bandwith, etc) can be expected of connections made to this         candidate.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_NONE"/>
      <member name="host"
              value="1"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_HOST"/>
      <member name="server_reflexive"
              value="2"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_SERVER_REFLEXIVE"/>
      <member name="peer_reflexive"
              value="3"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_PEER_REFLEXIVE"/>
      <member name="relay"
              value="4"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_RELAY"/>
      <member name="multicast"
              value="5"
              c:identifier="TP_CALL_STREAM_CANDIDATE_TYPE_MULTICAST"/>
    </enumeration>
    <record name="CallStreamClass"
            c:type="TpCallStreamClass"
            glib:is-gtype-struct-for="CallStream"
            version="0.17.5">
      <doc xml:whitespace="preserve">The class of a #TpCallStream.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="CallStreamPrivate"
            c:type="TpCallStreamPrivate"
            disguised="1">
    </record>
    <class name="Capabilities"
           c:symbol-prefix="capabilities"
           c:type="TpCapabilities"
           version="0.11.3"
           parent="GObject.Object"
           glib:type-name="TpCapabilities"
           glib:get-type="tp_capabilities_get_type"
           glib:type-struct="CapabilitiesClass">
      <doc xml:whitespace="preserve">An object representing capabilities a #TpConnection or #TpContact supports.</doc>
      <method name="dup_channel_classes_variant"
              c:identifier="tp_capabilities_dup_channel_classes_variant"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpCapabilities:channel-classes-variant property</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the value of the #TpCapabilities:channel-classes-variant property</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_channel_classes"
              c:identifier="tp_capabilities_get_channel_classes"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #GPtrArray as the #TpCapabilities:channel-classes property</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
      </method>
      <method name="is_specific_to_contact"
              c:identifier="tp_capabilities_is_specific_to_contact"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #gboolean as the #TpCapabilities:contact-specific property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_audio_call"
              c:identifier="tp_capabilities_supports_audio_call"
              version="0.17.6">
        <doc xml:whitespace="preserve">Return whether audio calls can be established, for instance by calling
tp_account_channel_request_new_audio_call(), followed by
tp_account_channel_request_set_target_id() with @handle_type.

To check whether requests using
tp_account_channel_request_set_target_contact() would work, set
@handle_type to %TP_HANDLE_TYPE_CONTACT.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing Call as ChannelType, @handle_type as TargetHandleType, a True value for InitialAudio and an identifier of the appropriate type can be expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type of the call; #TP_HANDLE_TYPE_CONTACT for private, #TP_HANDLE_TYPE_ROOM or #TP_HANDLE_TYPE_NONE for conference (depending on the protocol)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_audio_video_call"
              c:identifier="tp_capabilities_supports_audio_video_call"
              version="0.17.6">
        <doc xml:whitespace="preserve">Return whether audio/video calls can be established, for instance by calling
tp_account_channel_request_new_audio_video_call(), followed by
tp_account_channel_request_set_target_id() with @handle_type.

To check whether requests using
tp_account_channel_request_set_target_contact() would work, set
@handle_type to %TP_HANDLE_TYPE_CONTACT.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing Call as ChannelType, @handle_type as TargetHandleType, a True value for InitialAudio/InitialVideo and an identifier of the appropriate type can be expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type of the call; #TP_HANDLE_TYPE_CONTACT for private, #TP_HANDLE_TYPE_ROOM or #TP_HANDLE_TYPE_NONE for conference (depending on the protocol)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_contact_search"
              c:identifier="tp_capabilities_supports_contact_search"
              version="0.13.11">
        <doc xml:whitespace="preserve">Return whether this protocol or connection can perform contact
searches. Optionally, also return whether a limited number of
results can be specified, and whether alternative servers can be
searched.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if #TpContactSearch can be used.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="with_limit"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return %TRUE if the limit parameter to tp_contact_search_new_async() and tp_contact_search_reset_async() can be nonzero</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="with_server"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return %TRUE if the server parameter to tp_contact_search_new_async() and tp_contact_search_reset_async() can be non-%NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_dbus_tubes"
              c:identifier="tp_capabilities_supports_dbus_tubes"
              version="0.13.0">
        <doc xml:whitespace="preserve">If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities supports
D-Bus tubes with @handle_type as TargetHandleType.
If @service_name is not %NULL, it also checks if it supports stream tubes
with @service as #TP_PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME.

If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if the connection supports requesting D-Bus tube channels with
@handle_type as ChannelType. The @service_name argument is unused in
this case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the contact or connection supports this type of D-Bus tubes.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type of the tube (either #TP_HANDLE_TYPE_CONTACT or #TP_HANDLE_TYPE_ROOM)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="service_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the service name of the tube, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_file_transfer"
              c:identifier="tp_capabilities_supports_file_transfer"
              version="0.17.6">
        <doc xml:whitespace="preserve">Return whether private file transfer can be established by providing
a contact identifier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing FileTransfer as ChannelType, HandleTypeContact as TargetHandleType and a contact identifier can be expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_file_transfer_description"
              c:identifier="tp_capabilities_supports_file_transfer_description"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if requests as described for tp_capabilities_supports_file_transfer() can also specify the outgoing file's description</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_file_transfer_initial_offset"
              c:identifier="tp_capabilities_supports_file_transfer_initial_offset"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return whether an initial offset other than 0 can be specified on
outgoing file transfers. This can be used to resume partial transfers,
by omitting the part that has already been sent.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if requests as described for tp_capabilities_supports_file_transfer() can also specify an initial offset greater than 0</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_file_transfer_timestamp"
              c:identifier="tp_capabilities_supports_file_transfer_timestamp"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if requests as described for tp_capabilities_supports_file_transfer() can also specify the outgoing file's timestamp</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_file_transfer_uri"
              c:identifier="tp_capabilities_supports_file_transfer_uri"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if requests as described for tp_capabilities_supports_file_transfer() can also specify the outgoing file's URI</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_room_list"
              c:identifier="tp_capabilities_supports_room_list"
              version="0.13.14">
        <doc xml:whitespace="preserve">Discovers whether this protocol or connection supports listing rooms.
Specifically, if this function returns %TRUE, a room list channel can be
requested as follows:
|[
GHashTable *request;
TpAccountChannelRequest *req;

request = tp_asv_new (
    TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
      TP_IFACE_CHANNEL_TYPE_ROOM_LIST,
    TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_NONE,
    NULL);

req = tp_account_channel_request_new (account, request,
   TP_USER_ACTION_TIME_CURRENT_TIME);

tp_account_channel_request_create_and_handle_channel_async (req, NULL,
    create_channel_cb, NULL);

g_object_unref (req);
g_hash_table_unref (request);
]|

If @with_server is set to %TRUE, a list of rooms on a particular server can
be requested as follows:
|[
/\* Same code as above but with request defined using: *\/
request = tp_asv_new (
    TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
      TP_IFACE_CHANNEL_TYPE_ROOM_LIST,
    TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_NONE,
    TP_PROP_CHANNEL_TYPE_ROOM_LIST_SERVER, G_TYPE_STRING,
      "characters.shakespeare.lit",
    NULL);
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing RoomList as ChannelType, HandleTypeNone as TargetHandleType can be expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="with_server"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return %TRUE if the #TP_PROP_CHANNEL_TYPE_ROOM_LIST_SERVER property can be defined when requesting a RoomList channel.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_sms"
              c:identifier="tp_capabilities_supports_sms"
              version="0.19.0">
        <doc xml:whitespace="preserve">If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if SMS text channels can be requested with the connection associated
with this #TpCapabilities.

If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities supports
SMS text channels.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing Text as ChannelType, HandleTypeContact as TargetHandleType, a channel identifier and #TP_PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL set to %TRUE can be expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_stream_tubes"
              c:identifier="tp_capabilities_supports_stream_tubes"
              version="0.13.0">
        <doc xml:whitespace="preserve">If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities supports
stream tubes with @handle_type as TargetHandleType.
If @service is not %NULL, it also checks if it supports stream tubes
with @service as #TP_PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE.

If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if the connection supports requesting stream tube channels with
@handle_type as ChannelType. The @service argument is unused in this case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the contact or connection supports this type of stream tubes.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type of the tube (either #TP_HANDLE_TYPE_CONTACT or #TP_HANDLE_TYPE_ROOM)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">the service of the tube, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_text_chatrooms"
              c:identifier="tp_capabilities_supports_text_chatrooms"
              version="0.11.3">
        <doc xml:whitespace="preserve">If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if named text chatrooms can be joined by providing a chatroom
identifier, for instance by calling
tp_account_channel_request_new_text() followed by
tp_account_channel_request_set_target_id() with %TP_HANDLE_TYPE_ROOM.

If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities can be invited
to named text chatrooms.

If the protocol is such that chatrooms can be joined or contacts can be
invited, but only via a more elaborate D-Bus API than normal
(because more information is needed), then this method will return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing Text as ChannelType, HandleTypeRoom as TargetHandleType and a channel identifier can be expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_text_chats"
              c:identifier="tp_capabilities_supports_text_chats"
              version="0.11.3">
        <doc xml:whitespace="preserve">Return whether private text channels can be established by providing
a contact identifier, for instance by calling
tp_account_channel_request_new_text() followed by
tp_account_channel_request_set_target_contact().

If the protocol is such that text chats can be established, but only via a
more elaborate D-Bus API than normal (because more information is needed),
then this method will return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing Text as ChannelType, HandleTypeContact as TargetHandleType and a contact identifier can be expected to work, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="channel-classes"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The underlying data structure used by Telepathy to represent the
requests that can succeed.

This can be used by advanced clients to determine whether an unusually
complex request would succeed. See the Telepathy D-Bus API Specification
for details of how to interpret the returned #GPtrArray of
#TP_STRUCT_TYPE_REQUESTABLE_CHANNEL_CLASS.

The higher-level methods like
tp_capabilities_supports_text_chats() are likely to be more useful to
the majority of clients.</doc>
        <type/>
      </property>
      <property name="channel-classes-variant"
                version="0.19.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The underlying data structure used by Telepathy to represent the
requests that can succeed.

This can be used by advanced clients to determine whether an unusually
complex request would succeed. See the Telepathy D-Bus API Specification
for details of how to interpret the returned #GVariant of type
a(a{sv}as).

The higher-level methods like
tp_capabilities_supports_text_chats() are likely to be more useful to
the majority of clients.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="contact-specific"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this object accurately describes the capabilities of a particular
contact, or if it's only a guess based on the capabilities of the
underlying connection.</doc>
        <type name="gboolean"/>
      </property>
    </class>
    <record name="CapabilitiesClass"
            c:type="TpCapabilitiesClass"
            disguised="1"
            glib:is-gtype-struct-for="Capabilities">
    </record>
    <record name="CapabilitiesPrivate"
            c:type="TpCapabilitiesPrivate"
            disguised="1">
    </record>
    <enumeration name="CaptchaCancelReason" c:type="TpCaptchaCancelReason">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A reason why captcha authentication was aborted by the client.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="user_cancelled"
              value="0"
              c:identifier="TP_CAPTCHA_CANCEL_REASON_USER_CANCELLED"/>
      <member name="not_supported"
              value="1"
              c:identifier="TP_CAPTCHA_CANCEL_REASON_NOT_SUPPORTED"/>
      <member name="service_confused"
              value="2"
              c:identifier="TP_CAPTCHA_CANCEL_REASON_SERVICE_CONFUSED"/>
    </enumeration>
    <bitfield name="CaptchaFlags" c:type="TpCaptchaFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Extra flags to include with Captcha information       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="captcha_flags_required"
              value="1"
              c:identifier="TP_CAPTCHA_FLAGS_REQUIRED"/>
    </bitfield>
    <enumeration name="CaptchaStatus" c:type="TpCaptchaStatus">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local_pending"
              value="0"
              c:identifier="TP_CAPTCHA_STATUS_LOCAL_PENDING"/>
      <member name="remote_pending"
              value="1"
              c:identifier="TP_CAPTCHA_STATUS_REMOTE_PENDING"/>
      <member name="succeeded"
              value="2"
              c:identifier="TP_CAPTCHA_STATUS_SUCCEEDED"/>
      <member name="try_again"
              value="3"
              c:identifier="TP_CAPTCHA_STATUS_TRY_AGAIN"/>
      <member name="failed" value="4" c:identifier="TP_CAPTCHA_STATUS_FAILED"/>
    </enumeration>
    <class name="Channel"
           c:symbol-prefix="channel"
           c:type="TpChannel"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpChannel"
           glib:get-type="tp_channel_get_type"
           glib:type-struct="ChannelClass">
      <doc xml:whitespace="preserve">A proxy object for a Telepathy channel.
A proxy object for a Telepathy channel. There are no interesting
public struct fields.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <constructor name="new"
                   c:identifier="tp_channel_new"
                   version="0.7.1"
                   deprecated="Use tp_simple_client_factory_ensure_channel() instead."
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new channel proxy, or %NULL on invalid arguments.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="optional_channel_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the channel type if already known, or %NULL if not</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="optional_handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type if already known, or %TP_UNKNOWN_HANDLE_TYPE if not</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="optional_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle if already known, or 0 if not (if @optional_handle_type is %TP_UNKNOWN_HANDLE_TYPE or %TP_HANDLE_TYPE_NONE, this must be 0)</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_properties"
                   c:identifier="tp_channel_new_from_properties"
                   version="0.7.19"
                   deprecated="Use tp_simple_client_factory_ensure_channel() instead."
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new channel proxy, or %NULL on invalid arguments</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable properties of the channel, as signalled by the NewChannel D-Bus signal or returned by the CreateChannel and EnsureChannel D-Bus methods: a mapping from strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_chat_states"
                c:identifier="tp_channel_get_feature_quark_chat_states">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contacts"
                c:identifier="tp_channel_get_feature_quark_contacts">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_channel_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_group"
                c:identifier="tp_channel_get_feature_quark_group">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_password"
                c:identifier="tp_channel_get_feature_quark_password">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_init_known_interfaces"
                version="0.7.6">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannel have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="borrow_connection"
              c:identifier="tp_channel_borrow_connection"
              version="0.7.12"
              deprecated="Since 0.19.9. New code should use tp_channel_get_connection() instead.">
        <doc xml:whitespace="preserve">Returns the connection for this channel. The returned pointer is only valid
while this channel is valid - reference it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="borrow_immutable_properties"
              c:identifier="tp_channel_borrow_immutable_properties"
              deprecated="Since 0.19.9. New code should use tp_channel_dup_immutable_properties() instead.">
        <doc xml:whitespace="preserve">Returns the immutable D-Bus properties of this channel, the same as
#TpChannel:channel-properties.

The returned hash table should not be altered, and is not necessarily
valid after the main loop is next re-entered. Copy it with
g_boxed_copy() (its type is %TP_HASH_TYPE_QUALIFIED_PROPERTY_VALUE_MAP)
if a copy that remains valid must be kept.

If the #TpChannel:channel-properties property was not set during
construction (e.g. by calling tp_channel_new_from_properties()), a
reasonable but possibly incomplete version will be made up from the values
of individual properties; reading this property repeatedly may yield
progressively more complete values until the %TP_CHANNEL_FEATURE_CORE
feature is prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable where the keys are strings, D-Bus interface name + "." + property name, and the values are #GValue instances</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="call_when_ready"
              c:identifier="tp_channel_call_when_ready"
              version="0.7.7"
              introspectable="0"
              deprecated="Use tp_proxy_prepare_async()"
              deprecated-version="0.17.6">
        <doc xml:whitespace="preserve">If @self is ready for use or has been invalidated, call @callback
immediately, then return. Otherwise, arrange
for @callback to be called when @self either becomes ready for use
or becomes invalid.

This is a less general form of tp_proxy_prepare_async(), which should be
used in new code. (One important difference is that this function can call
@callback before it has returned, whereas tp_proxy_prepare_async() always
calls @callback from the main loop.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">called when the channel becomes ready or invalidated, whichever happens first</doc>
            <type name="ChannelWhenReadyCb" c:type="TpChannelWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async"
              c:identifier="tp_channel_close_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Close channel @self. In most cases, it's generally cleaner to use
tp_channel_leave_async() instead to properly leave and close the channel.

When the channel has been closed, @callback will be called.
You can then call tp_channel_close_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when we closed the channel, or %NULL to ignore any reply</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish"
              c:identifier="tp_channel_close_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a call to tp_channel_leave_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been closed; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult passed to the callback for tp_channel_close_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_async"
              c:identifier="tp_channel_destroy_async"
              version="0.15.2">
        <doc xml:whitespace="preserve">Destroy channel @self.
If @self doesn't implement #TP_IFACE_QUARK_CHANNEL_INTERFACE_DESTROYABLE
or if for any reason we can't destroy the channel, we close it.

When the channel has been destroyed or closed, @callback will be called.
You can then call tp_channel_destroy_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when we left the channel</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_finish"
              c:identifier="tp_channel_destroy_finish"
              version="0.15.2"
              throws="1">
        <doc xml:whitespace="preserve">Completes a call to tp_channel_destroy_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been destroyed or closed; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult passed to the callback for tp_channel_destroy_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_immutable_properties"
              c:identifier="tp_channel_dup_immutable_properties"
              version="0.19.9">
        <doc xml:whitespace="preserve">Returns the immutable D-Bus properties of this channel, in a variant of type
%G_VARIANT_TYPE_VARDICT where the keys are strings,
D-Bus interface name + "." + property name. Use g_variant_lookup() or
g_variant_lookup_value() for convenient access to the values.

If the #TpChannel:channel-properties property was not set during
construction (e.g. by calling tp_channel_new_from_properties()), a
reasonable but possibly incomplete version will be made up from the values
of individual properties; reading this property repeatedly may yield
progressively more complete values until the %TP_CHANNEL_FEATURE_CORE
feature is prepared.

This function should be used only by #TpChannel subclasses, otherwise it is
recommended to use individual property getters instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a dictionary where the keys are strings, D-Bus interface name + "." + property name.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_channel_type"
              c:identifier="tp_channel_get_channel_type"
              version="0.7.12">
        <doc xml:whitespace="preserve">Get the D-Bus interface name representing this channel's type,
if it has been discovered.

This is the same as the #TpChannelIface:channel-type property; it isn't
guaranteed to be non-%NULL until the %TP_CHANNEL_FEATURE_CORE feature has
been prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the channel type, if the channel is ready; either the channel type or %NULL, if the channel is not yet ready.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_channel_type_id"
              c:identifier="tp_channel_get_channel_type_id"
              version="0.7.12">
        <doc xml:whitespace="preserve">Get the D-Bus interface name representing this channel's type, as a GQuark,
if it has been discovered.

This is the same as the #TpChannelIface:channel-type property, except that it
is a GQuark rather than a string. It isn't guaranteed to be nonzero until
the %TP_CHANNEL_FEATURE_CORE property is ready.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the channel type, if the channel is ready; either the channel type or 0, if the channel is not yet ready.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </method>
      <method name="get_chat_state"
              c:identifier="tp_channel_get_chat_state"
              version="0.11.3"
              deprecated="Use tp_text_channel_get_chat_state() instead.">
        <doc xml:whitespace="preserve">Return the chat state for the given contact. If tp_proxy_is_prepared()
would return %FALSE for the feature %TP_CHANNEL_FEATURE_CHAT_STATES,
the result will always be %TP_CHANNEL_CHAT_STATE_INACTIVE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the chat state for @contact, or %TP_CHANNEL_CHAT_STATE_INACTIVE if their chat state is not known</doc>
          <type name="ChannelChatState" c:type="TpChannelChatState"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a contact handle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="tp_channel_get_connection"
              version="0.19.9">
        <doc xml:whitespace="preserve">Returns the connection for this channel. The returned pointer is only valid
while this channel is valid - reference it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="get_handle"
              c:identifier="tp_channel_get_handle"
              version="0.7.12">
        <doc xml:whitespace="preserve">Get the handle representing the contact, chatroom, etc. with which this
channel communicates for its whole lifetime, or 0 if there is no such
handle or it has not yet been discovered.

This is the same as the #TpChannelIface:handle property. It isn't
guaranteed to have its final value until the %TP_CHANNEL_FEATURE_CORE
feature is ready.

If @handle_type is not %NULL, the type of handle is written into it.
This will be %TP_UNKNOWN_HANDLE_TYPE if the handle has not yet been
discovered, or %TP_HANDLE_TYPE_NONE if there is no handle with which this
channel will always communicate. This is the same as the
#TpChannelIface:handle-type property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <parameter name="handle_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return the type of this handle</doc>
            <type name="HandleType" c:type="TpHandleType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identifier"
              c:identifier="tp_channel_get_identifier"
              version="0.7.21">
        <doc xml:whitespace="preserve">This channel's associated identifier, or the empty string if no identifier
or unknown.

This is the same as the #TpChannel:identifier property, and isn't guaranteed
to be set until the %TP_CHANNEL_FEATURE_CORE property is ready.

Changed in 0.11.4: as with #TpChannel:identifier, this could
previously either be %NULL or the empty string if there was no suitable
value. It is now non-%NULL in all cases.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the identifier</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_initiator_contact"
              c:identifier="tp_channel_get_initiator_contact"
              version="0.15.6">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:initiator-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="get_initiator_handle"
              c:identifier="tp_channel_get_initiator_handle"
              version="0.11.15"
              introspectable="0"
              deprecated="New code should use tp_channel_get_initiator_contact() instead.">
        <doc xml:whitespace="preserve">Return the #TpChannel:initiator-handle property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:initiator-handle</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_initiator_identifier"
              c:identifier="tp_channel_get_initiator_identifier"
              version="0.11.15"
              introspectable="0"
              deprecated="New code should use tp_channel_get_initiator_contact() instead.">
        <doc xml:whitespace="preserve">Return the #TpChannel:initiator-identifier property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:initiator-identifier</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_requested"
              c:identifier="tp_channel_get_requested"
              version="0.11.15">
        <doc xml:whitespace="preserve">Return the #TpChannel:requested property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:requested</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_target_contact"
              c:identifier="tp_channel_get_target_contact"
              version="0.15.6">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:target-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="group_dup_local_pending_contacts"
              c:identifier="tp_channel_group_dup_local_pending_contacts"
              version="0.15.6">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_CONTACTS feature has been
prepared, return a #GPtrArray containing its local-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_CONTACTS has not been prepared,
the result may either be a set of local-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a new #GPtrArray of #TpContact, free it with g_ptr_array_unref(), or %NULL.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="group_dup_members_contacts"
              c:identifier="tp_channel_group_dup_members_contacts"
              version="0.15.6">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_CONTACTS feature has been
prepared, return a #GPtrArray containing its members.

If @self is a group but %TP_CHANNEL_FEATURE_CONTACTS has not been prepared,
the result may either be a set of members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a new #GPtrArray of #TpContact, free it with g_ptr_array_unref(), or %NULL.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="group_dup_remote_pending_contacts"
              c:identifier="tp_channel_group_dup_remote_pending_contacts"
              version="0.15.6">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_CONTACTS feature has been
prepared, return a #GPtrArray containing its remote-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_CONTACTS has not been prepared,
the result may either be a set of remote-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a new #GPtrArray of #TpContact, free it with g_ptr_array_unref(), or %NULL.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="group_get_contact_owner"
              c:identifier="tp_channel_group_get_contact_owner"
              version="0.15.6">
        <doc xml:whitespace="preserve">Synopsis (see below for further explanation):

- if @self is not a group or @contact is not a member of this channel,
  result is undefined;
- if %TP_CHANNEL_FEATURE_CONTACTS has not yet been prepared, result is
  undefined;
- if @self does not have flags that include
  %TP_CHANNEL_GROUP_FLAG_PROPERTIES,
  result is undefined;
- if @contact is channel-specific and its globally valid "owner" is known,
  return that owner;
- if @contact is channel-specific and its globally valid "owner" is unknown,
  return %NULL;
- if @contact is globally valid, return @contact itself

Some channels (those with flags that include
%TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES) have a concept of
"channel-specific contacts". These are contacts that only have meaning within
the context of the channel - for instance, in XMPP Multi-User Chat,
participants in a chatroom are identified by an in-room JID consisting
of the JID of the chatroom plus a local nickname.

Depending on the protocol and configuration, it might be possible to find
out what globally valid contact (i.e. a contact that you could add to
your contact list) "owns" a channel-specific contact. For instance, in
most XMPP MUC chatrooms, normal users cannot see what global JID
corresponds to an in-room JID, but moderators can.

This is further complicated by the fact that channels with channel-specific
contacts can sometimes have members with globally valid contacts (for
instance, if you invite someone to an XMPP MUC using their globally valid
JID, you would expect to see the contact representing that JID in the
Group's remote-pending set).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the global contact that owns the given contact, or %NULL.</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a contact which is a member of this channel</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_flags"
              c:identifier="tp_channel_group_get_flags"
              version="0.7.12">
        <doc xml:whitespace="preserve">Return the #TpChannel:group-flags property (see the description
of that property for notes on validity).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the group flags, or 0</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </return-value>
      </method>
      <method name="group_get_handle_owner"
              c:identifier="tp_channel_group_get_handle_owner"
              version="0.7.12"
              deprecated="New code should use tp_channel_group_get_contact_owner() instead.">
        <doc xml:whitespace="preserve">Synopsis (see below for further explanation):

- if @self is not a group or @handle is not a member of this channel,
  result is undefined;
- if %TP_CHANNEL_FEATURE_GROUP has not yet been prepared, result is
  undefined;
- if @self does not have flags that include
  %TP_CHANNEL_GROUP_FLAG_PROPERTIES,
  result is undefined;
- if @handle is channel-specific and its globally valid "owner" is known,
  return that owner;
- if @handle is channel-specific and its globally valid "owner" is unknown,
  return zero;
- if @handle is globally valid, return @handle itself

Some channels (those with flags that include
%TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES) have a concept of
"channel-specific handles". These are handles that only have meaning within
the context of the channel - for instance, in XMPP Multi-User Chat,
participants in a chatroom are identified by an in-room JID consisting
of the JID of the chatroom plus a local nickname.

Depending on the protocol and configuration, it might be possible to find
out what globally valid handle (i.e. an identifier that you could add to
your contact list) "owns" a channel-specific handle. For instance, in
most XMPP MUC chatrooms, normal users cannot see what global JID
corresponds to an in-room JID, but moderators can.

This is further complicated by the fact that channels with channel-specific
handles can sometimes have members with globally valid handles (for
instance, if you invite someone to an XMPP MUC using their globally valid
JID, you would expect to see the handle representing that JID in the
Group's remote-pending set).

This function's result is undefined unless the channel is ready
and its flags include %TP_CHANNEL_GROUP_FLAG_PROPERTIES (an implementation
without extra D-Bus round trips is not possible using the older API).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the global handle that owns the given handle, or 0</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle which is a member of this channel</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_local_pending"
              c:identifier="tp_channel_group_get_local_pending"
              version="0.7.12"
              deprecated="New code should use tp_channel_group_dup_local_pending_contacts() instead.">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_GROUP feature has been
prepared, return a #TpIntset containing its local-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_GROUP has not been prepared,
the result may either be a set of local-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the local-pending members, or %NULL</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </return-value>
      </method>
      <method name="group_get_local_pending_contact_info"
              c:identifier="tp_channel_group_get_local_pending_contact_info"
              version="0.15.6">
        <doc xml:whitespace="preserve">If @local_pending is actually a local-pending contact,
write additional information into @actor, @reason and @message and return
%TRUE. The contact and message are not referenced or copied, and can only be
assumed to remain valid until the main loop is re-entered.

If @local_pending is not the handle of a local-pending contact,
write %NULL into @actor, %TP_CHANNEL_GROUP_CHANGE_REASON_NONE into @reason
and "" into @message, and return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the contact is in fact local-pending</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpContact of a local-pending contact about whom more information is needed</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
          <parameter name="actor"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the contact who requested the change</doc>
            <type name="Contact" c:type="TpContact**"/>
          </parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the reason for the change</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason*"/>
          </parameter>
          <parameter name="message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the user-supplied message</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_local_pending_info"
              c:identifier="tp_channel_group_get_local_pending_info"
              version="0.7.12"
              deprecated="New code should use tp_channel_group_get_local_pending_contact_info() instead.">
        <doc xml:whitespace="preserve">If @local_pending is actually the handle of a local-pending contact,
write additional information into @actor, @reason and @message and return
%TRUE. The handle and message are not referenced or copied, and can only be
assumed to remain valid until the main loop is re-entered.

If @local_pending is not the handle of a local-pending contact,
write 0 into @actor, %TP_CHANNEL_GROUP_CHANGE_REASON_NONE into @reason
and "" into @message, and return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the contact is in fact local-pending</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle of a local-pending contact about whom more information is needed</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="actor"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the contact who requested the change</doc>
            <type name="Handle" c:type="TpHandle*"/>
          </parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the reason for the change</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason*"/>
          </parameter>
          <parameter name="message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the user-supplied message</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_members"
              c:identifier="tp_channel_group_get_members"
              version="0.7.12"
              deprecated="New code should use tp_channel_group_dup_members_contacts() instead.">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_GROUP feature has been
prepared, return a #TpIntset containing its members.

If @self is a group but %TP_CHANNEL_FEATURE_GROUP has not been prepared,
the result may either be a set of members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the members, or %NULL</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </return-value>
      </method>
      <method name="group_get_remote_pending"
              c:identifier="tp_channel_group_get_remote_pending"
              version="0.7.12"
              deprecated="New code should use tp_channel_group_dup_remote_pending_contacts() instead.">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_GROUP feature has been
prepared, return a #TpIntset containing its remote-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_GROUP has not been prepared,
the result may either be a set of remote-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the remote-pending members, or %NULL</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </return-value>
      </method>
      <method name="group_get_self_contact"
              c:identifier="tp_channel_group_get_self_contact"
              version="0.15.6">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:group-self-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="group_get_self_handle"
              c:identifier="tp_channel_group_get_self_handle"
              version="0.7.12"
              deprecated="New code should use tp_channel_group_get_self_contact() instead.">
        <doc xml:whitespace="preserve">Return the #TpChannel:group-self-handle property (see the description
of that property for notes on validity).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle representing the user, or 0</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="is_ready"
              c:identifier="tp_channel_is_ready"
              version="0.7.12"
              introspectable="0"
              deprecated="use tp_proxy_is_prepared() with %TP_CHANNEL_FEATURE_CORE"
              deprecated-version="0.17.6">
        <doc xml:whitespace="preserve">Returns the same thing as the #TpChannel:channel-ready property.

New code should use tp_proxy_is_prepared(), which is a more general form of
this method.

For group channels, this method is equivalent to checking for the
combination of %TP_CHANNEL_FEATURE_CORE and %TP_CHANNEL_FEATURE_GROUP; for
non-group channels, it's equivalent to checking for
%TP_CHANNEL_FEATURE_CORE.

One important difference is that after #TpProxy::invalidated is
signalled, #TpChannel:channel-ready keeps its current value - which might
be %TRUE, if the channel was successfully prepared before it became
invalidated - but tp_proxy_is_prepared() returns %FALSE for all features.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if introspection has completed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="join_async"
              c:identifier="tp_channel_join_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Join channel @self with @message as join message.

When we joined the channel, @callback will be called.
You can then call tp_channel_join_finish() to get the result of
the operation.

Note that unlike tp_channel_leave_async(), %TP_CHANNEL_FEATURE_GROUP feature
must be prepared before calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the join message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when we joined the channel</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="join_finish"
              c:identifier="tp_channel_join_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Completes a call to tp_channel_join_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel was successfully joined; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult passed to the callback for tp_channel_join_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_async"
              c:identifier="tp_channel_leave_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Leave channel @self with @reason as reason and @message as leave message.
If @self doesn't implement #TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP or if
for any reason we can't properly leave the channel, we close it.

When we left the channel, @callback will be called.
You can then call tp_channel_leave_finish() to get the result of
the operation.

Note that unlike tp_channel_join_async(), %TP_CHANNEL_FEATURE_GROUP feature
does not have to be prepared and will be prepared for you. But this is a
deprecated behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the leave reason</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the leave message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when we left the channel</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_finish"
              c:identifier="tp_channel_leave_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Completes a call to tp_channel_leave_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been left; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult passed to the callback for tp_channel_leave_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="password_needed"
              c:identifier="tp_channel_password_needed"
              version="0.15.2">
        <doc xml:whitespace="preserve">Return the #TpChannel:password-needed property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:password-needed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="provide_password_async"
              c:identifier="tp_channel_provide_password_async"
              version="0.15.2">
        <doc xml:whitespace="preserve">Provide @password so that @self can be joined.
This function must be called with the correct password in order for
channel joining to proceed if the TpChannel:password-needed property
is set.

Once the password has been provided, @callback will be
called. You can then call tp_channel_provide_password_finish()
to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="password" transfer-ownership="none">
            <doc xml:whitespace="preserve">the password</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when @password has been provided</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="provide_password_finish"
              c:identifier="tp_channel_provide_password_finish"
              version="0.15.2"
              throws="1">
        <doc xml:whitespace="preserve">Completes a call to tp_channel_provide_password_async().
If the password was rejected, the operation
fails with #TP_ERROR_AUTHENTICATION_FAILED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the password has been provided and accepted, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult passed to the callback for tp_channel_provide_password_async().</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_until_ready"
              c:identifier="tp_channel_run_until_ready"
              version="0.7.1"
              introspectable="0"
              deprecated="Use tp_proxy_prepare_async() and re-enter the main loop yourself, or restructure your program in such a way as to avoid re-entering the main loop."
              deprecated-version="0.11.0">
        <doc xml:whitespace="preserve">If @self is ready for use (introspection has finished, etc.), return
immediately. Otherwise, re-enter the main loop until the channel either
becomes invalid or becomes ready for use, or until the main loop stored
via @loop is cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been introspected and is ready for use, %FALSE if the channel has become invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL and %FALSE is returned, used to raise an error</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a #GMainLoop is placed here while it is being run (so calling code can call g_main_loop_quit() to abort), and %NULL is placed here after the loop has been run</doc>
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <property name="channel-properties"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The immutable D-Bus properties of this channel, represented by a
#GHashTable where the keys are D-Bus interface name + "." + property
name, and the values are #GValue instances.

Read-only except during construction. If this is not provided
during construction, a reasonable (but possibly incomplete) version
will be made up from the values of individual properties; reading this
property repeatedly may yield progressively more complete values until
tp_proxy_prepare_async() has finished preparing %TP_CHANNEL_FEATURE_CORE.</doc>
        <type/>
      </property>
      <property name="channel-ready"
                deprecated="use tp_proxy_is_prepared() with %TP_CHANNEL_FEATURE_CORE for checks, or tp_proxy_prepare_async() for notification"
                deprecated-version="0.17.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Initially %FALSE; changes to %TRUE when tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE, and if the channel is a
group, %TP_CHANNEL_FEATURE_GROUP.

This is a less general form of tp_proxy_is_prepared(), which should be
used in new code.

One important difference is that after #TpProxy::invalidated is
signalled, #TpChannel:channel-ready keeps its current value - which might
be %TRUE, if the channel was successfully prepared before it became
invalidated - but tp_proxy_is_prepared() returns %FALSE for all features.

Change notification is via notify::channel-ready.</doc>
        <type name="gboolean"/>
      </property>
      <property name="connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection to which this #TpChannel belongs. Used for e.g.
handle manipulation.</doc>
        <type name="Connection"/>
      </property>
      <property name="group-flags" version="0.7.12" transfer-ownership="none">
        <doc xml:whitespace="preserve">If the %TP_CHANNEL_FEATURE_GROUP feature has been prepared successfully,
#TpChannelGroupFlags indicating the capabilities and behaviour of that
group.

Otherwise, this may be 0.

Change notification is via notify::group-flags or
TpChannel::group-flags-changed.</doc>
        <type name="guint"/>
      </property>
      <property name="group-self-contact"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this channel is a group and %TP_CHANNEL_FEATURE_CONTACTS has been
prepared, and the user is a member of the group, the #TpContact
representing them in this group.

Otherwise, the result may be either a contact representing the user,
or %NULL.

Change notification is via notify::group-self-contact.</doc>
        <type name="Contact"/>
      </property>
      <property name="group-self-handle"
                version="0.7.12"
                deprecated="Use #TpChannel:group-self-contact instead."
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this channel is a group and %TP_CHANNEL_FEATURE_GROUP has been
prepared, and the user is a member of the group, the #TpHandle
representing them in this group.

Otherwise, the result may be either a handle representing the user, or 0.

Change notification is via notify::group-self-handle.</doc>
        <type name="guint"/>
      </property>
      <property name="identifier" transfer-ownership="none">
        <doc xml:whitespace="preserve">This channel's associated identifier, or the empty string if it has
handle type %TP_HANDLE_TYPE_NONE.

For channels where #TpChannelIface:handle is non-zero, this is the result
of inspecting #TpChannelIface:handle.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be
the empty string.

Changed in 0.11.4: this property is never %NULL. Previously,
it was %NULL before an identifier was known, or when a channel
with no TargetID D-Bus property had TargetHandleType %TP_HANDLE_TYPE_NONE.</doc>
        <type name="utf8"/>
      </property>
      <property name="initiator-contact"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpContact of the initiator of this channel, or %NULL if there is no
particular initiator.

If the channel was initiated by a remote contact, this represents
that contact, and #TpChannel:requested will be %FALSE. For instance,
for an incoming call this property indicates the caller, and for a
chatroom invitation this property indicates who sent the invitation.

If the channel was requested by the local user, #TpChannel:requested
will be %TRUE, and this property may be the #TpChannel:group-self-contact
or #TpConnection:self-contact.

If the channel appeared for some other reason (for instance as a
side-effect of connecting to the server), this property may be %NULL.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CONTACTS; until then, it may be
%NULL.</doc>
        <type name="Contact"/>
      </property>
      <property name="initiator-handle"
                version="0.11.15"
                deprecated="Use #TpChannel:initiator-contact instead."
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The %TP_HANDLE_TYPE_CONTACT #TpHandle of the initiator of this
channel, or 0 if there is no particular initiator.

If the channel was initiated by a remote contact, this handle represents
that contact, and #TpChannel:requested will be %FALSE. For instance,
for an incoming call this property indicates the caller, and for a
chatroom invitation this property indicates who sent the invitation.

If the channel was requested by the local user, #TpChannel:requested
will be %TRUE, and this property may be the #TpChannel:group-self-handle
or #TpConnection:self-handle.

If the channel appeared for some other reason (for instance as a
side-effect of connecting to the server), this property may be 0.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be 0.</doc>
        <type name="guint"/>
      </property>
      <property name="initiator-identifier"
                version="0.11.15"
                deprecated="Use #TpChannel:initiator-contact instead."
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If #TpChannel:initiator-handle is 0, this will always be "".
Otherwise, this will be the #TpContact:identifier of the contact
with that handle.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be
the empty string.</doc>
        <type name="utf8"/>
      </property>
      <property name="password-needed"
                version="0.15.2"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, tp_channel_provide_password_async() has to be called
to be able to join the channel.

This is not guaranteed to be meaningful until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_PASSWORD; until then, it may return
%FALSE even if the channel is actually protected by a password.
Preparing %TP_CHANNEL_FEATURE_PASSWORD also ensures that the
notify::password-needed signal will be fired when this property changes.</doc>
        <type name="gboolean"/>
      </property>
      <property name="requested" version="0.11.15" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if this channel was created in response to a local request, such
as a call to tp_account_channel_request_create_channel_async(). %FALSE
if this channel was initiated by a remote contact
(the #TpChannel:initiator-handle), or if it appeared as a side-effect
of some other action.

For instance, this is %FALSE on incoming calls and file transfers,
remotely-initiated 1-1 text conversations, and invitations to chatrooms,
and %TRUE on outgoing calls and file transfers, locally-initiated 1-1
text conversations, and chatrooms joined by local user action.

This is not guaranteed to be meaningful until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may return
%FALSE even if the channel was actually requested.</doc>
        <type name="gboolean"/>
      </property>
      <property name="target-contact"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this channel is for communication with a single contact (that is,
#TpChannelIface:handle-type is %TP_HANDLE_TYPE_CONTACT), then a #TpContact
representing the remote contact. For chat rooms, contact search channels and
other channels without a single remote contact, %NULL.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CONTACTS; until then, it may be
%NULL.</doc>
        <type name="Contact"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelPrivate" c:type="TpChannelPrivate*"/>
      </field>
      <glib:signal name="chat-state-changed"
                   when="last"
                   detailed="1"
                   version="0.11.3"
                   deprecated="Use #TpTextChannel::contact-chat-state-changed instead">
        <doc xml:whitespace="preserve">Emitted when a contact's chat state changes after tp_proxy_prepare_async()
has finished preparing the feature %TP_CHANNEL_FEATURE_CHAT_STATES.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a contact handle for the local user or another contact</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new #TpChannelChatState for the contact</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-contacts-changed"
                   when="last"
                   detailed="1"
                   version="0.15.6">
        <doc xml:whitespace="preserve">Emitted when the group members change in a Group channel.

This is not guaranteed to be emitted until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CONTACTS; until then, it may be
omitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of #TpContact containing the full members added</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of #TpContact containing the members (full, local-pending or remote-pending) removed</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of #TpContact containing the local-pending members added</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of #TpContact containing the remote-pending members added</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpContact for the "actor" handle in @details</doc>
            <type name="Contact"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GHashTable mapping (gchar *) to #GValue containing details about the change, as described in the specification of the MembersChangedDetailed signal.</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-flags-changed"
                   when="last"
                   detailed="1"
                   version="0.7.12">
        <doc xml:whitespace="preserve">Emitted when the #TpChannel:group-flags property changes while the
channel is ready.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpChannelGroupFlags which are newly set</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpChannelGroupFlags which are no longer set</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed"
                   when="last"
                   detailed="1"
                   version="0.7.12"
                   introspectable="0"
                   deprecated="Use #TpChannel::group-contacts-changed instead.">
        <doc xml:whitespace="preserve">Emitted when the group members change in a Group channel that is ready.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">an optional textual message</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the full members added</doc>
            <type/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the members (full, local-pending or remote-pending) removed</doc>
            <type/>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the local-pending members added</doc>
            <type/>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the remote-pending members added</doc>
            <type/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpHandle of the contact causing the change, or 0</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the reason for the change as a #TpChannelGroupChangeReason</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed-detailed"
                   when="last"
                   detailed="1"
                   version="0.7.21"
                   deprecated="Use #TpChannel::group-contacts-changed instead.">
        <doc xml:whitespace="preserve">Emitted when the group members change in a Group channel that is ready.
Contains a superset of the information in the
TpChannel::group-members-changed signal, and is emitted at the same time;
applications can connect to this signal and ignore the other.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the full members added</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the members (full, local-pending or remote-pending) removed</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the local-pending members added</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the remote-pending members added</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GHashTable mapping (gchar *) to #GValue containing details about the change, as described in the specification of the MembersChangedDetailed signal.</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="ChannelCallStateFlags" c:type="TpChannelCallStateFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A set of flags representing call states.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="ringing"
              value="1"
              c:identifier="TP_CHANNEL_CALL_STATE_RINGING"/>
      <member name="queued"
              value="2"
              c:identifier="TP_CHANNEL_CALL_STATE_QUEUED"/>
      <member name="held" value="4" c:identifier="TP_CHANNEL_CALL_STATE_HELD"/>
      <member name="forwarded"
              value="8"
              c:identifier="TP_CHANNEL_CALL_STATE_FORWARDED"/>
      <member name="in_progress"
              value="16"
              c:identifier="TP_CHANNEL_CALL_STATE_IN_PROGRESS"/>
      <member name="conference_host"
              value="32"
              c:identifier="TP_CHANNEL_CALL_STATE_CONFERENCE_HOST"/>
    </bitfield>
    <enumeration name="ChannelChatState" c:type="TpChannelChatState">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="gone" value="0" c:identifier="TP_CHANNEL_CHAT_STATE_GONE"/>
      <member name="inactive"
              value="1"
              c:identifier="TP_CHANNEL_CHAT_STATE_INACTIVE"/>
      <member name="active"
              value="2"
              c:identifier="TP_CHANNEL_CHAT_STATE_ACTIVE"/>
      <member name="paused"
              value="3"
              c:identifier="TP_CHANNEL_CHAT_STATE_PAUSED"/>
      <member name="composing"
              value="4"
              c:identifier="TP_CHANNEL_CHAT_STATE_COMPOSING"/>
    </enumeration>
    <record name="ChannelClass"
            c:type="TpChannelClass"
            glib:is-gtype-struct-for="Channel"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpChannel. In addition to @parent_class there are four
pointers reserved for possible future use.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <enumeration name="ChannelContactSearchState"
                 c:type="TpChannelContactSearchState">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="not_started"
              value="0"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_NOT_STARTED"/>
      <member name="in_progress"
              value="1"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_IN_PROGRESS"/>
      <member name="more_available"
              value="2"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_MORE_AVAILABLE"/>
      <member name="completed"
              value="3"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_COMPLETED"/>
      <member name="failed"
              value="4"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_FAILED"/>
    </enumeration>
    <class name="ChannelDispatchOperation"
           c:symbol-prefix="channel_dispatch_operation"
           c:type="TpChannelDispatchOperation"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpChannelDispatchOperation"
           glib:get-type="tp_channel_dispatch_operation_get_type"
           glib:type-struct="ChannelDispatchOperationClass">
      <doc xml:whitespace="preserve">One of the channel dispatcher's functions is to offer incoming channels to
Approver clients for approval. An approver should generally ask the user
whether they want to participate in the requested communication channels
(join the chat or chatroom, answer the call, accept the file transfer, or
whatever is appropriate). A collection of channels offered in this way
is represented by a ChannelDispatchOperation object.

If the user wishes to accept the communication channels, the approver
should call tp_cli_channel_dispatch_operation_call_handle_with() to
indicate the user's or approver's preferred handler for the channels (the
empty string indicates no particular preference, and will cause any
suitable handler to be used).

If the user wishes to reject the communication channels, or if the user
accepts the channels and the approver will handle them itself, the approver
should call tp_cli_channel_dispatch_operation_call_claim(). If this method
succeeds, the approver immediately has control over the channels as their
primary handler, and may do anything with them (in particular, it may close
them in whatever way seems most appropriate).

There are various situations in which the channel dispatch operation will
be closed, causing the #TpProxy::invalidated signal to be emitted. If this
happens, the approver should stop prompting the user.

Because all approvers are launched simultaneously, the user might respond
to another approver; if this happens, the #TpProxy::invalidated signal
will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.

If a channel closes, the #TpChannelDispatchOperation::channel-lost signal
is emitted. If all channels
close, there is nothing more to dispatch, so the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.

If the channel dispatcher crashes or exits, the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_NAME_OWNER_LOST. In a high-quality implementation, the
dispatcher should be restarted, at which point it will create new
channel dispatch operations for any undispatched channels, and the approver
will be notified again.

This proxy is usable but incomplete: accessors for the D-Bus properties will
be added in a later version of telepathy-glib, along with a mechanism
similar to tp_connection_call_when_ready().</doc>
      <constructor name="new"
                   c:identifier="tp_channel_dispatch_operation_new"
                   deprecated="Since 0.19.9. New code should get #TpChannelDispatchOperation objects from a #TpBaseClient"
                   throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new channel dispatch operation proxy.

The @immutable_properties argument is not yet used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an channel dispatch operation proxy, or %NULL if @object_path is not syntactically valid or the channel dispatcher is not running</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The non-NULL object path of this channel dispatch operation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">As many as are known of the immutable D-Bus properties of this channel dispatch operation, or %NULL if none are known</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_channel_dispatch_operation_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_dispatch_operation_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannelDispatchOperation have been
set up. This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_DISPATCH_OPERATION.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="borrow_account"
              c:identifier="tp_channel_dispatch_operation_borrow_account"
              version="0.11.5"
              introspectable="0"
              deprecated="Since 0.19.9. New code should use tp_channel_dispatch_operation_get_account() instead.">
        <doc xml:whitespace="preserve">Returns the #TpAccount of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="borrow_channels"
              c:identifier="tp_channel_dispatch_operation_borrow_channels"
              version="0.11.5"
              introspectable="0"
              deprecated="Since 0.19.9. New code should use tp_channel_dispatch_operation_get_channels() instead.">
        <doc xml:whitespace="preserve">Returns a #GPtrArray containing the #TpChannel of this
ChannelDispatchOperation.
The returned array and its #TpChannel are only valid while @self is
valid - copy array and reference channels with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:channels</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
      </method>
      <method name="borrow_connection"
              c:identifier="tp_channel_dispatch_operation_borrow_connection"
              version="0.11.5"
              introspectable="0"
              deprecated="Since 0.19.9. New code should use tp_channel_dispatch_operation_get_connection() instead.">
        <doc xml:whitespace="preserve">Returns the #TpConnection of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="borrow_immutable_properties"
              c:identifier="tp_channel_dispatch_operation_borrow_immutable_properties"
              version="0.11.5"
              introspectable="0"
              deprecated="Since 0.19.9. New code should use individual property getters like tp_channel_dispatch_operation_get_connection(), tp_channel_dispatch_operation_get_account(), tp_channel_dispatch_operation_get_channels(), or tp_channel_dispatch_operation_get_possible_handlers() instead.">
        <doc xml:whitespace="preserve">Returns the immutable D-Bus properties of this channel.
The returned hash table is only valid while @self is valid - reference
it with g_hash_table_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:cdo-properties</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="borrow_possible_handlers"
              c:identifier="tp_channel_dispatch_operation_borrow_possible_handlers"
              version="0.11.5"
              introspectable="0"
              deprecated="Since 0.19.9. New code should use tp_channel_dispatch_operation_get_possible_handlers() instead.">
        <doc xml:whitespace="preserve">Returns a #GStrv containing the possible handlers of this
ChannelDispatchOperation.
The returned array and its strings are only valid while @self is
valid - copy it with g_strdupv if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:possible-handlers</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="claim_async"
              c:identifier="tp_channel_dispatch_operation_claim_async"
              version="0.11.5"
              deprecated="since 0.15.0. Use tp_channel_dispatch_operation_claim_with_async()">
        <doc xml:whitespace="preserve">Called by an approver to claim channels for handling internally.
If this method is called successfully, the process calling this
method becomes the handler for the channel.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details. The approver MUST NOT attempt to interact with
the channels further in this case.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_finish"
              c:identifier="tp_channel_dispatch_operation_claim_finish"
              version="0.11.5"
              deprecated="since 0.15.0. Use tp_channel_dispatch_operation_claim_with_finish()"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to Claim().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_with_async"
              c:identifier="tp_channel_dispatch_operation_claim_with_async"
              version="0.15.0">
        <doc xml:whitespace="preserve">Called by an approver to claim channels for handling internally.
If this method is called successfully, the process calling this
method becomes the handler for the channel.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details. The approver MUST NOT attempt to interact with
the channels further in this case.

This is an improved version of tp_channel_dispatch_operation_claim_async()
as it tells @client about the new channels being handled.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClient claiming @self</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_with_finish"
              c:identifier="tp_channel_dispatch_operation_claim_with_finish"
              version="0.15.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to Claim() initiated using
tp_channel_dispatch_operation_claim_with_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_channels_async"
              c:identifier="tp_channel_dispatch_operation_close_channels_async"
              version="0.15.1">
        <doc xml:whitespace="preserve">Called by an approver to claim channels and close them all right away.
If this method is called successfully, @self has been claimed and
tp_channel_close_async() has been called on all of its channels.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_channels_finish"
              c:identifier="tp_channel_dispatch_operation_close_channels_finish"
              version="0.15.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async operation initiated using
tp_channel_dispatch_operation_close_channels_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful and Close() has at least been attempted on all the channels, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_channels_async"
              c:identifier="tp_channel_dispatch_operation_destroy_channels_async"
              version="0.15.2">
        <doc xml:whitespace="preserve">Called by an approver to claim channels and destroy them all right away.
If this method is called successfully, @self has been claimed and
tp_channel_destroy_async() has been called on all of its channels.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_channels_finish"
              c:identifier="tp_channel_dispatch_operation_destroy_channels_finish"
              version="0.15.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async operation initiated using
tp_channel_dispatch_operation_destroy_channels_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful and tp_channel_destroy_async() has at least been attempted on all the channels, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_account"
              c:identifier="tp_channel_dispatch_operation_get_account"
              version="0.19.9"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns the #TpAccount of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_channels"
              c:identifier="tp_channel_dispatch_operation_get_channels"
              version="0.19.9">
        <doc xml:whitespace="preserve">Returns a #GPtrArray containing the #TpChannel of this
ChannelDispatchOperation.
The returned array and its #TpChannel are only valid while @self is
valid - copy array and reference channels with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:channels</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Channel"/>
          </array>
        </return-value>
      </method>
      <method name="get_connection"
              c:identifier="tp_channel_dispatch_operation_get_connection"
              version="0.19.9"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns the #TpConnection of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="get_possible_handlers"
              c:identifier="tp_channel_dispatch_operation_get_possible_handlers"
              version="0.19.9"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns a #GStrv containing the possible handlers of this
ChannelDispatchOperation.
The returned array and its strings are only valid while @self is
valid - copy it with g_strdupv if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:possible-handlers</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="handle_with_async"
              c:identifier="tp_channel_dispatch_operation_handle_with_async"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by an approver to accept a channel bundle and request that the
given handler be used to handle it.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted with the TP_DBUS_ERROR_OBJECT_REMOVED error code.

However, this method may fail because the dispatch has already been
completed and the object has already gone. If this occurs, it indicates
that another approver has asked for the bundle to be handled by a
particular handler. The approver MUST NOT attempt to interact with
the channels further in this case, unless it is separately
invoked as the handler.

Approvers which are also channel handlers SHOULD use
tp_channel_dispatch_operation_claim_async() instead
of tp_channel_dispatch_operation_handle_with_async() to request
that they can handle a channel bundle themselves.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">The well-known bus name (starting with #TP_CLIENT_BUS_NAME_BASE) of the channel handler that should handle the channel, or %NULL if the client has no preferred channel handler</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_finish"
              c:identifier="tp_channel_dispatch_operation_handle_with_finish"
              version="0.11.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to HandleWith().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the HandleWith() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_time_async"
              c:identifier="tp_channel_dispatch_operation_handle_with_time_async"
              version="0.11.7">
        <doc xml:whitespace="preserve">A variant of tp_channel_dispatch_operation_handle_with_async()
allowing the approver to pass an user action time.
This timestamp will be passed to the Handler when HandleChannels is called.

If an X server timestamp for the user action causing this method call is
available, @user_action_time should be this timestamp (for instance, the
result of gdk_event_get_time() if it is not %GDK_CURRENT_TIME). Otherwise, it
may be %TP_USER_ACTION_TIME_NOT_USER_ACTION to behave as if there was no
user action or it happened a long time ago, or
%TP_USER_ACTION_TIME_CURRENT_TIME to have the Handler behave as though the
user action had just happened (resembling, but not numerically equal to,
%GDK_CURRENT_TIME).

This method has been introduced in telepathy-mission-control 5.5.0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">The well-known bus name (starting with #TP_CLIENT_BUS_NAME_BASE) of the channel handler that should handle the channel, or %NULL if the client has no preferred channel handler</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_time_finish"
              c:identifier="tp_channel_dispatch_operation_handle_with_time_finish"
              version="0.11.7"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to HandleWithTime().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the HandleWithTime() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_channels_async"
              c:identifier="tp_channel_dispatch_operation_leave_channels_async"
              version="0.15.2">
        <doc xml:whitespace="preserve">Called by an approver to claim channels and leave them all right away.
If this method is called successfully, @self has been claimed and
tp_channel_leave_async() has been called on all of its channels.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the leave reason</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the leave message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_channels_finish"
              c:identifier="tp_channel_dispatch_operation_leave_channels_finish"
              version="0.15.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async operation initiated using
tp_channel_dispatch_operation_leave_channels_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful and tp_channel_leave_async() has at least been attempted on all the channels, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccount with which the connection and channels are associated.

Read-only except during construction.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="Account"/>
      </property>
      <property name="cdo-properties"
                version="0.11.5"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The immutable D-Bus properties of this ChannelDispatchOperation,
represented by a #GHashTable where the keys are D-Bus
interface name + "." + property name, and the values are #GValue instances.

Read-only except during construction. If this is not provided
during construction, it is not guaranteed to be set until
tp_proxy_prepare_async() has finished preparing
%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type/>
      </property>
      <property name="channels"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing the #TpChannel to be dispatched.

Read-only.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection with which the channels are associated.

Read-only except during construction.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="Connection"/>
      </property>
      <property name="possible-handlers"
                version="0.11.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GStrv containing the well known bus names (starting
with TP_CLIENT_BUS_NAME_BASE) of the possible Handlers for
the channels

Read-only except during construction.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatchOperationPrivate"
              c:type="TpChannelDispatchOperationPrivate*"/>
      </field>
      <glib:signal name="channel-lost"
                   when="last"
                   detailed="1"
                   version="0.11.5">
        <doc xml:whitespace="preserve">Emitted when a channel has closed before it could be claimed or handled.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannel that closed</doc>
            <type name="Channel"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">domain of a #GError indicating why the channel has been closed</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">error code of a #GError indicating why the channel has been closed</doc>
            <type name="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message associated with the error</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ChannelDispatchOperationClass"
            c:type="TpChannelDispatchOperationClass"
            glib:is-gtype-struct-for="ChannelDispatchOperation">
      <doc xml:whitespace="preserve">The class of a #TpChannelDispatchOperation.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatchOperationClassPrivate"
              c:type="TpChannelDispatchOperationClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelDispatchOperationClassPrivate"
            c:type="TpChannelDispatchOperationClassPrivate"
            disguised="1">
    </record>
    <record name="ChannelDispatchOperationPrivate"
            c:type="TpChannelDispatchOperationPrivate"
            disguised="1">
    </record>
    <class name="ChannelDispatcher"
           c:symbol-prefix="channel_dispatcher"
           c:type="TpChannelDispatcher"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpChannelDispatcher"
           glib:get-type="tp_channel_dispatcher_get_type"
           glib:type-struct="ChannelDispatcherClass">
      <doc xml:whitespace="preserve">The Channel Dispatcher's main D-Bus API is used to request channels,
which is done by calling tp_cli_channel_dispatcher_call_create_channel() or
tp_cli_channel_dispatcher_call_ensure_channel() as appropriate.

The Telepathy Channel Dispatcher is also responsible for responding to new
channels and launching client processes to handle them. However, clients
that can work with incoming channels do not have to call methods
on the channel dispatcher: instead, they must register with the channel
dispatcher passively, by taking a bus name starting with
%TP_CLIENT_BUS_NAME_BASE and implementing the #TpSvcClient interface.
See the Telepathy D-Bus Interface Specification for details.

This proxy is usable but incomplete: convenience methods will be added in
a later version of telepathy-glib, along with a mechanism similar to
tp_connection_call_when_ready().</doc>
      <constructor name="new" c:identifier="tp_channel_dispatcher_new">
        <doc xml:whitespace="preserve">Convenience function to create a new channel dispatcher proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to a channel dispatcher proxy</doc>
          <type name="ChannelDispatcher" c:type="TpChannelDispatcher*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_dispatcher_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannelDispatcher have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_DISPATCHER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="present_channel_async"
              c:identifier="tp_channel_dispatcher_present_channel_async"
              version="0.15.0">
        <doc xml:whitespace="preserve">Asynchronously calls PresentChannel on the ChannelDispatcher to ask
to the handler of @channel to re-present it to the user.
You can then call tp_channel_dispatcher_present_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or #TP_USER_ACTION_TIME_NOT_USER_ACTION if this presentation request is for some reason not involving user action.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="present_channel_finish"
              c:identifier="tp_channel_dispatcher_present_channel_finish"
              version="0.15.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel presentation request started using
tp_channel_dispatcher_present_channel_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call succeeded, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatcherPrivate"
              c:type="TpChannelDispatcherPrivate*"/>
      </field>
    </class>
    <record name="ChannelDispatcherClass"
            c:type="TpChannelDispatcherClass"
            glib:is-gtype-struct-for="ChannelDispatcher">
      <doc xml:whitespace="preserve">The class of a #TpChannelDispatcher.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatcherClassPrivate"
              c:type="TpChannelDispatcherClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelDispatcherClassPrivate"
            c:type="TpChannelDispatcherClassPrivate"
            disguised="1">
    </record>
    <record name="ChannelDispatcherPrivate"
            c:type="TpChannelDispatcherPrivate"
            disguised="1">
    </record>
    <enumeration name="ChannelGroupChangeReason"
                 c:type="TpChannelGroupChangeReason">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The reason for a set of handles to move to one of           Members,           LocalPendingMembers or           RemotePendingMembers, or to be removed           from the group. A client may supply a reason when attempting to           remove members from a group with           RemoveMembersWithReason, and reasons           are supplied by the CM when emitting           MembersChanged and           MembersChangedDetailed. Some reason           codes have different meanings depending on the Actor in a           MembersChanged signal.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NONE"/>
      <member name="offline"
              value="1"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_OFFLINE"/>
      <member name="kicked"
              value="2"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_KICKED"/>
      <member name="busy"
              value="3"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BUSY"/>
      <member name="invited"
              value="4"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVITED"/>
      <member name="banned"
              value="5"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BANNED"/>
      <member name="error"
              value="6"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_ERROR"/>
      <member name="invalid_contact"
              value="7"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVALID_CONTACT"/>
      <member name="no_answer"
              value="8"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER"/>
      <member name="renamed"
              value="9"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_RENAMED"/>
      <member name="permission_denied"
              value="10"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_PERMISSION_DENIED"/>
      <member name="separated"
              value="11"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_SEPARATED"/>
    </enumeration>
    <bitfield name="ChannelGroupFlags" c:type="TpChannelGroupFlags">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="can_add"
              value="1"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_ADD"/>
      <member name="can_remove"
              value="2"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_REMOVE"/>
      <member name="can_rescind"
              value="4"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_RESCIND"/>
      <member name="message_add"
              value="8"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ADD"/>
      <member name="message_remove"
              value="16"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REMOVE"/>
      <member name="message_accept"
              value="32"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT"/>
      <member name="message_reject"
              value="64"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REJECT"/>
      <member name="message_rescind"
              value="128"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_RESCIND"/>
      <member name="channel_specific_handles"
              value="256"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES"/>
      <member name="only_one_group"
              value="512"
              c:identifier="TP_CHANNEL_GROUP_FLAG_ONLY_ONE_GROUP"/>
      <member name="handle_owners_not_available"
              value="1024"
              c:identifier="TP_CHANNEL_GROUP_FLAG_HANDLE_OWNERS_NOT_AVAILABLE"/>
      <member name="properties"
              value="2048"
              c:identifier="TP_CHANNEL_GROUP_FLAG_PROPERTIES"/>
      <member name="members_changed_detailed"
              value="4096"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED"/>
      <member name="message_depart"
              value="8192"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_DEPART"/>
    </bitfield>
    <record name="ChannelManagerIter"
            c:type="TpChannelManagerIter"
            version="0.7.15"
            introspectable="0">
      <doc xml:whitespace="preserve">An iterator over the #TpChannelManager objects known to a #TpBaseConnection.
It has no public fields.

Use tp_base_connection_channel_manager_iter_init() to start iteration and
tp_base_connection_channel_manager_iter_next() to continue.</doc>
      <field name="self" readable="0" private="1">
        <type name="BaseConnection" c:type="TpBaseConnection*"/>
      </field>
      <field name="index" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_future" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="ChannelMediaCapabilities"
              c:type="TpChannelMediaCapabilities">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The channel-type-specific capability flags used for         Channel.Type.StreamedMedia in the Connection.Interface.Capabilities         interface. See the InitialAudio         property for details of the mechanisms that will replace this.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="audio"
              value="1"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_AUDIO"/>
      <member name="video"
              value="2"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_VIDEO"/>
      <member name="nat_traversal_stun"
              value="4"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_STUN"/>
      <member name="nat_traversal_gtalk_p2p"
              value="8"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_GTALK_P2P"/>
      <member name="nat_traversal_ice_udp"
              value="16"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_ICE_UDP"/>
      <member name="immutable_streams"
              value="32"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_IMMUTABLE_STREAMS"/>
    </bitfield>
    <bitfield name="ChannelPasswordFlags" c:type="TpChannelPasswordFlags">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="provide"
              value="8"
              c:identifier="TP_CHANNEL_PASSWORD_FLAG_PROVIDE"/>
      <member name="hint"
              value="4"
              c:identifier="TP_CHANNEL_PASSWORD_FLAG_HINT"/>
    </bitfield>
    <record name="ChannelPrivate" c:type="TpChannelPrivate" disguised="1">
    </record>
    <class name="ChannelRequest"
           c:symbol-prefix="channel_request"
           c:type="TpChannelRequest"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpChannelRequest"
           glib:get-type="tp_channel_request_get_type"
           glib:type-struct="ChannelRequestClass">
      <doc xml:whitespace="preserve">Requesting a channel from the channel dispatcher can take some time, so an
object is created in the channel dispatcher to represent each request. This
proxy represents one of those objects.

Any client can call tp_cli_channel_request_call_cancel() at any time to
attempt to cancel the request.

On success, the #TpChannelRequest::succeeded signal will be emitted.
Immediately after that, the #TpProxy::invalidated signal will be emitted,
with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED (this is not an error condition, it merely
indicates that the channel request no longer exists).

On failure, the #TpProxy::invalidated signal will be emitted with some
other suitable error, usually from the %TP_ERROR domain.

If the channel dispatcher crashes or exits, the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_NAME_OWNER_LOST.

This proxy is usable but incomplete: accessors for the Account,
UserActionTime, PreferredHandler, Requests and Interfaces properties will
be added in a later version of telepathy-glib, along with a mechanism
similar to tp_connection_call_when_ready().

Until suitable convenience methods are implemented, the generic
tp_cli_dbus_properties_call_get_all() method can be used to get those
properties.</doc>
      <constructor name="new"
                   c:identifier="tp_channel_request_new"
                   deprecated="Since 0.19.9. New code should get #TpChannelRequest objects from a #TpBaseClient"
                   throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new channel request proxy.

If the channel request was newly created, the client making the request
is responsible for calling tp_cli_channel_request_call_proceed() when it
is ready for the channel request to proceed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an channel request proxy, or %NULL if @object_path is not syntactically valid or the channel dispatcher is not running</doc>
          <type name="ChannelRequest" c:type="TpChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The non-NULL object path of this channel request</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">As many as are known of the immutable D-Bus properties of this channel request, or %NULL if none are known</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_request_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannelRequest have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_REQUEST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="dup_hints"
              c:identifier="tp_channel_request_dup_hints"
              version="0.19.10">
        <doc xml:whitespace="preserve">Return the #TpChannelRequest:hints-vardict property</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:hints-vardict</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="dup_immutable_properties"
              c:identifier="tp_channel_request_dup_immutable_properties"
              version="0.19.10">
        <doc xml:whitespace="preserve">Return the #TpChannelRequest:immutable-properties-vardict property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:immutable-properties-vardict</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_account"
              c:identifier="tp_channel_request_get_account"
              version="0.15.3">
        <doc xml:whitespace="preserve">Return the value of the #TpChannelRequest:account construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_hints"
              c:identifier="tp_channel_request_get_hints"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return the #TpChannelRequest:hints property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:hints</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="get_immutable_properties"
              c:identifier="tp_channel_request_get_immutable_properties"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return the #TpChannelRequest:immutable-properties construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:immutable-properties</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="get_preferred_handler"
              c:identifier="tp_channel_request_get_preferred_handler"
              version="0.15.3">
        <doc xml:whitespace="preserve">return the #TpChannelRequest:preferred-handler construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:preferred-handler</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_user_action_time"
              c:identifier="tp_channel_request_get_user_action_time"
              version="0.15.3">
        <doc xml:whitespace="preserve">return the #TpChannelRequest:user-action-time construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:user-action-time</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="set_channel_factory"
              c:identifier="tp_channel_request_set_channel_factory"
              version="0.13.14"
              deprecated="since 0.15.5. Use #TpProxy:factory instead.">
        <doc xml:whitespace="preserve">Change the value of the #TpChannelRequest:channel-factory property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object implementing the #TpClientChannelFactoryInterface interface</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account" version="0.15.3" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccount on which this request was made, not guaranteed
to be prepared.

Read-only.</doc>
        <type name="Account"/>
      </property>
      <property name="channel-factory"
                version="0.13.14"
                deprecated="since 0.15.5. Use #TpProxy:factory instead."
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The object implementing the #TpClientChannelFactoryInterface interface
that will be used to create channel proxies when the
#TpChannelRequest::succeeded-with-channel signal is fired.
This property can be changed using
tp_channel_request_set_channel_factory().

If no channel factory is specified then #TpAutomaticProxyFactory is used.</doc>
        <type name="GObject.Object"/>
      </property>
      <property name="hints"
                version="0.13.14"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TP_HASH_TYPE_STRING_VARIANT_MAP of metadata provided by
the channel requester; or %NULL if #TpChannelRequest:immutable-properties
is not defined or if no hints has been defined.

Read-only.</doc>
        <type/>
      </property>
      <property name="hints-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A %G_VARIANT_TYPE_VARDICT of metadata provided by
the channel requester; or %NULL if #TpChannelRequest:immutable-properties
is not defined or if no hints have been defined.

Read-only.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="immutable-properties"
                version="0.13.14"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The immutable D-Bus properties of this channel request, represented by a
#GHashTable where the keys are D-Bus interface name + "." + property
name, and the values are #GValue instances.

Note that this property is set only if the immutable properties have been
set during the construction of the #TpChannelRequest.

Read-only except during construction.</doc>
        <type/>
      </property>
      <property name="immutable-properties-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The immutable D-Bus properties of this channel request, represented by a
%G_VARIANT_TYPE_VARDICT where the keys are
D-Bus interface name + "." + property name.

Note that this property is set only if the immutable properties have been
set during the construction of the #TpChannelRequest.

Read-only except during construction.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="preferred-handler"
                version="0.15.3"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Either the well-known bus name (starting with #TP_CLIENT_BUS_NAME_BASE)
of the preferred handler for this channel request,
or %NULL to indicate that any handler would be acceptable.

Read-only.</doc>
        <type name="utf8"/>
      </property>
      <property name="user-action-time"
                version="0.15.3"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The time at which user action occurred, or
#TP_USER_ACTION_TIME_NOT_USER_ACTION if this channel request is
for some reason not involving user action.

Read-only.</doc>
        <type name="gint64"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelRequestPrivate" c:type="TpChannelRequestPrivate*"/>
      </field>
      <glib:signal name="succeeded"
                   when="last"
                   detailed="1"
                   deprecated="since 0.13.14. Use #TpChannelRequest::succeeded-with-channel, which provides the resulting channel, instead.">
        <doc xml:whitespace="preserve">Emitted when the channel request succeeds.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="succeeded-with-channel"
                   when="last"
                   detailed="1"
                   version="0.13.14">
        <doc xml:whitespace="preserve">Emitted when the channel request succeeds.

With telepathy-mission-control version 5.7.1 and earlier, @connection and
@channel will be %NULL. When using newer versions, they will be correctly
set to the newly-created channel, and the connection which owns it.

The #TpChannel is created using #TpChannelRequest:channel-factory or
#TpProxy:factory but the features of the factory are NOT prepared.
It's up to the user to prepare the features returned by
tp_simple_client_factory_dup_channel_features() himself.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpConnection of @channel, or %NULL</doc>
            <type name="Connection"/>
          </parameter>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannel created, or %NULL</doc>
            <type name="Channel"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ChannelRequestClass"
            c:type="TpChannelRequestClass"
            glib:is-gtype-struct-for="ChannelRequest">
      <doc xml:whitespace="preserve">The class of a #TpChannelRequest.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelRequestClassPrivate"
              c:type="TpChannelRequestClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelRequestClassPrivate"
            c:type="TpChannelRequestClassPrivate"
            disguised="1">
    </record>
    <record name="ChannelRequestPrivate"
            c:type="TpChannelRequestPrivate"
            disguised="1">
    </record>
    <bitfield name="ChannelTextMessageFlags"
              c:type="TpChannelTextMessageFlags">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="truncated"
              value="1"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_TRUNCATED"/>
      <member name="non_text_content"
              value="2"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_NON_TEXT_CONTENT"/>
      <member name="scrollback"
              value="4"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_SCROLLBACK"/>
      <member name="rescued"
              value="8"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_RESCUED"/>
    </bitfield>
    <enumeration name="ChannelTextMessageType"
                 c:type="TpChannelTextMessageType">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The type of message.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="normal"
              value="0"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NORMAL"/>
      <member name="action"
              value="1"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION"/>
      <member name="notice"
              value="2"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NOTICE"/>
      <member name="auto_reply"
              value="3"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY"/>
      <member name="delivery_report"
              value="4"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_DELIVERY_REPORT"/>
    </enumeration>
    <enumeration name="ChannelTextSendError" c:type="TpChannelTextSendError">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_UNKNOWN"/>
      <member name="offline"
              value="1"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_OFFLINE"/>
      <member name="invalid_contact"
              value="2"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_INVALID_CONTACT"/>
      <member name="permission_denied"
              value="3"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_PERMISSION_DENIED"/>
      <member name="too_long"
              value="4"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_TOO_LONG"/>
      <member name="not_implemented"
              value="5"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_NOT_IMPLEMENTED"/>
    </enumeration>
    <callback name="ChannelWhenReadyCb"
              c:type="TpChannelWhenReadyCb"
              deprecated="0.17.6">
      <doc xml:whitespace="preserve">Signature of a callback passed to tp_channel_call_when_ready(), which
will be called exactly once, when the channel becomes ready or
invalid (whichever happens first)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:whitespace="preserve">the channel (which may be in the middle of being disposed, if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is TP_DBUS_ERROR_PROXY_UNREFERENCED)</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL if the channel is ready for use, or the error with which it was invalidated if it is now invalid</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">whatever was passed to tp_channel_call_when_ready()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="ClientChannelFactory"
               c:symbol-prefix="client_channel_factory"
               c:type="TpClientChannelFactory"
               version="0.13.6"
               glib:type-name="TpClientChannelFactory"
               glib:get-type="tp_client_channel_factory_get_type"
               glib:type-struct="ClientChannelFactoryInterface">
      <doc xml:whitespace="preserve">Opaque typedef representing a #GObject that implements
the %TP_TYPE_CLIENT_CHANNEL_FACTORY interface.</doc>
      <virtual-method name="obj_create_channel" introspectable="0" throws="1">
        <return-value>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="obj_dup_channel_features" introspectable="0">
        <return-value>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_channel"
              c:identifier="tp_client_channel_factory_create_channel"
              version="0.13.2"
              throws="1">
        <doc xml:whitespace="preserve">Function called when a channel need to be created.
Implementation can return a subclass of #TpChannel if they need to.

Changed in 0.13.6: the function's signature was previously wrong;
it expected an object instance as its first parameter, but the type of the
parameter was the type of the interface vtable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new channel proxy, or %NULL on invalid arguments</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable properties of the channel</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="dup_channel_features"
              c:identifier="tp_client_channel_factory_dup_channel_features"
              version="0.13.3">
        <doc xml:whitespace="preserve">Return a zero terminated #GArray containing the #TpChannel features that
should be prepared on @channel.

Changed in 0.13.6: the function's signature was previously wrong;
it expected an object instance as its first parameter, but the type of the
parameter was the type of the interface vtable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ClientChannelFactoryInterface"
            c:type="TpClientChannelFactoryInterface"
            glib:is-gtype-struct-for="ClientChannelFactory"
            version="0.13.2">
      <doc xml:whitespace="preserve">Interface for a channel factory</doc>
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="create_channel" introspectable="0">
        <callback name="create_channel" introspectable="0" throws="1">
          <return-value>
            <type name="Channel" c:type="TpChannel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactoryInterface"
                    c:type="TpClientChannelFactoryInterface*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_channel_features" introspectable="0">
        <callback name="dup_channel_features" introspectable="0">
          <return-value>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactoryInterface"
                    c:type="TpClientChannelFactoryInterface*"/>
            </parameter>
            <parameter name="channel" transfer-ownership="none">
              <type name="Channel" c:type="TpChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="obj_create_channel" introspectable="0">
        <callback name="obj_create_channel" introspectable="0" throws="1">
          <return-value>
            <type name="Channel" c:type="TpChannel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactory"
                    c:type="TpClientChannelFactory*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="obj_dup_channel_features" introspectable="0">
        <callback name="obj_dup_channel_features" introspectable="0">
          <return-value>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactory"
                    c:type="TpClientChannelFactory*"/>
            </parameter>
            <parameter name="channel" transfer-ownership="none">
              <type name="Channel" c:type="TpChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="ClientMessage"
           c:symbol-prefix="client_message"
           c:type="TpClientMessage"
           version="0.13.9"
           parent="Message"
           glib:type-name="TpClientMessage"
           glib:get-type="tp_client_message_get_type"
           glib:type-struct="ClientMessageClass">
      <doc xml:whitespace="preserve">Opaque structure representing a message in the Telepathy messages interface
(client side).</doc>
      <constructor name="new"
                   c:identifier="tp_client_message_new"
                   version="0.13.9">
        <doc xml:whitespace="preserve">A convenient function to create a new #TpClientMessage</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpClientMessage having only the header part.</doc>
          <type name="Message" c:type="TpMessage*"/>
        </return-value>
      </constructor>
      <constructor name="new_text"
                   c:identifier="tp_client_message_new_text"
                   version="0.13.9">
        <doc xml:whitespace="preserve">A convenient function to create a new #TpClientMessage having
'text/plain' as 'content-type', @type as 'message-type' and
@text as 'content'.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpClientMessage</doc>
          <type name="Message" c:type="TpMessage*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of message</doc>
            <type name="ChannelTextMessageType"
                  c:type="TpChannelTextMessageType"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:whitespace="preserve">content of the messsage</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <record name="ClientMessageClass"
            c:type="TpClientMessageClass"
            disguised="1"
            glib:is-gtype-struct-for="ClientMessage">
    </record>
    <bitfield name="ConnMgrParamFlags" c:type="TpConnMgrParamFlags">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="required"
              value="1"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_REQUIRED"/>
      <member name="register"
              value="2"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_REGISTER"/>
      <member name="has_default"
              value="4"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_HAS_DEFAULT"/>
      <member name="secret"
              value="8"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_SECRET"/>
      <member name="dbus_property"
              value="16"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_DBUS_PROPERTY"/>
    </bitfield>
    <class name="Connection"
           c:symbol-prefix="connection"
           c:type="TpConnection"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpConnection"
           glib:get-type="tp_connection_get_type"
           glib:type-struct="ConnectionClass">
      <doc xml:whitespace="preserve">A proxy object for a Telepathy connection. There are no interesting
public struct fields.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <constructor name="new"
                   c:identifier="tp_connection_new"
                   version="0.7.1"
                   deprecated="Use tp_simple_client_factory_ensure_connection() instead."
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new connection proxy, or %NULL if unique-name resolution fails or on invalid arguments</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="bus_name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the well-known or unique name of the connection process; if well-known, this function will make a blocking call to the bus daemon to resolve the unique name. May be %NULL if @object_path is not, in which case a well-known name will be derived from @object_path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the object path of the connection process. May be %NULL if @bus_name is a well-known name, in which case the object path will be derived from @bus_name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_aliasing"
                c:identifier="tp_connection_get_feature_quark_aliasing">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_avatar_requirements"
                c:identifier="tp_connection_get_feature_quark_avatar_requirements">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_balance"
                c:identifier="tp_connection_get_feature_quark_balance">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_capabilities"
                c:identifier="tp_connection_get_feature_quark_capabilities">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_connected"
                c:identifier="tp_connection_get_feature_quark_connected">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_blocking"
                c:identifier="tp_connection_get_feature_quark_contact_blocking">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_groups"
                c:identifier="tp_connection_get_feature_quark_contact_groups">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_info"
                c:identifier="tp_connection_get_feature_quark_contact_info">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_list"
                c:identifier="tp_connection_get_feature_quark_contact_list">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_list_properties"
                c:identifier="tp_connection_get_feature_quark_contact_list_properties">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_connection_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_connection_init_known_interfaces"
                version="0.7.6">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpConnection have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CONNECTION.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="presence_type_cmp_availability"
                c:identifier="tp_connection_presence_type_cmp_availability"
                version="0.7.16">
        <doc xml:whitespace="preserve">Compares @p1 and @p2 like strcmp(). @p1 &gt; @p2 means @p1 is more available
than @p2.

The order used is: available &gt; busy &gt; away &gt; xa &gt; hidden &gt; offline &gt; error &gt;
unknown &gt; unset</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">-1, 0 or 1, if @p1 is &lt;, == or &gt; than @p2.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnectionPresenceType</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnectionPresenceType</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_client_interest"
              c:identifier="tp_connection_add_client_interest"
              version="0.11.3">
        <doc xml:whitespace="preserve">Subscribe to any opt-in change notifications for @interested_in.

For contact information, use #TpContact instead, which will call this
automatically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interested_in" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string identifying an interface or part of an interface to which this connection will subscribe</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_client_interest_by_id"
              c:identifier="tp_connection_add_client_interest_by_id"
              version="0.11.3"
              introspectable="0">
        <doc xml:whitespace="preserve">Subscribe to any opt-in change notifications for @interested_in.

Equivalent to, but a little more efficient than, calling
tp_connection_add_client_interest() for the string value of @interested_in.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interested_in" transfer-ownership="none">
            <doc xml:whitespace="preserve">a quark identifying an interface or part of an interface to which this connection will subscribe</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_to_group_async"
              c:identifier="tp_connection_add_to_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add the given @contacts to the given @group, creating it if necessary.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to include in the group.</doc>
            <array length="1" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_to_group_finish"
              c:identifier="tp_connection_add_to_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_add_to_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_async"
              c:identifier="tp_connection_authorize_publication_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">For each of the given @contacts, request that the local user's presence is
sent to that contact, i.e. that their #TpContact:publish-state property
becomes %TP_SUBSCRIPTION_STATE_YES.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to authorize</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_finish"
              c:identifier="tp_connection_authorize_publication_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_authorize_publication_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_connection_status_to_property"
              c:identifier="tp_connection_bind_connection_status_to_property"
              version="0.13.16">
        <doc xml:whitespace="preserve">Binds the :status of @self to the boolean property of another
object using a #GBinding such that the @target_property will be set to
%TRUE when @self is connected (and @invert is %FALSE).

@target_property will be synchronised immediately (%G_BINDING_SYNC_CREATE).
@invert can be interpreted as analogous to %G_BINDING_INVERT_BOOLEAN.

For instance, this function can be used to bind the GtkWidget:sensitive
property to only make a widget sensitive when the account is connected.

See g_object_bind_property() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GBinding instance representing the binding between the @self and the @target. The binding is released whenever the #GBinding reference count reaches zero.</doc>
          <type name="GObject.Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @target to bind (must be %G_TYPE_BOOLEAN)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="invert" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if you wish to invert the value of @target_property (i.e. %FALSE if connected)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_contacts_async"
              c:identifier="tp_connection_block_contacts_async"
              version="0.17.0">
        <doc xml:whitespace="preserve">Direct the server to block @contacts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to block</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="report_abusive" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE, report these contacts as abusive to the server administrators as well as blocking them. See #TpConnection:can-report-abusive to discover whether reporting abuse is supported. If #TpConnection:can-report-abusive is %FALSE, this parameter will be ignored.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_contacts_finish"
              c:identifier="tp_connection_block_contacts_finish"
              version="0.17.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_block_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_when_ready"
              c:identifier="tp_connection_call_when_ready"
              version="0.7.7"
              introspectable="0"
              deprecated="Use tp_proxy_prepare_async()"
              deprecated-version="0.17.6">
        <doc xml:whitespace="preserve">If @self is ready for use or has been invalidated, call @callback
immediately, then return. Otherwise, arrange
for @callback to be called when @self either becomes ready for use
or becomes invalid.

Note that if the connection is not in state CONNECTED, the callback will
not be called until the connection either goes to state CONNECTED
or is invalidated (e.g. by going to state DISCONNECTED or by becoming
unreferenced). In particular, this method does not call Connect().
Call tp_cli_connection_call_connect() too, if you want to do that.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">called when the connection becomes ready or invalidated, whichever happens first</doc>
            <type name="ConnectionWhenReadyCb"
                  c:type="TpConnectionWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_report_abusive"
              c:identifier="tp_connection_can_report_abusive"
              version="0.17.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:can-report-abusive</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_set_contact_alias"
              c:identifier="tp_connection_can_set_contact_alias">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="disconnect_async"
              c:identifier="tp_connection_disconnect_async"
              version="0.17.5">
        <doc xml:whitespace="preserve">Disconnect the connection.

This method is intended for use by AccountManager implementations,
such as Mission Control. To disconnect a connection managed by an
AccountManager, either use tp_account_request_presence_async()
or tp_account_set_enabled_async(), depending whether the intention is
to put the account offline temporarily, or disable it longer-term.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_finish"
              c:identifier="tp_connection_disconnect_finish"
              version="0.17.5"
              throws="1">
        <doc xml:whitespace="preserve">Interpret the result of tp_connection_disconnect_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_by_id_async"
              c:identifier="tp_connection_dup_contact_by_id_async"
              version="0.19.0">
        <doc xml:whitespace="preserve">Create a #TpContact object and make any asynchronous method calls necessary
to ensure that all the features specified in @features are ready for use
(if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">A strings representing the desired contact by its identifier in the IM protocol (an XMPP JID, SIP URI, MSN Passport, AOL screen-name etc.)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called (may be %NULL if @n_features is 0)</doc>
            <array length="1" zero-terminated="0" c:type="TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">A user callback to call when the contact is ready</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_by_id_finish"
              c:identifier="tp_connection_dup_contact_by_id_finish"
              version="0.19.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_get_contact_by_id_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #TpContact or %NULL on error.</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_if_possible"
              c:identifier="tp_connection_dup_contact_if_possible"
              version="0.13.9">
        <doc xml:whitespace="preserve">Try to return an existing contact object or create a new contact object
immediately.

If tp_connection_has_immortal_handles() would return %TRUE and
@identifier is non-%NULL, this function always succeeds.

On connections without immortal handles, it is not possible to guarantee
that @handle remains valid without making asynchronous D-Bus calls, so
it might be necessary to delay processing of messages or other events
until a #TpContact can be constructed asynchronously, for instance by using
tp_connection_get_contacts_by_id().

Similarly, if @identifier is %NULL, it might not be possible to find the
identifier for @handle without making asynchronous D-Bus calls, so
it might be necessary to delay processing of messages or other events
until a #TpContact can be constructed asynchronously, for instance by using
tp_connection_get_contacts_by_handle().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a contact or %NULL</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle of type %TP_HANDLE_TYPE_CONTACT</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:whitespace="preserve">the normalized identifier (XMPP JID, etc.) corresponding to @handle, or %NULL if not known</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_info_supported_fields"
              c:identifier="tp_connection_dup_contact_info_supported_fields"
              version="0.19.9">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of supported contact info fields for this
connection. The list must be freed with tp_contact_info_spec_list_free().

To wait for valid supported fields, call tp_proxy_prepare_async() with the
feature %TP_CONNECTION_FEATURE_CONTACT_INFO.

This property cannot change after @self goes to the Connected state.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec struct, or %NULL if the feature is not yet prepared or the connection doesn't have the necessary properties.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoFieldSpec"/>
          </type>
        </return-value>
      </method>
      <method name="dup_contact_list"
              c:identifier="tp_connection_dup_contact_list"
              version="0.15.5">
        <doc xml:whitespace="preserve">Retrieves the user's contact list. In general, blocked contacts are not
included in this list. The #TpContact objects returned are guaranteed to
have all of the features previously passed to
tp_simple_client_factory_add_contact_features() prepared.

Before calling this method, you must first call tp_proxy_prepare_async() with
the %TP_CONNECTION_FEATURE_CONTACT_LIST feature, and verify that
#TpConnection:contact-list-state is set to %TP_CONTACT_LIST_STATE_SUCCESS.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a new #GPtrArray of #TpContact. Use g_ptr_array_unref() when done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="dup_detailed_error_vardict"
              c:identifier="tp_connection_dup_detailed_error_vardict"
              version="0.19.0">
        <doc xml:whitespace="preserve">If the connection has disconnected, return the D-Bus error name with which
it disconnected (in particular, this is %TP_ERROR_STR_CANCELLED if it was
disconnected by a user request).

Otherwise, return %NULL, without altering @details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">optionally used to return a %G_VARIANT_TYPE_VARDICT with details of the error</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_account"
              c:identifier="tp_connection_get_account"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the the #TpAccount associated with this connection. Will return %NULL
if @self was not acquired from a #TpAccount via tp_account_get_connection(),
or if the account object got finalized in the meantime (#TpConnection does
not keep a strong ref on its #TpAccount).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the account associated with this connection, or %NULL.</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_avatar_requirements"
              c:identifier="tp_connection_get_avatar_requirements"
              version="0.11.4">
        <doc xml:whitespace="preserve">To wait for valid avatar requirements, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_AVATAR_REQUIREMENTS.

This property cannot change after @self goes to the Connected state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAvatarRequirements struct, or %NULL if the feature is not yet prepared or the connection doesn't have the necessary properties.</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
      </method>
      <method name="get_balance"
              c:identifier="tp_connection_get_balance"
              version="0.15.1">
        <doc xml:whitespace="preserve">If @self has a valid account balance, returns %TRUE and sets the variables
pointed to by @balance, @scale and @currency to the appropriate fields
of the Balance.AccountBalance property.

The monetary value of the balance is expressed as a fixed-point number,
@balance, with a decimal scale defined by @scale; for instance a @balance
of 1234 with @scale of 2 represents a value of "12.34" in the currency
represented by @currency.

Requires %TP_CONNECTION_FEATURE_BALANCE to be prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the balance is valid (and the values set), %FALSE if the balance is invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="balance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to store the account balance (or %NULL)</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="scale"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to store the balance scale (or %NULL)</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="currency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to store the balance currency (or %NULL)</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_balance_uri"
              c:identifier="tp_connection_get_balance_uri"
              version="0.15.1">
        <doc xml:whitespace="preserve">The value of Balance.ManageCreditURI.

Requires %TP_CONNECTION_FEATURE_BALANCE to be prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #TpConnection:balance-uri property.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_blocked_contacts"
              c:identifier="tp_connection_get_blocked_contacts"
              version="0.17.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:blocked-contacts</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="get_can_change_contact_list"
              c:identifier="tp_connection_get_can_change_contact_list"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:can-change-contact-list property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_capabilities"
              c:identifier="tp_connection_get_capabilities"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #TpCapabilities as the #TpConnection:capabilities property</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
      </method>
      <method name="get_cm_name"
              c:identifier="tp_connection_get_cm_name"
              version="0.19.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpConnection:cm-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_connection_manager_name"
              c:identifier="tp_connection_get_connection_manager_name"
              version="0.13.16"
              deprecated="Use tp_connection_get_cm_name() instead.">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpConnection:connection-manager-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_contact_attributes"
              c:identifier="tp_connection_get_contact_attributes"
              deprecated="Use tp_simple_client_factory_ensure_contact() instead.">
        <doc xml:whitespace="preserve">Return (via a callback) any number of attributes of the given handles.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, if @hold
was %TRUE, the callback would hold a reference to them which could be
released with tp_connection_unref_handles().

This is a thin wrapper around the GetContactAttributes D-Bus method, and
should be used in preference to
tp_cli_connection_interface_contacts_call_get_contact_attributes(); mixing this
function, tp_connection_hold_handles(), tp_connection_unref_handles(), and
#TpContact with direct use of the RequestHandles, HoldHandles and
GetContactAttributes D-Bus methods is unwise, as #TpConnection and
#TpContact perform client-side reference counting of handles.
The #TpContact API provides a higher-level abstraction which should
usually be used instead.

@callback will later be called with the attributes of those of the given
handles that were valid. Invalid handles are simply omitted from the
parameter to the callback.

If @hold is %TRUE, the @callback is given one reference to each handle
that appears as a key in the callback's @attributes parameter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of handles in @handles (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of handles</doc>
            <array length="1" zero-terminated="0" c:type="TpHandle*">
              <type name="Handle" c:type="TpHandle"/>
            </array>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GStrv of interfaces</doc>
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
          <parameter name="hold" transfer-ownership="none">
            <doc xml:whitespace="preserve">if %TRUE, the callback will hold one reference to each valid handle</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="GObject.Callback"
                  c:type="tp_cli_connection_interface_contacts_callback_for_get_contact_attributes"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contact_groups"
              c:identifier="tp_connection_get_contact_groups"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:contact-groups</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_contact_info_flags"
              c:identifier="tp_connection_get_contact_info_flags"
              version="0.11.7">
        <doc xml:whitespace="preserve">Returns the flags describing how contact info (vCards) behaves on this
connection

To wait for valid contact info flags, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_CONTACT_INFO.

This property cannot change after @self goes to the Connected state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a set of #TpContactInfoFlags</doc>
          <type name="ContactInfoFlags" c:type="TpContactInfoFlags"/>
        </return-value>
      </method>
      <method name="get_contact_info_supported_fields"
              c:identifier="tp_connection_get_contact_info_supported_fields"
              version="0.11.7"
              deprecated="Since 0.19.9. New code should use tp_connection_dup_contact_info_supported_fields() instead.">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of supported contact info fields for this
connection. The list must be freed with g_list_free() after used.

Note that the #TpContactInfoFieldSpec&lt;!-- --&gt;s in the returned #GList are not
dupped before returning from this function. One could copy every item in the
list using tp_contact_info_field_spec_copy().

To wait for valid supported fields, call tp_proxy_prepare_async() with the
feature %TP_CONNECTION_FEATURE_CONTACT_INFO.

This property cannot change after @self goes to the Connected state.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec struct, or %NULL if the feature is not yet prepared or the connection doesn't have the necessary properties.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoFieldSpec"/>
          </type>
        </return-value>
      </method>
      <method name="get_contact_list_attributes"
              c:identifier="tp_connection_get_contact_list_attributes"
              deprecated="Use tp_connection_dup_contact_list() instead.">
        <doc xml:whitespace="preserve">Return (via a callback) the contacts on the contact list and any number of
their attributes.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, if @hold
was %TRUE, the callback would hold a reference to them which could be
released with tp_connection_unref_handles().

This is a thin wrapper around the RequestContactList D-Bus method,
and should be used in preference to lower-level functions; it is similar
to tp_connection_get_contact_attributes().

The #TpContact API provides a higher-level abstraction which should
usually be used instead.

If @hold is %TRUE, the @callback is given a reference to each handle
that appears as a key in the callback's @attributes parameter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds (using a large timeout is recommended)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GStrv of interfaces</doc>
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
          <parameter name="hold" transfer-ownership="none">
            <doc xml:whitespace="preserve">if %TRUE, the callback will hold one reference to each handle it receives</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="GObject.Callback"
                  c:type="tp_cli_connection_interface_contacts_callback_for_get_contact_attributes"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contact_list_persists"
              c:identifier="tp_connection_get_contact_list_persists"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:contact-list-persists property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_contact_list_state"
              c:identifier="tp_connection_get_contact_list_state"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:contact-list-state property</doc>
          <type name="ContactListState" c:type="TpContactListState"/>
        </return-value>
      </method>
      <method name="get_contacts_by_handle"
              c:identifier="tp_connection_get_contacts_by_handle"
              version="0.7.18"
              deprecated="Use tp_simple_client_factory_ensure_contact() instead.">
        <doc xml:whitespace="preserve">Create a number of #TpContact objects and make asynchronous method calls
to hold their handles and ensure that all the features specified in
@features are ready for use (if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of handles in @handles (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of handles of type %TP_HANDLE_TYPE_CONTACT representing the desired contacts</doc>
            <array length="0" zero-terminated="0" c:type="TpHandle*">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called (may be %NULL if @n_features is 0)</doc>
            <array length="2" zero-terminated="0" c:type="TpContactFeature*">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionContactsByHandleCb"
                  c:type="TpConnectionContactsByHandleCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Called to destroy @user_data either after @callback has been called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">An object to pass to the callback, which will be weakly referenced; if this object is destroyed, the operation will be cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contacts_by_id"
              c:identifier="tp_connection_get_contacts_by_id"
              version="0.7.18"
              deprecated="Use tp_connection_get_contact_by_id_async() instead.">
        <doc xml:whitespace="preserve">Create a number of #TpContact objects and make asynchronous method calls
to obtain their handles and ensure that all the features specified in
@features are ready for use (if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_ids" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of IDs in @ids (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of strings representing the desired contacts by their identifiers in the IM protocol (XMPP JIDs, SIP URIs, MSN Passports, AOL screen-names etc.)</doc>
            <array length="0" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called (may be %NULL if @n_features is 0)</doc>
            <array length="2" zero-terminated="0" c:type="TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionContactsByIdCb"
                  c:type="TpConnectionContactsByIdCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Called to destroy @user_data either after @callback has been called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">An object to pass to the callback, which will be weakly referenced; if this object is destroyed, the operation will be cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_detailed_error"
              c:identifier="tp_connection_get_detailed_error"
              version="0.11.4">
        <doc xml:whitespace="preserve">If the connection has disconnected, return the D-Bus error name with which
it disconnected (in particular, this is %TP_ERROR_STR_CANCELLED if it was
disconnected by a user request).

Otherwise, return %NULL, without altering @details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optionally used to return a map from string to #GValue, which must not be modified or destroyed by the caller</doc>
            <type name="GLib.HashTable" c:type="const GHashTable**">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_disjoint_groups"
              c:identifier="tp_connection_get_disjoint_groups"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:disjoint-groups</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_group_storage"
              c:identifier="tp_connection_get_group_storage"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:group-storage</doc>
          <type name="ContactMetadataStorageType"
                c:type="TpContactMetadataStorageType"/>
        </return-value>
      </method>
      <method name="get_protocol_name"
              c:identifier="tp_connection_get_protocol_name"
              version="0.13.16">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpConnection:protocol-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_request_uses_message"
              c:identifier="tp_connection_get_request_uses_message"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:request-uses-message property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_self_contact"
              c:identifier="tp_connection_get_self_contact"
              version="0.13.9">
        <doc xml:whitespace="preserve">Return a #TpContact representing the local user on this connection.

The returned object is not necessarily valid after the main loop is
re-entered; ref it with g_object_ref() if you want to keep it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the TpConnection:self-contact property, which may be %NULL</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="get_self_handle"
              c:identifier="tp_connection_get_self_handle"
              version="0.7.26"
              deprecated="Use tp_connection_get_self_handle() instead.">
        <doc xml:whitespace="preserve">Return the %TP_HANDLE_TYPE_CONTACT handle of the local user on this
connection, or 0 if the self-handle is not known yet or the connection
has become invalid (the TpProxy::invalidated signal).

The returned handle is not necessarily valid forever (the
notify::self-handle signal will be emitted if it changes, which can happen
on protocols such as IRC). Construct a #TpContact object if you want to
track the local user's identifier in the protocol, or other information
like their presence status, over time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the TpConnection:self-handle property</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_status"
              c:identifier="tp_connection_get_status"
              version="0.7.14">
        <doc xml:whitespace="preserve">If @reason is not %NULL it is set to the reason why "status" changed to its
current value, or %TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">This connection's status, or %TP_UNKNOWN_CONNECTION_STATUS if we don't know yet.</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a TpConnectionStatusReason, or %NULL</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_immortal_handles"
              c:identifier="tp_connection_has_immortal_handles">
        <doc xml:whitespace="preserve">Return %TRUE if this connection is known to not destroy handles
(#TpHandle) until it disconnects.

On such connections, if you know that a handle maps to a particular
identifier now, then you can rely on that handle mapping to that
identifier for the whole lifetime of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if handles last as long as the connection itself</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="hold_handles"
              c:identifier="tp_connection_hold_handles"
              deprecated="Holding handles is not needed with Connection Managers having immortal handles (any Connection Manager using telepathy-glib &gt;= 0.13.8). Other Connection Managers are considered deprecated, clients wanting to still support them should continue using this deprecated function.">
        <doc xml:whitespace="preserve">Hold (ensure a reference to) the given handles, if they are valid.

If they are valid, the callback will later be called with the given
handles; if not all of them are valid, the callback will be called with
an error.

This function, along with tp_connection_unref_handles(),
tp_connection_get_contact_attributes() and #TpContact, keeps a client-side
reference count of handles; you should not use the RequestHandles,
HoldHandles and GetContactAttributes D-Bus methods directly as well as these
functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of handles in @handles (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of handles</doc>
            <array length="2" zero-terminated="0" c:type="TpHandle*">
              <type name="Handle" c:type="TpHandle"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="ConnectionHoldHandlesCb"
                  c:type="TpConnectionHoldHandlesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ready"
              c:identifier="tp_connection_is_ready"
              version="0.7.17"
              introspectable="0"
              deprecated="use tp_proxy_is_prepared() with %TP_CONNECTION_FEATURE_CONNECTED"
              deprecated-version="0.17.6">
        <doc xml:whitespace="preserve">Returns the same thing as the #TpConnection:connection-ready property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if introspection has completed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="parse_object_path"
              c:identifier="tp_connection_parse_object_path"
              version="0.7.27"
              deprecated="Use tp_connection_get_protocol_name() and tp_connection_get_connection_manager_name() instead.">
        <doc xml:whitespace="preserve">If the object path of @connection is in the correct form, set
@protocol and @cm_name, return TRUE. Otherwise leave them unchanged and
return FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the object path was correctly parsed, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="protocol"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">If not NULL, used to return the protocol of the connection</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="cm_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">If not NULL, used to return the connection manager name of the connection</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="refresh_contact_info"
              c:identifier="tp_connection_refresh_contact_info"
              version="0.11.7">
        <doc xml:whitespace="preserve">Requests to refresh the #TpContact:contact-info property on each contact from
@contacts, requesting it from the network if an up-to-date version is not
cached locally. "notify::contact-info" will be emitted when the contact's
information are updated.

If %TP_CONTACT_FEATURE_CONTACT_INFO is not yet set on a contact, it will be
set before its property gets updated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects associated with @self</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="remove_contacts_async"
              c:identifier="tp_connection_remove_contacts_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Remove the given @contacts from the contact list entirely. It is
protocol-dependent whether this works, and under which circumstances.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to remove</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_contacts_finish"
              c:identifier="tp_connection_remove_contacts_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_remove_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_async"
              c:identifier="tp_connection_remove_from_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Remove the given @contacts from the given @group. If there are no members
left in the group afterwards, the group MAY itself be removed.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to remove from the group.</doc>
            <array length="1" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_finish"
              c:identifier="tp_connection_remove_from_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_remove_from_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group_async"
              c:identifier="tp_connection_remove_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Remove all members from the given group, then remove the group itself.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to remove.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group_finish"
              c:identifier="tp_connection_remove_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_remove_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_group_async"
              c:identifier="tp_connection_rename_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Rename the given @old_name.

On protocols where groups behave like tags, this is an API short-cut for
adding all of the group's members to a group with the new name, then removing
the old group.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to rename</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new name for the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_group_finish"
              c:identifier="tp_connection_rename_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_rename_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_handles"
              c:identifier="tp_connection_request_handles"
              deprecated="If @handle_type is TP_HANDLE_TYPE_CONTACT, use tp_connection_dup_contact_by_id_async() instead. For channel requests, use tp_account_channel_request_set_target_id() instead.">
        <doc xml:whitespace="preserve">Request the handles corresponding to the given identifiers, and if they
are valid, hold (ensure a reference to) the corresponding handles.

If they are valid, the callback will later be called with the given
handles; if not all of them are valid, the callback will be called with
an error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of string identifiers for which handles are required, terminated by %NULL (must not be %NULL or empty)</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="ConnectionRequestHandlesCb"
                  c:type="TpConnectionRequestHandlesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_async"
              c:identifier="tp_connection_request_subscription_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Request that the given @contacts allow the local user to subscribe to their
presence, i.e. that their #TpContact:subscribe-state property becomes
%TP_SUBSCRIPTION_STATE_YES.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to whom requests are to be sent.</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">an optional plain-text message from the user, to send to those @contacts with the subscription request.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_finish"
              c:identifier="tp_connection_request_subscription_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_request_subscription_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_until_ready"
              c:identifier="tp_connection_run_until_ready"
              version="0.7.1"
              introspectable="0"
              deprecated="Use tp_proxy_prepare_async() and re-enter the main loop yourself, or restructure your program in such a way as to avoid re-entering the main loop."
              deprecated-version="0.11.0">
        <doc xml:whitespace="preserve">If @self is connected and ready for use, return immediately. Otherwise,
call Connect() (unless @connect is %FALSE) and re-enter the main loop
until the connection becomes invalid, the connection connects successfully
and is introspected, or the main loop stored via @loop is cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection is now connected and ready for use, %FALSE if the connection has become invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="connect" transfer-ownership="none">
            <doc xml:whitespace="preserve">if %TRUE, call Connect() if it appears to be necessary; if %FALSE, rely on Connect() to be called by another client</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL and %FALSE is returned, used to raise an error</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a #GMainLoop is placed here while it is being run (so calling code can call g_main_loop_quit() to abort), and %NULL is placed here after the loop has been run</doc>
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_info_async"
              c:identifier="tp_connection_set_contact_info_async"
              version="0.11.7">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the contact info of @self. When
the operation is finished, @callback will be called. You can then call
tp_connection_set_contact_info_finish() to get the result of the operation.

This method should not be expected to succeed if the result of
tp_connection_get_contact_info_flags() does not include
%TP_CONTACT_INFO_FLAG_CAN_SET.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="ContactInfoField"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_info_finish"
              c:identifier="tp_connection_set_contact_info_finish"
              version="0.11.7"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of @self info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_group_members_async"
              c:identifier="tp_connection_set_group_members_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add the given @contacts to the given @group (creating it if necessary), and
remove all other members.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects members for the group. If this set is empty, this method MAY remove the group.</doc>
            <array length="1" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_group_members_finish"
              c:identifier="tp_connection_set_group_members_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_set_group_members_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_contacts_async"
              c:identifier="tp_connection_unblock_contacts_async"
              version="0.17.0">
        <doc xml:whitespace="preserve">Direct the server to unblock @contacts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to block</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_contacts_finish"
              c:identifier="tp_connection_unblock_contacts_finish"
              version="0.17.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_unblock_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_async"
              c:identifier="tp_connection_unpublish_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Attempt to set the given @contacts' #TpContact:publish-state property to
%TP_SUBSCRIPTION_STATE_NO, i.e. stop sending presence to them.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to remove</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_finish"
              c:identifier="tp_connection_unpublish_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_unpublish_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref_handles"
              c:identifier="tp_connection_unref_handles"
              deprecated="This is no-op so can be safely removed.">
        <doc xml:whitespace="preserve">Do nothing. In versions of telepathy-glib prior to 0.13.8,
this released a reference to the handles in @handles.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of handles in @handles</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of @n_handles handles</doc>
            <array length="1" zero-terminated="0" c:type="TpHandle*">
              <type name="Handle" c:type="TpHandle"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_async"
              c:identifier="tp_connection_unsubscribe_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Attempt to set the given @contacts' #TpContact:subscribe-state property to
%TP_SUBSCRIPTION_STATE_NO, i.e. stop receiving their presence.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to remove</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_finish"
              c:identifier="tp_connection_unsubscribe_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_unsubscribe_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts"
              c:identifier="tp_connection_upgrade_contacts"
              version="0.7.18"
              deprecated="Use tp_connection_upgrade_contacts_async() instead.">
        <doc xml:whitespace="preserve">Given several #TpContact objects, make asynchronous method calls
ensure that all the features specified in @features are ready for use
(if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects associated with @self</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called</doc>
            <array length="2" zero-terminated="0" c:type="TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionUpgradeContactsCb"
                  c:type="TpConnectionUpgradeContactsCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Called to destroy @user_data either after @callback has been called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">An object to pass to the callback, which will be weakly referenced; if this object is destroyed, the operation will be cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts_async"
              c:identifier="tp_connection_upgrade_contacts_async"
              version="0.19.0">
        <doc xml:whitespace="preserve">Given several #TpContact objects, make asynchronous method calls
ensure that all the features specified in @features are ready for use
(if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects associated with @self</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called</doc>
            <array length="2" zero-terminated="0" c:type="TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts_finish"
              c:identifier="tp_connection_upgrade_contacts_finish"
              version="0.19.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_upgrade_contacts_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="contacts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to set a #GPtrArray of upgraded #TpContact, or %NULL.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <property name="balance" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Amount field of the Balance.AccountBalance property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.

See Also: tp_connection_get_balance()</doc>
        <type name="gint"/>
      </property>
      <property name="balance-currency" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Currency field of the Balance.AccountBalance property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.

See Also: tp_connection_get_balance()</doc>
        <type name="utf8"/>
      </property>
      <property name="balance-scale" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Scale field of the Balance.AccountBalance property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.

See Also: tp_connection_get_balance()</doc>
        <type name="guint"/>
      </property>
      <property name="balance-uri" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Balance.ManageCreditURI property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.</doc>
        <type name="utf8"/>
      </property>
      <property name="blocked-contacts"
                version="0.17.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray of blocked #TpContact. Changes are notified using the
#TpConnection::blocked-contacts-changed signal.

These TpContact objects have been prepared with the desired features.
See tp_simple_client_factory_add_contact_features() to define which
features needs to be prepared on them.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_BLOCKING.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="can-change-contact-list"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If true, presence subscription and publication can be changed using the
RequestSubscription, AuthorizePublication and RemoveContacts methods.

Rational: link-local XMPP, presence is implicitly published to everyone in
the local subnet, so the user cannot control their presence publication.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="gboolean"/>
      </property>
      <property name="can-report-abusive"
                version="0.17.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this property is %TRUE, contacts may be reported as abusive to the
server administrators by setting report_abusive to %TRUE when calling
tp_connection_block_contacts_async().

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_BLOCKING.</doc>
        <type name="gboolean"/>
      </property>
      <property name="capabilities" transfer-ownership="none">
        <doc xml:whitespace="preserve">The %TpCapabilities object representing the capabilities of this
connection, or NULL if we don't know yet.

To wait for valid capability information, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_CAPABILITIES.</doc>
        <type name="Capabilities"/>
      </property>
      <property name="cm-name" version="0.19.3" transfer-ownership="none">
        <doc xml:whitespace="preserve">This connection's connection manager name.</doc>
        <type name="utf8"/>
      </property>
      <property name="connection-manager-name"
                version="0.13.16"
                deprecated="Use #TpConnection:cm-name instead."
                transfer-ownership="none">
        <doc xml:whitespace="preserve">This connection's connection manager name.</doc>
        <type name="utf8"/>
      </property>
      <property name="connection-ready"
                deprecated="use tp_proxy_is_prepared() with %TP_CHANNEL_FEATURE_CONNECTED for checks, or tp_proxy_prepare_async() for notification"
                deprecated-version="0.17.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Initially %FALSE; changes to %TRUE when the connection has gone to
CONNECTED status, introspection has finished and it's ready for use.

By the time this property becomes %TRUE, any extra interfaces will
have been set up and the #TpProxy:interfaces property will have been
populated.

This is similar to %TP_CONNECTION_FEATURE_CONNECTED, except that once
it has changed to %TRUE, it remains %TRUE even if the connection has
been invalidated.</doc>
        <type name="gboolean"/>
      </property>
      <property name="contact-groups"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The names of all groups that currently exist. This may be a larger set than
the union of all #TpContact:contact-groups properties, if the connection
allows groups to be empty.

This property's value is not meaningful until the
#TpConnection:contact-list-state property has become
%TP_CONTACT_LIST_STATE_SUCCESS.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="contact-list-persists"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If true, presence subscriptions (in both directions) on this connection are
stored by the server or other infrastructure.

If false, presence subscriptions on this connection are not stored.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="gboolean"/>
      </property>
      <property name="contact-list-state"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The progress made in retrieving the contact list.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="guint"/>
      </property>
      <property name="disjoint-groups"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">True if each contact can be in at most one group; false if each contact
can be in many groups.

This property cannot change after the connection has moved to the
%TP_CONNECTION_STATUS_CONNECTED state. Until then, its value is undefined,
and it may change at any time, without notification.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <type name="gboolean"/>
      </property>
      <property name="group-storage"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Indicates the extent to which contacts' groups can be set and stored.

This property cannot change after the connection has moved to the
%TP_CONNECTION_STATUS_CONNECTED state. Until then, its value is undefined,
and it may change at any time, without notification.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <type name="guint"/>
      </property>
      <property name="protocol-name"
                version="0.13.16"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The connection's machine-readable protocol name, such as "jabber",
"msn" or "local-xmpp". Recommended names for most protocols can be
found in the Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8"/>
      </property>
      <property name="request-uses-message"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If true, the Message parameter to RequestSubscription is likely to be
significant, and user interfaces SHOULD prompt the user for a message to
send with the request; a message such as "I would like to add you to my
contact list", translated into the local user's language, might make a
suitable default.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="gboolean"/>
      </property>
      <property name="self-contact" version="0.13.9" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpContact representing the local user on this connection,
or %NULL if not yet available.

If the local user's unique identifier changes (for instance by using
/nick on IRC), this property will change to a different #TpContact object
representing the new identifier, and #GObject::notify will be emitted.

The #TpContact object is guaranteed to have all of the features previously
passed to tp_simple_client_factory_add_contact_features() prepared.

To wait for a non-%NULL self-contact (and other properties), call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONNECTED.</doc>
        <type name="Contact"/>
      </property>
      <property name="self-handle"
                deprecated="Use #TpConnection:self-contact instead."
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The %TP_HANDLE_TYPE_CONTACT handle of the local user on this connection,
or 0 if we don't know yet or if the connection has become invalid.

This may change if the local user's unique identifier changes (for
instance by using /nick on IRC), in which case #GObject::notify will be
emitted.

To wait for a valid self-handle (and other properties), call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONNECTED.</doc>
        <type name="guint"/>
      </property>
      <property name="status" transfer-ownership="none">
        <doc xml:whitespace="preserve">This connection's status, or %TP_UNKNOWN_CONNECTION_STATUS if we don't
know yet.

To wait for a valid status (and other properties), call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_CORE.

Since version 0.11.3, the change to status
%TP_CONNECTION_STATUS_CONNECTED is delayed slightly, until introspection
of the connection has finished.</doc>
        <type name="guint"/>
      </property>
      <property name="status-reason" transfer-ownership="none">
        <doc xml:whitespace="preserve">To wait for a valid status (and other properties), call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_CORE.

The reason why #TpConnection:status changed to its current value,
or TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown.
know yet.</doc>
        <type name="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ConnectionPrivate" c:type="TpConnectionPrivate*"/>
      </field>
      <glib:signal name="balance-changed"
                   when="last"
                   detailed="1"
                   version="0.15.1">
        <doc xml:whitespace="preserve">Emitted when at least one of the #TpConnection:balance,
#TpConnection:balance-scale or #TpConnection:balance-currency
property is changed.

For this signal to be emitted, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="balance" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpConnection:balance property</doc>
            <type name="gint"/>
          </parameter>
          <parameter name="balance_scale" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpConnection:balance-scale property</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="balance_currency" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpConnection:balance-currency property</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="blocked-contacts-changed"
                   when="last"
                   version="0.17.0">
        <doc xml:whitespace="preserve">Notify of changes in #TpConnection:blocked-contacts.
 It is guaranteed that all contacts have desired features prepared. See
tp_simple_client_factory_add_contact_features() to define which features
needs to be prepared.

This signal is also emitted for the initial set of blocked contacts once
retrieved.

For this signal to be emitted, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_BLOCKING.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of #TpContact which have been blocked</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of #TpContact which are no longer blocked</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="contact-list-changed" when="last" version="0.15.5">
        <doc xml:whitespace="preserve">Notify of changes in the list of contacts as returned by
tp_connection_dup_contact_list(). It is guaranteed that all contacts have
desired features prepared. See
tp_simple_client_factory_add_contact_features() to define which features
needs to be prepared.

This signal is also emitted for the initial set of contacts once retrieved.

For this signal to be emitted, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of #TpContact added to contacts list</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPtrArray of #TpContact removed from contacts list</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-renamed" when="last" version="0.15.5">
        <doc xml:whitespace="preserve">Emitted when a group is renamed, in protocols where this can be
distinguished from group creation, removal and membership changes.

Immediately after this signal is emitted, #TpConnection::groups-created
signal the creation of a group with the new name, and
#TpConnection::groups-removed signal the removal of a group with the old
name.
If the group was not empty, immediately after those signals are emitted,
#TpContact::contact-groups-changed signal that the members of that group
were removed from the old name and added to the new name.

When this signal is emitted, #TpConnection:contact-groups property is
already updated.

For this signal to be emited, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the old name of the group.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new name of the group.</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="groups-created" when="last" version="0.15.5">
        <doc xml:whitespace="preserve">Emitted when new, empty groups are created. This will often be followed by
#TpContact::contact-groups-changed signals that add some members. When this
signal is emitted, #TpConnection:contact-groups property is already
updated.

For this signal to be emited, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GStrv with the names of the new groups.</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="groups-removed" when="last" version="0.15.5">
        <doc xml:whitespace="preserve">Emitted when one or more groups are removed. If they had members at the
time that they were removed, then immediately after this signal is emitted,
#TpContact::contact-groups-changed signals that their members were removed.
When this signal is emitted, #TpConnection:contact-groups property is
already updated.

For this signal to be emited, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GStrv with the names of the groups.</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="ConnectionAliasFlags" c:type="TpConnectionAliasFlags">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="connection_alias_flag_user_set"
              value="1"
              c:identifier="TP_CONNECTION_ALIAS_FLAG_USER_SET"/>
    </bitfield>
    <bitfield name="ConnectionCapabilityFlags"
              c:type="TpConnectionCapabilityFlags">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="create"
              value="1"
              c:identifier="TP_CONNECTION_CAPABILITY_FLAG_CREATE"/>
      <member name="invite"
              value="2"
              c:identifier="TP_CONNECTION_CAPABILITY_FLAG_INVITE"/>
    </bitfield>
    <record name="ConnectionClass"
            c:type="TpConnectionClass"
            glib:is-gtype-struct-for="Connection"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpConnection. In addition to @parent_class there are four
pointers reserved for possible future use.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <callback name="ConnectionContactsByHandleCb"
              c:type="TpConnectionContactsByHandleCb"
              version="0.7.18">
      <doc xml:whitespace="preserve">Signature of a callback used to receive the result of
tp_connection_get_contacts_by_handle().

If an unrecoverable error occurs (for instance, if @connection
becomes disconnected) the whole operation fails, and no contacts or
invalid handles are returned.

If some or even all of the @handles passed to
tp_connection_get_contacts_by_handle() were not valid, this is not
considered to be a failure. @error will be %NULL in this situation,
@contacts will contain contact objects for those handles that were
valid (possibly none of them), and @invalid will contain the handles
that were not valid.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of TpContact objects successfully created (one per valid handle), or 0 on unrecoverable errors</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts TpContact objects (this callback is not given a reference to any of these objects, and must call g_object_ref() on any that it will keep), or %NULL on unrecoverable errors</doc>
          <array length="1" zero-terminated="0" c:type="TpContact**">
            <type name="Contact" c:type="TpContact*"/>
          </array>
        </parameter>
        <parameter name="n_failed" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of invalid handles that were passed to tp_connection_get_contacts_by_handle() (or on unrecoverable errors, the total number of handles that were given)</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="failed" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_failed handles that were passed to tp_connection_get_contacts_by_handle() but turned out to be invalid (or on unrecoverable errors, all the handles that were given)</doc>
          <array length="3" zero-terminated="0" c:type="TpHandle*">
            <type name="Handle" c:type="TpHandle"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an unrecoverable error that caused everything to fail</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">the @user_data that was passed to tp_connection_get_contacts_by_handle()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object that was passed to tp_connection_get_contacts_by_handle()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionContactsByIdCb"
              c:type="TpConnectionContactsByIdCb"
              version="0.7.18">
      <doc xml:whitespace="preserve">Signature of a callback used to receive the result of
tp_connection_get_contacts_by_id().

@requested_ids contains the IDs that were converted to handles successfully.
The normalized form of requested_ids[i] is
tp_contact_get_identifier (contacts[i]).

If some or even all of the @ids passed to
tp_connection_get_contacts_by_id() were not valid, this is not
considered to be a fatal error. @error will be %NULL in this situation,
@contacts will contain contact objects for those IDs that were
valid (it may be empty), and @failed_id_errors will map the IDs
that were not valid to a corresponding #GError (if the connection manager
complies with the Telepathy spec, it will have domain %TP_ERROR and code
%TP_ERROR_INVALID_HANDLE).

If an unrecoverable error occurs (for instance, if @connection
becomes disconnected) the whole operation fails, and no contacts
or requested IDs are returned. @failed_id_errors will contain all the IDs
that were requested, mapped to a corresponding #GError (either one
indicating that the ID was invalid, if that was determined before the
fatal error occurred, or a copy of @error).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of TpContact objects successfully created (one per valid ID), or 0 on unrecoverable errors</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts TpContact objects (this callback is not given a reference to any of these objects, and must call g_object_ref() on any that it will keep), or %NULL on unrecoverable errors</doc>
          <array length="1" zero-terminated="0" c:type="TpContact**">
            <type name="Contact" c:type="TpContact*"/>
          </array>
        </parameter>
        <parameter name="requested_ids" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts valid IDs (JIDs, SIP URIs etc.) that were passed to tp_connection_get_contacts_by_id(), in an order corresponding to @contacts, or %NULL on unrecoverable errors</doc>
          <array length="1" zero-terminated="0" c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="failed_id_errors" transfer-ownership="none">
          <doc xml:whitespace="preserve">A hash table in which the keys are IDs and the values are errors (#GError)</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.Error"/>
          </type>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an unrecoverable error that caused everything to fail</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">the @user_data that was passed to tp_connection_get_contacts_by_id()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object that was passed to tp_connection_get_contacts_by_id()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionHoldHandlesCb"
              c:type="TpConnectionHoldHandlesCb"
              deprecated="See tp_connection_hold_handles().">
      <doc xml:whitespace="preserve">Signature of the callback called when tp_connection_hold_handles() succeeds
or fails.

On success, the caller has a reference to each handle in @handles.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, they could be
released with tp_connection_unref_handles().

For convenience, the handle type and handles requested by the caller are
passed through to this callback on success, so the caller does not have to
include them in @user_data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle type that was passed to tp_connection_hold_handles()</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of handles that were passed to tp_connection_hold_handles() on success, or 0 on failure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">a copy of the array of @n_handles handles that was passed to tp_connection_hold_handles() on success, or %NULL on failure</doc>
          <type name="Handle" c:type="const TpHandle*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error on failure</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">the same arbitrary pointer that was passed to tp_connection_hold_handles()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the same object that was passed to tp_connection_hold_handles()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ConnectionManager"
           c:symbol-prefix="connection_manager"
           c:type="TpConnectionManager"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpConnectionManager"
           glib:get-type="tp_connection_manager_get_type"
           glib:type-struct="ConnectionManagerClass">
      <doc xml:whitespace="preserve">A proxy object for a Telepathy connection manager.

This might represent a connection manager which is currently running
(in which case it can be introspected) or not (in which case its
capabilities can be read from .manager files in the filesystem).
Accordingly, this object never emits #TpProxy::invalidated unless all
references to it are discarded.

Various fields and methods on this object do not work until
%TP_CONNECTION_MANAGER_FEATURE_CORE is prepared. Use
tp_proxy_prepare_async() to wait for this to happen.

Since 0.19.1, accessing the fields of this struct is deprecated,
and they are no longer documented here.
Use the accessors tp_connection_manager_get_name(),
tp_connection_manager_is_running(),
tp_connection_manager_dup_protocols(),
tp_connection_manager_get_info_source()
and the #TpConnectionManager:always-introspect property instead.</doc>
      <constructor name="new"
                   c:identifier="tp_connection_manager_new"
                   throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new connection manager proxy. If
its protocol and parameter information are required, you should call
tp_proxy_prepare_async() on the result.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to a connection manager proxy, or %NULL if @error is set.</doc>
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The connection manager name (such as "gabble")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="manager_filename"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">The #TpConnectionManager:manager-file property, which may (and generally should) be %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="check_valid_name"
                c:identifier="tp_connection_manager_check_valid_name"
                version="0.7.1"
                throws="1">
        <doc xml:whitespace="preserve">Check that the given string is a valid connection manager name, i.e. that
it consists entirely of ASCII letters, digits and underscores, and starts
with a letter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a possible connection manager name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="check_valid_protocol_name"
                c:identifier="tp_connection_manager_check_valid_protocol_name"
                version="0.7.1"
                throws="1">
        <doc xml:whitespace="preserve">Check that the given string is a valid protocol name, i.e. that
it consists entirely of ASCII letters, digits and hyphen/minus, and starts
with a letter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a possible protocol name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_connection_manager_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_connection_manager_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpConnectionManager have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CONNECTION_MANAGER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="activate"
              c:identifier="tp_connection_manager_activate"
              version="0.7.1"
              introspectable="0">
        <doc xml:whitespace="preserve">Attempt to run and introspect the connection manager, asynchronously.
Since 0.7.26 this function is not generally very useful, since
the connection manager will now be activated automatically if necessary.

If the CM was already running, do nothing and return %FALSE.

On success, emit #TpConnectionManager::activated when the CM appears
on the bus, and #TpConnectionManager::got-info when its capabilities
have been (re-)discovered.

On failure, emit #TpConnectionManager::exited without first emitting
activated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if activation was needed and is now in progress, %FALSE if the connection manager was already running and no additional signals will be emitted.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="call_when_ready"
              c:identifier="tp_connection_manager_call_when_ready"
              version="0.7.26"
              introspectable="0"
              deprecated="since 0.17.6, use tp_proxy_prepare_async() instead">
        <doc xml:whitespace="preserve">Call the @callback from the main loop when information about @cm's
supported protocols and parameters has been retrieved.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">callback to call when information has been retrieved or on error</doc>
            <type name="ConnectionManagerWhenReadyCb"
                  c:type="TpConnectionManagerWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">object to reference weakly; if it is destroyed, @callback will not be called, but @destroy will still be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_protocol_names"
              c:identifier="tp_connection_manager_dup_protocol_names"
              version="0.7.26">
        <doc xml:whitespace="preserve">Returns a list of protocol names supported by this connection manager.
These are the internal protocol names used by the Telepathy specification
(e.g. "jabber" and "msn"), rather than user-visible names in any particular
locale.

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use
tp_proxy_prepare_async() to wait for this.

The result is copied and must be freed by the caller, but it is not
necessarily still true after the main loop is re-entered.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GStrv of protocol names</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="dup_protocols"
              c:identifier="tp_connection_manager_dup_protocols"
              version="0.17.6">
        <doc xml:whitespace="preserve">Return objects representing all protocols supported by this connection
manager.

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use tp_proxy_prepare_async()
to wait for this.

The caller must free the list, for instance with
&lt;literal&gt;g_list_free_full (l, g_object_unref)&lt;/literal&gt;.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a list of #TpProtocol objects representing the protocols supported by @self, owned by the caller</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Protocol"/>
          </type>
        </return-value>
      </method>
      <method name="get_info_source"
              c:identifier="tp_connection_manager_get_info_source"
              version="0.7.26">
        <doc xml:whitespace="preserve">If protocol and parameter information has been obtained from the connection
manager, return %TP_CM_INFO_SOURCE_LIVE; if it has been obtained from the
cache in the .manager file, return %TP_CM_INFO_SOURCE_FILE. If this
information has not yet been obtained, or obtaining it failed, return
%TP_CM_INFO_SOURCE_NONE.

This may increase at any time that the main loop is running; the
#GObject::notify signal is emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpConnectionManager:info-source property</doc>
          <type name="CMInfoSource" c:type="TpCMInfoSource"/>
        </return-value>
      </method>
      <method name="get_name"
              c:identifier="tp_connection_manager_get_name"
              version="0.7.26">
        <doc xml:whitespace="preserve">Return the internal name of this connection manager in the Telepathy
D-Bus API, e.g. "gabble" or "haze". This is often the name of the binary
without the "telepathy-" prefix.

The returned string is valid as long as @self is. Copy it with g_strdup()
if a longer lifetime is required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #TpConnectionManager:cm-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_protocol"
              c:identifier="tp_connection_manager_get_protocol"
              version="0.7.26"
              deprecated="0.19.1, use tp_connection_manager_get_protocol_object()">
        <doc xml:whitespace="preserve">Returns a structure representing a protocol, or %NULL if this connection
manager does not support the specified protocol.

Since 0.11.11, you can get a #GObject version with more
functionality by calling tp_connection_manager_get_protocol_object().

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use
tp_proxy_prepare_async() to wait for this.

The result is not necessarily valid after the main loop is re-entered.
Since 0.11.3, it can be copied with tp_connection_manager_protocol_copy()
if a permanently-valid copy is needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a structure representing the protocol</doc>
          <type name="ConnectionManagerProtocol"
                c:type="const TpConnectionManagerProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol as defined in the Telepathy D-Bus API, e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_protocol_object"
              c:identifier="tp_connection_manager_get_protocol_object"
              version="0.11.11">
        <doc xml:whitespace="preserve">Returns an object representing a protocol, or %NULL if this connection
manager does not support the specified protocol.

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use tp_proxy_prepare_async()
to wait for this.

The result should be referenced with g_object_ref() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an object representing the protocol, or %NULL</doc>
          <type name="Protocol" c:type="TpProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol as defined in the Telepathy D-Bus API, e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_protocol"
              c:identifier="tp_connection_manager_has_protocol"
              version="0.7.26">
        <doc xml:whitespace="preserve">Return whether @protocol is supported by this connection manager.

If this function is called before the connection manager information has
been obtained, the result is always %FALSE. Use tp_proxy_prepare_async()
to wait for this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this connection manager supports @protocol</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol as defined in the Telepathy D-Bus API, e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ready"
              c:identifier="tp_connection_manager_is_ready"
              version="0.7.26"
              introspectable="0"
              deprecated="since 0.17.6, use tp_proxy_is_prepared() with %TP_CONNECTION_MANAGER_FEATURE_CORE instead">
        <doc xml:whitespace="preserve">If protocol and parameter information has been obtained from the connection
manager or the cache in the .manager file, return %TRUE. Otherwise,
return %FALSE.

This may change from %FALSE to %TRUE at any time that the main loop is
running; the #GObject::notify signal is emitted for the
#TpConnectionManager:info-source property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, unless the #TpConnectionManager:info-source property is %TP_CM_INFO_SOURCE_NONE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_running"
              c:identifier="tp_connection_manager_is_running"
              version="0.7.26">
        <doc xml:whitespace="preserve">Return %TRUE if this connection manager currently appears to be running.
This may change at any time that the main loop is running; the
#TpConnectionManager::activated and #TpConnectionManager::exited signals
are emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the connection manager is currently running</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="always-introspect"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, always introspect the connection manager as it comes online,
even if we already have its info from a .manager file. Default %FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="cm-name" version="0.19.3" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the connection manager, e.g. "gabble" (read-only).</doc>
        <type name="utf8"/>
      </property>
      <property name="connection-manager"
                deprecated="Use #TpConnectionManager:cm-name instead."
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the connection manager, e.g. "gabble" (read-only).</doc>
        <type name="utf8"/>
      </property>
      <property name="info-source" transfer-ownership="none">
        <doc xml:whitespace="preserve">Where we got the current information on supported protocols
(a #TpCMInfoSource).

Since 0.7.26, the #GObject::notify signal is emitted for this
property.

(Note that this is of type %G_TYPE_UINT, not %TP_TYPE_CM_INFO_SOURCE,
for historical reasons.)</doc>
        <type name="guint"/>
      </property>
      <property name="manager-file"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The absolute path of the .manager file. If set to %NULL (the default),
the XDG data directories will be searched for a .manager file of the
correct name.

If set to the empty string, no .manager file will be read.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="protocols" readable="0" private="1">
        <type name="ConnectionManagerProtocol"
              c:type="const TpConnectionManagerProtocol* const*"/>
      </field>
      <field name="running" readable="0" bits="1" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="always_introspect" readable="0" bits="1" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="info_source" readable="0" bits="2" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="reserved_flags" readable="0" bits="28" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ConnectionManagerPrivate"
              c:type="TpConnectionManagerPrivate*"/>
      </field>
      <glib:signal name="activated" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when the connection manager's well-known name appears on the bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="exited" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when the connection manager's well-known name disappears from
the bus or when activation fails.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-info" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when the connection manager's capabilities have been discovered.

This signal is not very helpful. Using
tp_proxy_prepare_async() instead is recommended.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpCMInfoSource</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ConnectionManagerClass"
            c:type="TpConnectionManagerClass"
            glib:is-gtype-struct-for="ConnectionManager"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpConnectionManager.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer*"/>
      </field>
    </record>
    <callback name="ConnectionManagerListCb"
              c:type="TpConnectionManagerListCb"
              version="0.7.1">
      <doc xml:whitespace="preserve">Signature of the callback supplied to tp_list_connection_managers().

Since 0.11.3, tp_list_connection_managers() will
wait for %TP_CONNECTION_MANAGER_FEATURE_CORE to be prepared on each
connection manager passed to @callback, unless an error occurred while
launching that connection manager.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cms" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of #TpConnectionManager (the objects will be unreferenced and the array will be freed after the callback returns, so the callback must reference any CMs it stores a pointer to), or %NULL on error</doc>
          <array c:type="TpConnectionManager**">
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </array>
        </parameter>
        <parameter name="n_cms" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of connection managers in @cms (not including the final %NULL)</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error that occurred</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user-supplied data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied weakly referenced object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ConnectionManagerParam"
            c:type="TpConnectionManagerParam"
            version="0.7.1"
            glib:type-name="TpConnectionManagerParam"
            glib:get-type="tp_connection_manager_param_get_type"
            c:symbol-prefix="connection_manager_param">
      <doc xml:whitespace="preserve">Structure representing a connection manager parameter.

Since 0.19.1, accessing the fields of this struct is deprecated,
and they are no longer documented here.
Use the accessors tp_connection_manager_param_get_name(),
tp_connection_manager_param_get_dbus_signature(),
tp_connection_manager_param_is_required(),
tp_connection_manager_param_is_required_for_registration(),
tp_connection_manager_param_is_secret(),
tp_connection_manager_param_is_dbus_property(),
tp_connection_manager_param_get_default(),
tp_connection_manager_param_dup_default_variant() instead.</doc>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="dbus_signature" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="default_value" readable="0" private="1">
        <type name="GObject.Value" c:type="GValue"/>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="copy"
              c:identifier="tp_connection_manager_param_copy"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- Returns: says it all --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly (slice) allocated #TpConnectionManagerParam, free with tp_connection_manager_param_free()</doc>
          <type name="ConnectionManagerParam"
                c:type="TpConnectionManagerParam*"/>
        </return-value>
      </method>
      <method name="dup_default_variant"
              c:identifier="tp_connection_manager_param_dup_default_variant"
              version="0.19.0">
        <doc xml:whitespace="preserve">Get the default value for this parameter.

Use g_variant_get_type() to check that the type is what you expect.
For instance, a string parameter should have type
%G_VARIANT_TYPE_STRING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the default value, or %NULL if there is no default</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="free"
              c:identifier="tp_connection_manager_param_free"
              version="0.11.3">
        <doc xml:whitespace="preserve">Frees @param, which was copied with tp_connection_manager_param_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_dbus_signature"
              c:identifier="tp_connection_manager_param_get_dbus_signature"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the D-Bus signature of the parameter</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_default"
              c:identifier="tp_connection_manager_param_get_default"
              version="0.7.26">
        <doc xml:whitespace="preserve">Get the default value for this parameter, if there is one. If %FALSE is
returned, @value is left uninitialized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if there is a default value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to an unset (all zeroes) #GValue into which the default's type and value are written</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_connection_manager_param_get_name"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the parameter</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="is_dbus_property"
              c:identifier="tp_connection_manager_param_is_dbus_property"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter represents a D-Bus property of the same name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_required"
              c:identifier="tp_connection_manager_param_is_required"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter is normally required</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_required_for_registration"
              c:identifier="tp_connection_manager_param_is_required_for_registration"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter is required when registering a new account (by setting the special "register" parameter to %TRUE)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_secret"
              c:identifier="tp_connection_manager_param_is_secret"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter's value is a password or other secret</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </record>
    <record name="ConnectionManagerPrivate"
            c:type="TpConnectionManagerPrivate"
            disguised="1">
    </record>
    <record name="ConnectionManagerProtocol"
            c:type="TpConnectionManagerProtocol"
            version="0.7.1"
            deprecated="0.19.1, use #TpProtocol objects instead"
            glib:type-name="TpConnectionManagerProtocol"
            glib:get-type="tp_connection_manager_protocol_get_type"
            c:symbol-prefix="connection_manager_protocol">
      <doc xml:whitespace="preserve">Structure representing a protocol supported by a connection manager.
Note that the size of this structure may change, so its size must not be
relied on.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="params" writable="1">
        <type name="ConnectionManagerParam"
              c:type="TpConnectionManagerParam*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="can_register"
              c:identifier="tp_connection_manager_protocol_can_register"
              version="0.7.26"
              deprecated="0.19.1, use #TpProtocol objects instead">
        <doc xml:whitespace="preserve">Return whether a new account can be registered on this protocol, by setting
the special "register" parameter to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @protocol supports the parameter "register"</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="copy"
              c:identifier="tp_connection_manager_protocol_copy"
              version="0.11.3"
              deprecated="0.19.1, use #TpProtocol objects instead">
        <doc xml:whitespace="preserve">&lt;!-- Returns: says it all --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly (slice) allocated #TpConnectionManagerProtocol, free with tp_connection_manager_protocol_free()</doc>
          <type name="ConnectionManagerProtocol"
                c:type="TpConnectionManagerProtocol*"/>
        </return-value>
      </method>
      <method name="dup_param_names"
              c:identifier="tp_connection_manager_protocol_dup_param_names"
              version="0.7.26"
              deprecated="0.19.1, use #TpProtocol objects instead">
        <doc xml:whitespace="preserve">Returns a list of parameter names supported by this connection manager
for this protocol.

The result is copied and must be freed by the caller with g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GStrv of protocol names</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="free"
              c:identifier="tp_connection_manager_protocol_free"
              version="0.11.3"
              deprecated="0.19.1, use #TpProtocol objects instead">
        <doc xml:whitespace="preserve">Frees @proto, which was copied with tp_connection_manager_protocol_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_param"
              c:identifier="tp_connection_manager_protocol_get_param"
              version="0.7.26"
              deprecated="0.19.1, use #TpProtocol objects instead">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a structure representing the parameter @param, or %NULL if not supported</doc>
          <type name="ConnectionManagerParam"
                c:type="const TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_param"
              c:identifier="tp_connection_manager_protocol_has_param"
              version="0.7.26"
              deprecated="0.19.1, use #TpProtocol objects instead">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @protocol supports the parameter @param.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="ConnectionManagerWhenReadyCb"
              c:type="TpConnectionManagerWhenReadyCb"
              deprecated="since 0.17.6, use tp_proxy_prepare_async() instead">
      <doc xml:whitespace="preserve">Called as the result of tp_connection_manager_call_when_ready(). If the
connection manager's protocol and parameter information could be retrieved,
@error is %NULL and @cm is considered to be ready. Otherwise, @error is
non-%NULL and @cm is not ready.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cm" transfer-ownership="none">
          <doc xml:whitespace="preserve">a connection manager</doc>
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or the reason why tp_connection_manager_is_ready() would return %FALSE</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">the @user_data passed to tp_connection_manager_call_when_ready()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object passed to tp_connection_manager_call_when_ready()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionNameListCb"
              c:type="TpConnectionNameListCb"
              version="0.7.1">
      <doc xml:whitespace="preserve">Signature of the callback supplied to tp_list_connection_names().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="names" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of @n connection bus names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of names (not including the final %NULL), or 0 on error</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="cms" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of @n connection manager names (e.g. "gabble") in the same order as @names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="protocols" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of @n protocol names as defined in the Telepathy spec (e.g. "jabber") in the same order as @names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error that occurred</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">user-supplied data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied weakly referenced object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionPresenceType"
                 c:type="TpConnectionPresenceType">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unset"
              value="0"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNSET"/>
      <member name="offline"
              value="1"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_OFFLINE"/>
      <member name="available"
              value="2"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_AVAILABLE"/>
      <member name="away"
              value="3"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_AWAY"/>
      <member name="extended_away"
              value="4"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_EXTENDED_AWAY"/>
      <member name="hidden"
              value="5"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_HIDDEN"/>
      <member name="busy"
              value="6"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_BUSY"/>
      <member name="unknown"
              value="7"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNKNOWN"/>
      <member name="error"
              value="8"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_ERROR"/>
    </enumeration>
    <record name="ConnectionPrivate"
            c:type="TpConnectionPrivate"
            disguised="1">
    </record>
    <callback name="ConnectionRequestHandlesCb"
              c:type="TpConnectionRequestHandlesCb"
              deprecated="See tp_connection_request_handles().">
      <doc xml:whitespace="preserve">Signature of the callback called when tp_connection_request_handles()
succeeds or fails.

On success, the caller has a reference to each handle in @handles.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, they could be
released with tp_connection_unref_handles().

For convenience, the handle type and IDs requested by the caller are
passed through to this callback, so the caller does not have to include
them in @user_data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle type that was passed to tp_connection_request_handles()</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of IDs that were passed to tp_connection_request_handles() on success, or 0 on failure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @n_handles handles corresponding to @ids, in the same order, or %NULL on failure</doc>
          <array length="2" zero-terminated="0" c:type="TpHandle*">
            <type name="guint"/>
          </array>
        </parameter>
        <parameter name="ids" transfer-ownership="none">
          <doc xml:whitespace="preserve">a copy of the array of @n_handles IDs that was passed to tp_connection_request_handles() on success, or %NULL on failure</doc>
          <array length="2" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error on failure</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">the same arbitrary pointer that was passed to tp_connection_request_handles()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the same object that was passed to tp_connection_request_handles()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionStatus" c:type="TpConnectionStatus">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="connected"
              value="0"
              c:identifier="TP_CONNECTION_STATUS_CONNECTED"/>
      <member name="connecting"
              value="1"
              c:identifier="TP_CONNECTION_STATUS_CONNECTING"/>
      <member name="disconnected"
              value="2"
              c:identifier="TP_CONNECTION_STATUS_DISCONNECTED"/>
    </enumeration>
    <enumeration name="ConnectionStatusReason"
                 c:type="TpConnectionStatusReason">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A reason why the status of the connection changed. Apart from           Requested, the values of this enumeration only make sense as           reasons why the status changed to Disconnected.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none_specified"
              value="0"
              c:identifier="TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED"/>
      <member name="requested"
              value="1"
              c:identifier="TP_CONNECTION_STATUS_REASON_REQUESTED"/>
      <member name="network_error"
              value="2"
              c:identifier="TP_CONNECTION_STATUS_REASON_NETWORK_ERROR"/>
      <member name="authentication_failed"
              value="3"
              c:identifier="TP_CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED"/>
      <member name="encryption_error"
              value="4"
              c:identifier="TP_CONNECTION_STATUS_REASON_ENCRYPTION_ERROR"/>
      <member name="name_in_use"
              value="5"
              c:identifier="TP_CONNECTION_STATUS_REASON_NAME_IN_USE"/>
      <member name="cert_not_provided"
              value="6"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_PROVIDED"/>
      <member name="cert_untrusted"
              value="7"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_UNTRUSTED"/>
      <member name="cert_expired"
              value="8"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_EXPIRED"/>
      <member name="cert_not_activated"
              value="9"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_ACTIVATED"/>
      <member name="cert_hostname_mismatch"
              value="10"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_HOSTNAME_MISMATCH"/>
      <member name="cert_fingerprint_mismatch"
              value="11"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_FINGERPRINT_MISMATCH"/>
      <member name="cert_self_signed"
              value="12"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_SELF_SIGNED"/>
      <member name="cert_other_error"
              value="13"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_OTHER_ERROR"/>
      <member name="cert_revoked"
              value="14"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_REVOKED"/>
      <member name="cert_insecure"
              value="15"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_INSECURE"/>
      <member name="cert_limit_exceeded"
              value="16"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_LIMIT_EXCEEDED"/>
    </enumeration>
    <callback name="ConnectionUpgradeContactsCb"
              c:type="TpConnectionUpgradeContactsCb"
              version="0.7.18">
      <doc xml:whitespace="preserve">Signature of a callback used to receive the result of
tp_connection_upgrade_contacts().

If an unrecoverable error occurs (for instance, if @connection becomes
disconnected) it is indicated by @error, but the contacts in @contacts
are still provided.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of TpContact objects for which an upgrade was requested</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts TpContact objects (this callback is not given an extra reference to any of these objects, and must call g_object_ref() on any that it will keep)</doc>
          <array length="1" zero-terminated="0" c:type="TpContact**">
            <type name="Contact" c:type="TpContact*"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">An unrecoverable error, or %NULL if the connection remains valid</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:whitespace="preserve">the @user_data that was passed to tp_connection_upgrade_contacts()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object that was passed to tp_connection_upgrade_contacts()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionWhenReadyCb"
              c:type="TpConnectionWhenReadyCb"
              deprecated="0.17.6">
      <doc xml:whitespace="preserve">Signature of a callback passed to tp_connection_call_when_ready(), which
will be called exactly once, when the connection becomes ready or
invalid (whichever happens first)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection (which may be in the middle of being disposed, if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is TP_DBUS_ERROR_PROXY_UNREFERENCED)</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL if the connection is ready for use, or the error with which it was invalidated if it is now invalid</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">whatever was passed to tp_connection_call_when_ready()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Contact"
           c:symbol-prefix="contact"
           c:type="TpContact"
           version="0.7.18"
           parent="GObject.Object"
           glib:type-name="TpContact"
           glib:get-type="tp_contact_get_type"
           glib:type-struct="ContactClass">
      <doc xml:whitespace="preserve">An object representing a contact on a #TpConnection.

Contact objects support tracking a number of attributes of contacts, as
described by the #TpContactFeature flags. Features can be specified when
instantiating contact objects (with tp_connection_get_contacts_by_id() or
tp_connection_get_contacts_by_handle()), or added to an existing contact
object with tp_connection_upgrade_contacts(). For example, a client wishing
to keep track of a contact's alias would set #TP_CONTACT_FEATURE_ALIAS, and
then listen for the "notify::alias" signal, emitted whenever the
#TpContact:alias property changes.

Note that releasing a #TpContact object might release handle references
held by calling tp_cli_connection_call_request_handles(),
tp_cli_connection_run_request_handles(),
tp_cli_connection_call_hold_handles(),
tp_cli_connection_run_hold_handles(),
tp_cli_connection_interface_contacts_call_get_contact_attributes() or
tp_cli_connection_interface_contacts_run_get_contact_attributes() directly.
Those functions should be avoided in favour of using #TpContact,
tp_connection_hold_handles(), tp_connection_request_handles() and
tp_connection_get_contact_attributes().</doc>
      <method name="add_to_group_async"
              c:identifier="tp_contact_add_to_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_add_to_group_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_to_group_finish"
              c:identifier="tp_contact_add_to_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_add_to_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_async"
              c:identifier="tp_contact_authorize_publication_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_authorize_publication_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_finish"
              c:identifier="tp_contact_authorize_publication_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_authorize_publication_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_async"
              c:identifier="tp_contact_block_async"
              version="0.17.0">
        <doc xml:whitespace="preserve">Block communications with a contact, optionally reporting the contact as
abusive to the server administrators. To block more than one contact at once,
see tp_connection_block_contacts_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="report_abusive" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE, report this contact as abusive to the server administrators as well as blocking him. See #TpConnection:can-report-abusive to discover whether reporting abuse is supported. If #TpConnection:can-report-abusive is %FALSE, this parameter will be ignored.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_finish"
              c:identifier="tp_contact_block_finish"
              version="0.17.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_block_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_info"
              c:identifier="tp_contact_dup_contact_info"
              version="0.19.9">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of contact's vCard fields. The list must be
freed with tp_contact_info_list_free() after used.

Same as the #TpContact:contact-info property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoField, or %NULL if the feature is not yet prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
      </method>
      <method name="dup_location"
              c:identifier="tp_contact_dup_location"
              version="0.19.10">
        <doc xml:whitespace="preserve">Return the contact's user-defined location, or %NULL if the location is
unspecified.

This function returns the same information as tp_contact_get_location(),
but in a different format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a variant of type %G_VARIANT_TYPE_VARDICT, the same as the #TpContact:location-vardict property</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_account"
              c:identifier="tp_contact_get_account"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpAccount of @self's #TpContact:connection.
See tp_connection_get_account() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a borrowed reference to @self's account (it must be referenced with g_object_ref if it must remain valid longer than the contact)</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_alias"
              c:identifier="tp_contact_get_alias"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's alias. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL alias as the #TpContact:alias</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_avatar_file"
              c:identifier="tp_contact_get_avatar_file"
              version="0.11.6">
        <doc xml:whitespace="preserve">Return the contact's avatar file. This remains valid until the main loop
is re-entered; if the caller requires a #GFile that will persist for
longer than that, it must be reffed with g_object_ref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #GFile as the #TpContact:avatar-file property (possibly %NULL)</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
      </method>
      <method name="get_avatar_mime_type"
              c:identifier="tp_contact_get_avatar_mime_type"
              version="0.11.6">
        <doc xml:whitespace="preserve">Return the contact's avatar MIME type. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same MIME type as the #TpContact:avatar-mime-type property (possibly %NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_avatar_token"
              c:identifier="tp_contact_get_avatar_token"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's avatar token. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same token as the #TpContact:avatar-token property (possibly %NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_capabilities"
              c:identifier="tp_contact_get_capabilities"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #TpCapabilities (or %NULL) as the #TpContact:capabilities property</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
      </method>
      <method name="get_client_types"
              c:identifier="tp_contact_get_client_types"
              version="0.13.1">
        <doc xml:whitespace="preserve">Return the contact's client types or %NULL if the client types are
unspecified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #GStrv as the #TpContact:client-types property</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_connection"
              c:identifier="tp_contact_get_connection"
              version="0.7.18">
        <doc xml:whitespace="preserve">&lt;!-- nothing more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a borrowed reference to the #TpContact:connection (it must be referenced with g_object_ref if it must remain valid longer than the contact)</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="get_contact_groups"
              c:identifier="tp_contact_get_contact_groups"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return names of groups of which a contact is a member. It is incorrect to
call this method before %TP_CONTACT_FEATURE_CONTACT_GROUPS has been
prepared. This remains valid until the main loop is re-entered; if the caller
requires a #GStrv that will persist for longer than that, it must be copied
with g_strdupv().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #GStrv as the #TpContact:contact-groups property</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_contact_info"
              c:identifier="tp_contact_get_contact_info"
              version="0.11.7"
              deprecated="Since 0.19.9. New code should use tp_contact_dup_contact_info() instead.">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of contact's vCard fields. The list must be
freed with g_list_free() after used.

Note that the #TpContactInfoField&lt;!-- --&gt;s in the returned #GList are not
dupped before returning from this function. One could copy every item in the
list using tp_contact_info_field_copy().

Same as the #TpContact:contact-info property.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoField, or %NULL if the feature is not yet prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
      </method>
      <method name="get_handle"
              c:identifier="tp_contact_get_handle"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's handle, which is of type %TP_HANDLE_TYPE_CONTACT,
or 0 if the #TpContact:connection has become invalid.

This handle is referenced using the Telepathy D-Bus API and remains
referenced for as long as @self exists and the
#TpContact:connection remains valid.

However, the caller of this function does not gain an additional reference
to the handle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same handle as the #TpContact:handle property</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_identifier"
              c:identifier="tp_contact_get_identifier"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's identifier. This remains valid for as long as @self
exists; if the caller requires a string that will persist for longer than
that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL identifier as the #TpContact:identifier property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_location"
              c:identifier="tp_contact_get_location"
              version="0.11.1">
        <doc xml:whitespace="preserve">Return the contact's user-defined location or %NULL if the location is
unspecified.
This remains valid until the main loop is re-entered; if the caller
requires a hash table that will persist for longer than that, it must be
reffed with g_hash_table_ref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #GHashTable (or %NULL) as the #TpContact:location property</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_presence_message"
              c:identifier="tp_contact_get_presence_message"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's user-defined status message, or an empty string.
This remains valid until the main loop is re-entered; if the caller
requires a string that will persist for longer than that, it must be
copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL message as the #TpContact:presence-message property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_presence_status"
              c:identifier="tp_contact_get_presence_status"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the name of the contact's presence status, or an empty string.
This remains valid until the main loop is re-entered; if the caller
requires a string that will persist for longer than that, it must be
copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL status name as the #TpContact:presence-status property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_presence_type"
              c:identifier="tp_contact_get_presence_type"
              version="0.7.18">
        <doc xml:whitespace="preserve">If this object has been set up to track %TP_CONTACT_FEATURE_PRESENCE
and the underlying connection supports either the Presence or
SimplePresence interfaces, return the type of the contact's presence.

Otherwise, return %TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same presence type as the #TpContact:presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
      </method>
      <method name="get_publish_request"
              c:identifier="tp_contact_get_publish_request"
              version="0.13.12">
        <doc xml:whitespace="preserve">If #TpContact:publish-state is set to %TP_SUBSCRIPTION_STATE_ASK, return the
message that this remote contact sent when they requested permission to see
the local user's presence, an empty string ("") otherwise. This remains valid
until the main loop is re-entered; if the caller requires a string that will
persist for longer than that, it must be copied with g_strdup().

This is set to %NULL until %TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been
prepared, and it is guaranteed to be non-%NULL afterward.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpContact:publish-request.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_publish_state"
              c:identifier="tp_contact_get_publish_state"
              version="0.13.12">
        <doc xml:whitespace="preserve">Return the state of this remote contact's subscription to the local user's
presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpContact:publish-state.</doc>
          <type name="SubscriptionState" c:type="TpSubscriptionState"/>
        </return-value>
      </method>
      <method name="get_subscribe_state"
              c:identifier="tp_contact_get_subscribe_state"
              version="0.13.12">
        <doc xml:whitespace="preserve">Return the state of the local user's subscription to this remote contact's
presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpContact:subscribe-state.</doc>
          <type name="SubscriptionState" c:type="TpSubscriptionState"/>
        </return-value>
      </method>
      <method name="has_feature"
              c:identifier="tp_contact_has_feature"
              version="0.7.18">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @self has been set up to track the feature @feature</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a desired feature</doc>
            <type name="ContactFeature" c:type="TpContactFeature"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_blocked"
              c:identifier="tp_contact_is_blocked"
              version="0.17.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpContact:is-blocked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remove_async"
              c:identifier="tp_contact_remove_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_remove_contacts_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish"
              c:identifier="tp_contact_remove_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_remove_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_async"
              c:identifier="tp_contact_remove_from_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_remove_from_group_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_finish"
              c:identifier="tp_contact_remove_from_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_remove_from_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_contact_info_async"
              c:identifier="tp_contact_request_contact_info_async"
              version="0.11.7">
        <doc xml:whitespace="preserve">Requests an asynchronous request of the contact info of @self. When
the operation is finished, @callback will be called. You can then call
tp_contact_request_contact_info_finish() to get the result of the operation.

If the operation is successful, the #TpContact:contact-info property will be
updated (emitting "notify::contact-info" signal) before @callback is called.
That means you can call tp_contact_get_contact_info() to get the new vCard
inside @callback.

Note that requesting the vCard from the network can take significant time, so
a bigger timeout is set on the underlying D-Bus call. @cancellable can be
cancelled to free resources used in the D-Bus call if the caller is no longer
interested in the vCard.

If %TP_CONTACT_FEATURE_CONTACT_INFO is not yet set on @self, it will be
set before its property gets updated and @callback is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_contact_info_finish"
              c:identifier="tp_contact_request_contact_info_finish"
              version="0.11.7"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async request of @self info. If the operation was successful,
the contact's vCard can be accessed using tp_contact_get_contact_info().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_async"
              c:identifier="tp_contact_request_subscription_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_request_subscription_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">an optional message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_finish"
              c:identifier="tp_contact_request_subscription_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_request_subscription_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_groups_async"
              c:identifier="tp_contact_set_contact_groups_async"
              version="0.13.14">
        <doc xml:whitespace="preserve">Add @self to the given groups (creating new groups if necessary), and remove
it from all other groups. If the user is removed from a group of which they
were the only member, the group MAY be removed automatically. You can then
call tp_contact_set_contact_groups_finish() to get the result of the
operation.

If the operation is successful and %TP_CONTACT_FEATURE_CONTACT_GROUPS is
prepared, the #TpContact:contact-groups property will be
updated (emitting "notify::contact-groups" signal) and
#TpContact::contact-groups-changed signal will be emitted before @callback
is called. That means you can call tp_contact_get_contact_groups() to get the
new contact groups inside @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_groups" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of groups, or -1 if @groups is %NULL-terminated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="groups" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the set of groups which the contact should be in (may be %NULL if @n_groups is 0)</doc>
            <array length="0" zero-terminated="0" c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_groups_finish"
              c:identifier="tp_contact_set_contact_groups_finish"
              version="0.13.14"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of @self contact groups.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_async"
              c:identifier="tp_contact_unblock_async"
              version="0.17.0">
        <doc xml:whitespace="preserve">Unblock communications with a contact. To unblock more than one contact
at once, see tp_connection_unblock_contacts_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_finish"
              c:identifier="tp_contact_unblock_finish"
              version="0.17.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_unblock_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_async"
              c:identifier="tp_contact_unpublish_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_unpublish_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_finish"
              c:identifier="tp_contact_unpublish_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_unpublish_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_async"
              c:identifier="tp_contact_unsubscribe_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_unsubscribe_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_finish"
              c:identifier="tp_contact_unsubscribe_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_unsubscribe_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="alias" transfer-ownership="none">
        <doc xml:whitespace="preserve">The contact's alias if available, falling back to their
#TpContact:identifier if no alias is available or if the #TpContact has
not been set up to track %TP_CONTACT_FEATURE_ALIAS.

This alias may have been supplied by the contact themselves, or by the
local user, so it does not necessarily unambiguously identify the contact.
However, it is suitable for use as a main "display name" for the contact.

This is never %NULL for contact objects that are visible to library-user
code.</doc>
        <type name="utf8"/>
      </property>
      <property name="avatar-file" version="0.11.6" transfer-ownership="none">
        <doc xml:whitespace="preserve">#GFile to the latest cached avatar image, or %NULL if this contact has
no avatar, or if the avatar data is not yet retrieved.

When #TpContact:avatar-token changes, this property is not updated
immediately, but will be updated when the new avatar data is retrieved and
stored in cache. Until then, the file will keep its old value of the latest
cached avatar image.

This is set to %NULL if %TP_CONTACT_FEATURE_AVATAR_DATA is not set on this
contact. Note that setting %TP_CONTACT_FEATURE_AVATAR_DATA will also
implicitly set %TP_CONTACT_FEATURE_AVATAR_TOKEN.</doc>
        <type name="Gio.File"/>
      </property>
      <property name="avatar-mime-type"
                version="0.11.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">MIME type of the latest cached avatar image, or %NULL if this contact has
no avatar, or if the avatar data is not yet retrieved.

This is always the MIME type of the image given by #TpContact:avatar-file.</doc>
        <type name="utf8"/>
      </property>
      <property name="avatar-token" transfer-ownership="none">
        <doc xml:whitespace="preserve">An opaque string representing state of the contact's avatar (depending on
the protocol, this might be a hash, a timestamp or something else), or
an empty string if there is no avatar.

This may be %NULL if it is not known whether this contact has an avatar
or not (either for network protocol reasons, or because this #TpContact
has not been set up to track %TP_CONTACT_FEATURE_AVATAR_TOKEN).</doc>
        <type name="utf8"/>
      </property>
      <property name="capabilities" version="0.11.3" transfer-ownership="none">
        <doc xml:whitespace="preserve">The capabilities supported by this contact. If the underlying Connection
doesn't support the ContactCapabilities interface, this property will
contain the capabilities supported by the connection.
Use tp_capabilities_is_specific_to_contact() to check if the capabilities
are specific to this #TpContact or not.

This may be %NULL if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_CAPABILITIES.</doc>
        <type name="Capabilities"/>
      </property>
      <property name="client-types" version="0.13.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GStrv containing the client types of this contact.

This is set to %NULL if %TP_CONTACT_FEATURE_CLIENT_TYPES is not
set on this contact; it may also be %NULL if that feature is prepared, but
the contact's client types are unknown.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="connection" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection to which this contact belongs.</doc>
        <type name="Connection"/>
      </property>
      <property name="contact-groups"
                version="0.13.14"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GStrv with names of groups of which a contact is a member.

This is set to %NULL if %TP_CONTACT_FEATURE_CONTACT_GROUPS is not prepared
on this contact, or if the connection does not implement ContactGroups
interface.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="contact-info" version="0.11.7" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GList of #TpContactInfoField representing the vCard of this contact.

This is set to %NULL if %TP_CONTACT_FEATURE_CONTACT_INFO is not set on this
contact.</doc>
        <type name="ContactInfoList"/>
      </property>
      <property name="handle" transfer-ownership="none">
        <doc xml:whitespace="preserve">The contact's handle in the Telepathy D-Bus API, a handle of type
%TP_HANDLE_TYPE_CONTACT representing the string
given by #TpContact:identifier.

This handle is referenced using the Telepathy D-Bus API and remains
referenced for as long as the #TpContact exists and the
#TpContact:connection remains valid.

However, getting this property does not cause an additional reference
to the handle to be held.

If the #TpContact:connection becomes invalid, this property is no longer
meaningful and will be set to 0.</doc>
        <type name="guint"/>
      </property>
      <property name="identifier" transfer-ownership="none">
        <doc xml:whitespace="preserve">The contact's identifier in the instant messaging protocol (e.g.
XMPP JID, SIP URI, AOL screenname or IRC nick - whatever the underlying
protocol uses to identify a user).

This is never %NULL for contact objects that are visible to library-user
code.</doc>
        <type name="utf8"/>
      </property>
      <property name="is-blocked" version="0.17.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the contact has been blocked.

This is set to %FALSE if %TP_CONTACT_FEATURE_CONTACT_BLOCKING is not
prepared on this contact, or if the connection does not implement
ContactBlocking interface.</doc>
        <type name="gboolean"/>
      </property>
      <property name="location"
                version="0.11.1"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this contact has set a user-defined location, a string to
#GValue * hash table containing his location. If not, %NULL.
tp_asv_get_string() and similar functions can be used to access
the contents.

This may be %NULL even if the contact has set a location,
if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_LOCATION.</doc>
        <type/>
      </property>
      <property name="location-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this contact has set a user-defined location, a string to
variant map containing his location. If not, %NULL.
tp_vardict_get_string() and similar functions can be used to access
the contents.

This may be %NULL even if the contact has set a location,
if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_LOCATION.

This property contains the same information as #TpContact:location,
in a different format.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="presence-message" transfer-ownership="none">
        <doc xml:whitespace="preserve">If this contact has set a user-defined status message, that message;
if not, an empty string (which user interfaces may replace with a
localized form of the #TpContact:presence-status or
#TpContact:presence-type).

This may be an empty string even if the contact has set a message,
if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_PRESENCE. It is never %NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="presence-status" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string representing the presence status of this contact. This may be
a well-known string from the Telepathy specification, like "available",
or a connection-manager-specific string, like "out-to-lunch".

This may be an empty string if this #TpContact object has not been set up
to track %TP_CONTACT_FEATURE_PRESENCE. It is never %NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="presence-type" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnectionPresenceType representing the type of presence status
for this contact.

This is provided so even unknown values for #TpContact:presence-status
can be classified into their fundamental types.

This may be %TP_CONNECTION_PRESENCE_TYPE_UNSET if this #TpContact
has not been set up to track %TP_CONTACT_FEATURE_PRESENCE.</doc>
        <type name="guint"/>
      </property>
      <property name="publish-request"
                version="0.13.12"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The message that contact sent when they requested permission to see the
local user's presence, if #TpContact:publish-state is
%TP_SUBSCRIPTION_STATE_ASK, an empty string ("") otherwise.

This is set to %NULL until %TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been
prepared, and it is guaranteed to be non-%NULL afterward.</doc>
        <type name="utf8"/>
      </property>
      <property name="publish-state"
                version="0.13.12"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpSubscriptionState indicating the state of this contact's subscription
to the local user's presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <type name="guint"/>
      </property>
      <property name="subscribe-state"
                version="0.13.12"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpSubscriptionState indicating the state of the local user's
subscription to this contact's presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <type name="guint"/>
      </property>
      <glib:signal name="contact-groups-changed" when="last" version="0.13.14">
        <doc xml:whitespace="preserve">Emitted when this contact's groups changes. When this signal is emitted,
#TpContact:contact-groups property is already updated.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GStrv with added contact groups</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GStrv with removed contact groups</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="presence-changed" when="last" version="0.11.7">
        <doc xml:whitespace="preserve">Emitted when this contact's presence changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value of #TpContact:presence-type</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value of #TpContact:presence-status</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value of #TpContact:presence-message</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="subscription-states-changed"
                   when="last"
                   version="0.13.12">
        <doc xml:whitespace="preserve">Emitted when this contact's subscription states changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="subscribe" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of #TpContact:subscribe-state</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="publish" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of #TpContact:publish-state</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="publish_request" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of #TpContact:publish-request</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="ContactBlockingCapabilities"
              c:type="TpContactBlockingCapabilities">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="contact_blocking_capability_can_report_abusive"
              value="1"
              c:identifier="TP_CONTACT_BLOCKING_CAPABILITY_CAN_REPORT_ABUSIVE"/>
    </bitfield>
    <record name="ContactClass"
            c:type="TpContactClass"
            disguised="1"
            glib:is-gtype-struct-for="Contact">
    </record>
    <enumeration name="ContactFeature"
                 version="0.7.18"
                 c:type="TpContactFeature">
      <doc xml:whitespace="preserve">Enumeration representing the features a #TpContact can optionally support.
When requesting a #TpContact, library users specify the desired features;
the #TpContact code will only initialize state for those features, to
avoid unwanted D-Bus round-trips and signal connections.

Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_CONTACT_FEATURE.</doc>
      <member name="alias" value="0" c:identifier="TP_CONTACT_FEATURE_ALIAS"/>
      <member name="avatar_token"
              value="1"
              c:identifier="TP_CONTACT_FEATURE_AVATAR_TOKEN"/>
      <member name="presence"
              value="2"
              c:identifier="TP_CONTACT_FEATURE_PRESENCE"/>
      <member name="location"
              value="3"
              c:identifier="TP_CONTACT_FEATURE_LOCATION"/>
      <member name="capabilities"
              value="4"
              c:identifier="TP_CONTACT_FEATURE_CAPABILITIES"/>
      <member name="avatar_data"
              value="5"
              c:identifier="TP_CONTACT_FEATURE_AVATAR_DATA"/>
      <member name="contact_info"
              value="6"
              c:identifier="TP_CONTACT_FEATURE_CONTACT_INFO"/>
      <member name="client_types"
              value="7"
              c:identifier="TP_CONTACT_FEATURE_CLIENT_TYPES"/>
      <member name="subscription_states"
              value="8"
              c:identifier="TP_CONTACT_FEATURE_SUBSCRIPTION_STATES"/>
      <member name="contact_groups"
              value="9"
              c:identifier="TP_CONTACT_FEATURE_CONTACT_GROUPS"/>
      <member name="contact_blocking"
              value="10"
              c:identifier="TP_CONTACT_FEATURE_CONTACT_BLOCKING"/>
    </enumeration>
    <record name="ContactInfoField"
            c:type="TpContactInfoField"
            version="0.11.7"
            glib:type-name="TpContactInfoField"
            glib:get-type="tp_contact_info_field_get_type"
            c:symbol-prefix="contact_info_field">
      <doc xml:whitespace="preserve">A structure representing an information about a contact. Similar to a vCard
field.</doc>
      <field name="field_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parameters" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="field_value" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new"
                   c:identifier="tp_contact_info_field_new"
                   version="0.11.7">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpContactInfoField, free it with tp_contact_info_field_free()</doc>
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the field; this is the lowercased name of a vCard field. For example, a field representing a contact's address would be named "adr".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">A list of vCard type parameters applicable to this field, with their values. The type parameter names, and any values that are case-insensitive in vCard, MUST be in lower case. For example, a contact's preferred home address would have parameters 'type=home' and 'type=pref'.</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="field_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">For unstructured vCard fields (such as 'fn', a formatted name field), a single-element array containing the field's value. For structured fields (such as 'adr', an address field), an array corresponding to the semicolon-separated elements of the field (with empty strings for empty elements).</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy"
              c:identifier="tp_contact_info_field_copy"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpContactInfoField, free it with tp_contact_info_field_free()</doc>
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
      </method>
      <method name="free"
              c:identifier="tp_contact_info_field_free"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #TpContactInfoField.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <bitfield name="ContactInfoFieldFlags" c:type="TpContactInfoFieldFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Flags describing the behaviour of a vCard field.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="parameters_exact"
              value="1"
              c:identifier="TP_CONTACT_INFO_FIELD_FLAG_PARAMETERS_EXACT"/>
      <member name="overwritten_by_nickname"
              value="2"
              c:identifier="TP_CONTACT_INFO_FIELD_FLAG_OVERWRITTEN_BY_NICKNAME"/>
    </bitfield>
    <record name="ContactInfoFieldSpec"
            c:type="TpContactInfoFieldSpec"
            version="0.11.7"
            glib:type-name="TpContactInfoFieldSpec"
            glib:get-type="tp_contact_info_field_spec_get_type"
            c:symbol-prefix="contact_info_field_spec">
      <doc xml:whitespace="preserve">A struct describing a vCard field.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parameters" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="flags" writable="1">
        <type name="ContactInfoFieldFlags" c:type="TpContactInfoFieldFlags"/>
      </field>
      <field name="max" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="copy"
              c:identifier="tp_contact_info_field_spec_copy"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpContactInfoFieldSpec, free it with tp_contact_info_field_spec_free()</doc>
          <type name="ContactInfoFieldSpec" c:type="TpContactInfoFieldSpec*"/>
        </return-value>
      </method>
      <method name="free"
              c:identifier="tp_contact_info_field_spec_free"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #TpContactInfoFieldSpec.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <bitfield name="ContactInfoFlags" c:type="TpContactInfoFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Flags defining the behaviour of contact information on this protocol.         Some protocols provide no information on contacts without an explicit         request; others always push information to the connection manager as         and when it changes.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="can_set"
              value="1"
              c:identifier="TP_CONTACT_INFO_FLAG_CAN_SET"/>
      <member name="push" value="2" c:identifier="TP_CONTACT_INFO_FLAG_PUSH"/>
    </bitfield>
    <glib:boxed glib:name="ContactInfoList"
                c:symbol-prefix="contact_info_list"
                glib:type-name="TpContactInfoList"
                glib:get-type="tp_contact_info_list_get_type">
      <function name="copy"
                c:identifier="tp_contact_info_list_copy"
                version="0.11.7"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #GList of newly allocated #TpContactInfoField, free it with tp_contact_info_list_free()</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free"
                c:identifier="tp_contact_info_list_free"
                version="0.11.7"
                introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #GList and its elements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <glib:boxed glib:name="ContactInfoSpecList"
                c:symbol-prefix="contact_info_spec_list"
                glib:type-name="TpContactInfoSpecList"
                glib:get-type="tp_contact_info_spec_list_get_type">
      <function name="copy"
                c:identifier="tp_contact_info_spec_list_copy"
                version="0.11.7"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #GList of newly allocated #TpContactInfoFieldSpec, free it with tp_contact_info_spec_list_free()</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free"
                c:identifier="tp_contact_info_spec_list_free"
                version="0.11.7"
                introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #GList and its elements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <enumeration name="ContactListState" c:type="TpContactListState">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The progress made in retrieving the contact list.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_CONTACT_LIST_STATE_NONE"/>
      <member name="waiting"
              value="1"
              c:identifier="TP_CONTACT_LIST_STATE_WAITING"/>
      <member name="failure"
              value="2"
              c:identifier="TP_CONTACT_LIST_STATE_FAILURE"/>
      <member name="success"
              value="3"
              c:identifier="TP_CONTACT_LIST_STATE_SUCCESS"/>
    </enumeration>
    <enumeration name="ContactMetadataStorageType"
                 c:type="TpContactMetadataStorageType">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Values of this enumeration indicate the extent to which metadata           such as aliases and group memberships can be stored for the contacts           on a particular connection.          On some protocols, certain metadata (for instance, contact aliases)           can only be stored for contacts on the contact list, or contacts           with a particular contact list state.          To make it easier to deal with such protocols, if clients set           metadata on a contact who is not in the required state, the           Connection MUST cache the metadata for the duration of the session.           If clients request the attributes of that contact after the           appropriate "set" method has returned successfully, the Connection           MUST return the new (cached) value.          If the contact is later placed in the required state to store           metadata (for instance, if subscription to the contact's presence           is requested, on a protocol like MSN where the alias has storage type           Subscribed_Or_Pending), the connection MUST store the cached           metadata at that time.                     If the Connection didn't cache changes in this way, a client             intending to change the alias on MSN would have to wait until             the server acknowledged the subscription request; in the meantime,             other clients would still display the old alias.                   The only exception to that general rule is that if the Connection           cannot store particular metadata at all (i.e. the           storage type is None), it MUST reject attempts to set it.                     If the implementation knows that metadata can't be stored at             all, it's useful to report that, which can be done             synchronously. In general, user interfaces should detect             storage type None and not display editing controls at all.                ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_NONE"/>
      <member name="subscribed_or_pending"
              value="1"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_SUBSCRIBED_OR_PENDING"/>
      <member name="subscribed"
              value="2"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_SUBSCRIBED"/>
      <member name="anyone"
              value="3"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_ANYONE"/>
    </enumeration>
    <record name="ContactPrivate" c:type="TpContactPrivate" disguised="1">
    </record>
    <class name="ContactSearch"
           c:symbol-prefix="contact_search"
           c:type="TpContactSearch"
           version="0.13.11"
           parent="GObject.Object"
           glib:type-name="TpContactSearch"
           glib:get-type="tp_contact_search_get_type"
           glib:type-struct="ContactSearchClass">
      <doc xml:whitespace="preserve">An object for Telepathy contact searches.
There are no interesting public struct fields.</doc>
      <implements name="Gio.AsyncInitable"/>
      <constructor name="new_finish"
                   c:identifier="tp_contact_search_new_finish"
                   version="0.13.11"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new contact search object, or %NULL in case of error.</doc>
          <type name="ContactSearch" c:type="TpContactSearch*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult from the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async"
                c:identifier="tp_contact_search_new_async"
                version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account for the contact search</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="server" transfer-ownership="none">
            <doc xml:whitespace="preserve">the server on which to search for contacts, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="limit" transfer-ownership="none">
            <doc xml:whitespace="preserve">The maximum number of results the server should return, or 0 for the server default.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the initialization is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_account"
              c:identifier="tp_contact_search_get_account"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The TpContactSearch:account property</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_limit"
              c:identifier="tp_contact_search_get_limit"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The TpContactSearch:limit property</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_search_keys"
              c:identifier="tp_contact_search_get_search_keys"
              version="0.13.11">
        <doc xml:whitespace="preserve">Get the search keys for a contact search.
The keys are vCard field names in lower case, except when
they're one of the special cases from telepathy-spec like
"tel;cell" or "x-n-given". See the
&lt;ulink url="http://telepathy.freedesktop.org/spec/Channel_Type_Contact_Search.html"&gt;
Channel.Type.ContactSearch interface&lt;/ulink&gt;
for a list of the special cases.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the new search keys, or %NULL.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_server"
              c:identifier="tp_contact_search_get_server"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The TpContactSearch:server property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="reset_async"
              c:identifier="tp_contact_search_reset_async"
              version="0.13.11">
        <doc xml:whitespace="preserve">Resets the contact search object so a new search can be performed.
If another tp_contact_search_reset_async() call is in progress,
it will be cancelled and tp_contact_search_reset_finish() will
return an appropriate error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="server" transfer-ownership="none">
            <doc xml:whitespace="preserve">the server on which to search for contacts, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="limit" transfer-ownership="none">
            <doc xml:whitespace="preserve">The maximum number of results the server should return, or 0 for the server default.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the initialization is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset_finish"
              c:identifier="tp_contact_search_reset_finish"
              version="0.13.11"
              throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the new search keys, or %NULL in case of error.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult from the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start"
              c:identifier="tp_contact_search_start"
              version="0.13.11">
        <doc xml:whitespace="preserve">Starts a search for the keys specified in @criteria. Connect
to the #TpContactSearch::search-results-received signal
before calling this function.

Before searching again on the same #TpContactSearch, you must
call tp_contact_search_reset_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="criteria" transfer-ownership="none">
            <doc xml:whitespace="preserve">a map from keys returned by tp_contact_search_get_search_keys() to values to search for</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.13.11"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">This search's account.</doc>
        <type name="Account"/>
      </property>
      <property name="limit"
                version="0.13.11"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The maximum number of results that the server should return.
This is only supported by some protocols; use
tp_capabilities_supports_contact_search() to check if it's
supported.

To change the limit after the object has been constructed,
use tp_contact_search_reset_async().</doc>
        <type name="guint"/>
      </property>
      <property name="server"
                version="0.13.11"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The search server. This is only supported by some protocols;
use tp_capabilities_supports_contact_search() to check if it's
supported.

To change the server after the object has been constructed,
use tp_contact_search_reset_async().</doc>
        <type name="utf8"/>
      </property>
      <property name="state" version="0.13.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">This search's state, as a %TpChannelContactSearchState.</doc>
        <type name="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ContactSearchPrivate" c:type="TpContactSearchPrivate*"/>
      </field>
      <glib:signal name="search-results-received"
                   when="last"
                   version="0.13.11">
        <doc xml:whitespace="preserve">Emitted when search results are received. Note that this signal may
be emitted multiple times for the same search.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="results" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList with the search results</doc>
            <type name="GLib.List">
              <type name="ContactSearchResult"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ContactSearchClass"
            c:type="TpContactSearchClass"
            glib:is-gtype-struct-for="ContactSearch"
            version="0.13.11">
      <doc xml:whitespace="preserve">The class of a #TpContactSearch.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="ContactSearchPrivate"
            c:type="TpContactSearchPrivate"
            disguised="1">
    </record>
    <class name="ContactSearchResult"
           c:symbol-prefix="contact_search_result"
           c:type="TpContactSearchResult"
           version="0.13.11"
           parent="GObject.Object"
           glib:type-name="TpContactSearchResult"
           glib:get-type="tp_contact_search_result_get_type"
           glib:type-struct="ContactSearchResultClass">
      <doc xml:whitespace="preserve">An object representing the results of a Telepathy contact
search channel.
There are no interesting public struct fields.</doc>
      <method name="dup_fields"
              c:identifier="tp_contact_search_result_dup_fields"
              version="0.19.9">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoField for the specified contact. You should free it when you're done with tp_contact_info_list_free().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
      </method>
      <method name="get_field"
              c:identifier="tp_contact_search_result_get_field"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the specified field, or %NULL if the result doesn't have it.</doc>
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fields"
              c:identifier="tp_contact_search_result_get_fields"
              deprecated="Since 0.19.9. New code should use tp_contact_search_result_dup_fields() instead.">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoField for the specified contact. You should free it when you're done with g_list_free().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
      </method>
      <method name="get_identifier"
              c:identifier="tp_contact_search_result_get_identifier"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the contact identifier.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <property name="identifier"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ContactSearchResultPrivate"
              c:type="TpContactSearchResultPrivate*"/>
      </field>
    </class>
    <record name="ContactSearchResultClass"
            c:type="TpContactSearchResultClass"
            glib:is-gtype-struct-for="ContactSearchResult"
            version="0.13.11">
      <doc xml:whitespace="preserve">The class of a #TpContactSearchResult.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="ContactSearchResultPrivate"
            c:type="TpContactSearchResultPrivate"
            disguised="1">
    </record>
    <record name="ContactsMixin" c:type="TpContactsMixin">
      <doc xml:whitespace="preserve">Structure to be included in the instance structure of objects that
use this mixin. Initialize it with tp_contacts_mixin_init().

There are no public fields.</doc>
      <field name="priv" readable="0" private="1">
        <type name="ContactsMixinPrivate" c:type="TpContactsMixinPrivate*"/>
      </field>
      <function name="add_contact_attributes_iface"
                c:identifier="tp_contacts_mixin_add_contact_attributes_iface"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Declare that the given interface has contact attributes which can be added
to the attributes hash using the filler function. All the handles in the
handle array passed to the filler function are guaranteed to be valid and
referenced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:whitespace="preserve">Name of the interface that has ContactAttributes</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fill_contact_attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">Contact attribute filler function</doc>
            <type name="ContactsMixinFillContactAttributesFunc"
                  c:type="TpContactsMixinFillContactAttributesFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="finalize"
                c:identifier="tp_contacts_mixin_finalize"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Free resources held by the contacts mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object with this mixin.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_contact_attributes"
                c:identifier="tp_contacts_mixin_get_contact_attributes"
                introspectable="0">
        <doc xml:whitespace="preserve">Get contact attributes for the given contacts. Provide attributes for all requested
interfaces. If contact attributes are not immediately known, the behaviour is defined
by the interface; the attribute should either be omitted from the result or replaced
with a default value.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A dictionary mapping the contact handles to contact attributes.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A connection instance that uses this mixin. The connection must be connected.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">List of handles to retrieve contacts for. Any invalid handles will be dropped from the returned mapping.</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">A list of interfaces to retrieve attributes from.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="assumed_interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">A list of additional interfaces to retrieve attributes from. This can be used for interfaces documented as automatically included, like %TP_IFACE_CONNECTION for GetContactAttributes, or %TP_IFACE_CONNECTION and %TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST for GetContactListAttributes.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="sender" transfer-ownership="none">
            <doc xml:whitespace="preserve">The DBus client's unique name. If this is not NULL, the requested handles will be held on behalf of this client.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_contacts_mixin_get_offset_quark"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="iface_init"
                c:identifier="tp_contacts_mixin_iface_init"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the contacts interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceContacts in an object class</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init"
                c:identifier="tp_contacts_mixin_init"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_init ((GObject *) self,
                    G_STRUCT_OFFSET (SomeObject, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte offset of the TpContactsMixin within the object structure</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_contact_attribute"
                c:identifier="tp_contacts_mixin_set_contact_attribute"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Utility function to set attribute for handle to value in the attributes hash
as passed to a TpContactsMixinFillContactAttributesFunc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="contact_attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">contacts attribute hash as passed to TpContactsMixinFillContactAttributesFunc</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">Handle to set the attribute on</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">attribute name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">slice allocated GValue containing the value of the attribute, for instance with tp_g_value_slice_new. Ownership of the GValue is taken over by the mixin</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ContactsMixinClass" c:type="TpContactsMixinClass">
      <doc xml:whitespace="preserve">Structure to be included in the class structure of objects that
use this mixin. Initialize it with tp_contacts_mixin_class_init().

There are no public fields.</doc>
      <field name="priv" readable="0" private="1">
        <type name="ContactsMixinClassPrivate"
              c:type="TpContactsMixinClassPrivate*"/>
      </field>
      <function name="get_offset_quark"
                c:identifier="tp_contacts_mixin_class_get_offset_quark"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init"
                c:identifier="tp_contacts_mixin_class_init"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_class_init ((GObjectClass *) klass,
                         G_STRUCT_OFFSET (SomeObjectClass, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte offset of the TpContactsMixinClass within the class structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ContactsMixinClassPrivate"
            c:type="TpContactsMixinClassPrivate"
            disguised="1">
    </record>
    <callback name="ContactsMixinFillContactAttributesFunc"
              c:type="TpContactsMixinFillContactAttributesFunc">
      <doc xml:whitespace="preserve">This function is called to supply contact attributes pertaining to
a particular interface, for a list of contacts.
All the handles in @contacts are guaranteed to be valid and
referenced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the Contacts interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The contact handles for which attributes are requested</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="attributes_hash" transfer-ownership="none">
          <doc xml:whitespace="preserve">hash of handle =&gt; hash of attributes, containing all the contacts in the contacts array</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </callback>
    <record name="ContactsMixinPrivate"
            c:type="TpContactsMixinPrivate"
            disguised="1">
    </record>
    <class name="DBusDaemon"
           c:symbol-prefix="dbus_daemon"
           c:type="TpDBusDaemon"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpDBusDaemon"
           glib:get-type="tp_dbus_daemon_get_type"
           glib:type-struct="DBusDaemonClass">
      <doc xml:whitespace="preserve">A subclass of #TpProxy that represents the D-Bus daemon. It mainly provides
functionality to manage well-known names on the bus.</doc>
      <constructor name="new"
                   c:identifier="tp_dbus_daemon_new"
                   version="0.7.1"
                   introspectable="0">
        <doc xml:whitespace="preserve">Returns a proxy for signals and method calls on a particular bus
connection.

Use tp_dbus_daemon_dup() instead if you just want a connection to the
starter or session bus (which is almost always the right thing for
Telepathy).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new proxy for signals and method calls on the bus daemon to which @connection is connected</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection to D-Bus</doc>
            <type c:type="DBusGConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="dup"
                c:identifier="tp_dbus_daemon_dup"
                version="0.7.26"
                throws="1">
        <doc xml:whitespace="preserve">Returns a proxy for signals and method calls on the D-Bus daemon on which
this process was activated (if it was launched by D-Bus service
activation), or the session bus (otherwise).

If it is not possible to connect to the appropriate bus, raise an error
and return %NULL.

The returned #TpDBusDaemon is cached; the same #TpDBusDaemon object will
be returned by this function repeatedly, as long as at least one reference
exists.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a proxy for signals and method calls on the bus daemon, or %NULL</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_dbus_daemon_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpDBusDaemon have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_DBUS_DAEMON.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="cancel_name_owner_watch"
              c:identifier="tp_dbus_daemon_cancel_name_owner_watch"
              version="0.7.1"
              introspectable="0">
        <doc xml:whitespace="preserve">If there was a previous call to tp_dbus_daemon_watch_name_owner()
with exactly the given @name, @callback and @user_data, remove it.

If more than one watch matching the details provided was active, remove
only the most recently added one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if there was such a watch, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name that was being watched</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">the callback that was called</doc>
            <type name="DBusDaemonNameOwnerChangedCb"
                  c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the user data that was provided</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_unique_name"
              c:identifier="tp_dbus_daemon_get_unique_name"
              version="0.7.35">
        <doc xml:whitespace="preserve">&lt;!-- Returns: is enough --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the unique name of this connection to the bus, which is valid for as long as this #TpDBusDaemon is</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="list_activatable_names"
              c:identifier="tp_dbus_daemon_list_activatable_names"
              version="0.7.35">
        <doc xml:whitespace="preserve">Call the ListActivatableNames method on the bus daemon, asynchronously.
The @callback will be called from the main loop with a list of all the
well-known names that are available for service-activation on the bus.

In versions of telepathy-glib that have it, this should be preferred
instead of calling tp_cli_dbus_daemon_call_list_activatable_names(), since
that function will result in wakeups for every NameOwnerChanged signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">timeout for the call</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">callback to be called on success or failure; must not be %NULL</doc>
            <type name="DBusDaemonListNamesCb"
                  c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">opaque user-supplied data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">if not %NULL, called with @user_data as argument after the call has succeeded or failed, or after @weak_object has been destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a GObject which will be weakly referenced; if it is destroyed, @callback will not be called at all</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_names"
              c:identifier="tp_dbus_daemon_list_names"
              version="0.7.35">
        <doc xml:whitespace="preserve">Call the ListNames method on the bus daemon, asynchronously. The @callback
will be called from the main loop with a list of all the names (either
unique or well-known) that exist on the bus.

In versions of telepathy-glib that have it, this should be preferred
instead of calling tp_cli_dbus_daemon_call_list_names(), since that
function will result in wakeups for every NameOwnerChanged signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">timeout for the call</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">callback to be called on success or failure; must not be %NULL</doc>
            <type name="DBusDaemonListNamesCb"
                  c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">opaque user-supplied data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">if not %NULL, called with @user_data as argument after the call has succeeded or failed, or after @weak_object has been destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a GObject which will be weakly referenced; if it is destroyed, @callback will not be called at all</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_object"
              c:identifier="tp_dbus_daemon_register_object"
              version="0.11.3">
        <doc xml:whitespace="preserve">Export @object at @object_path. This is a convenience wrapper around
dbus_g_connection_register_g_object(), and behaves similarly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object to export</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_name"
              c:identifier="tp_dbus_daemon_release_name"
              version="0.7.30"
              throws="1">
        <doc xml:whitespace="preserve">Release the given well-known name. This makes a synchronous call to the bus
daemon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @well_known_name was released, or %FALSE and sets @error if an error occurred.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="well_known_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a well-known name owned by this process to release</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_name"
              c:identifier="tp_dbus_daemon_request_name"
              version="0.7.30"
              throws="1">
        <doc xml:whitespace="preserve">Claim the given well-known name without queueing, allowing replacement
or replacing an existing name-owner. This makes a synchronous call to the
bus daemon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @well_known_name was claimed, or %FALSE and sets @error if an error occurred.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="well_known_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a well-known name to acquire</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="idempotent" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to consider it to be a success if this process already owns the name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_object"
              c:identifier="tp_dbus_daemon_unregister_object"
              version="0.11.3">
        <doc xml:whitespace="preserve">Stop exporting @object on D-Bus. This is a convenience wrapper around
dbus_g_connection_unregister_g_object(), and behaves similarly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object previously exported with tp_dbus_daemon_register_object()</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="watch_name_owner"
              c:identifier="tp_dbus_daemon_watch_name_owner"
              version="0.7.1">
        <doc xml:whitespace="preserve">Arrange for @callback to be called with the owner of @name as soon as
possible (which might even be before this function returns!), then
again every time the ownership of @name changes.

If multiple watches are registered for the same @name, they will be called
in the order they were registered.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name whose ownership is to be watched</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">Callback to call when the ownership is discovered or changes</doc>
            <type name="DBusDaemonNameOwnerChangedCb"
                  c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Arbitrary data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Called to destroy @user_data when the name owner watch is cancelled due to tp_dbus_daemon_cancel_name_owner_watch()</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="DBusDaemonClass"
            c:type="TpDBusDaemonClass"
            disguised="1"
            glib:is-gtype-struct-for="DBusDaemon"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of #TpDBusDaemon.</doc>
    </record>
    <callback name="DBusDaemonListNamesCb"
              c:type="TpDBusDaemonListNamesCb"
              version="0.7.35">
      <doc xml:whitespace="preserve">Signature of a callback for functions that list bus names.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">object representing a connection to a bus</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="names" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant %NULL-terminated array of constant strings representing bus names, or %NULL on error</doc>
          <type name="utf8" c:type="const gchar* const*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">the error that occurred, or %NULL on success</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">the same user data that was passed to tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the same object that was passed to tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DBusDaemonNameOwnerChangedCb"
              c:type="TpDBusDaemonNameOwnerChangedCb"
              version="0.7.1">
      <doc xml:whitespace="preserve">The signature of the callback called by tp_dbus_daemon_watch_name_owner().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name whose ownership has changed or been discovered</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="new_owner" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique name that now owns @name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">Arbitrary user-supplied data as passed to tp_dbus_daemon_watch_name_owner()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusDaemonPrivate"
            c:type="TpDBusDaemonPrivate"
            disguised="1">
    </record>
    <enumeration name="DBusError" version="0.7.1" c:type="TpDBusError">
      <doc xml:whitespace="preserve">#GError codes for use with the %TP_DBUS_ERRORS domain.

Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_DBUS_ERROR.</doc>
      <member name="unknown_remote_error"
              value="0"
              c:identifier="TP_DBUS_ERROR_UNKNOWN_REMOTE_ERROR"/>
      <member name="proxy_unreferenced"
              value="1"
              c:identifier="TP_DBUS_ERROR_PROXY_UNREFERENCED"/>
      <member name="no_interface"
              value="2"
              c:identifier="TP_DBUS_ERROR_NO_INTERFACE"/>
      <member name="name_owner_lost"
              value="3"
              c:identifier="TP_DBUS_ERROR_NAME_OWNER_LOST"/>
      <member name="invalid_bus_name"
              value="4"
              c:identifier="TP_DBUS_ERROR_INVALID_BUS_NAME"/>
      <member name="invalid_interface_name"
              value="5"
              c:identifier="TP_DBUS_ERROR_INVALID_INTERFACE_NAME"/>
      <member name="invalid_object_path"
              value="6"
              c:identifier="TP_DBUS_ERROR_INVALID_OBJECT_PATH"/>
      <member name="invalid_member_name"
              value="7"
              c:identifier="TP_DBUS_ERROR_INVALID_MEMBER_NAME"/>
      <member name="object_removed"
              value="8"
              c:identifier="TP_DBUS_ERROR_OBJECT_REMOVED"/>
      <member name="cancelled"
              value="9"
              c:identifier="TP_DBUS_ERROR_CANCELLED"/>
      <member name="inconsistent"
              value="10"
              c:identifier="TP_DBUS_ERROR_INCONSISTENT"/>
    </enumeration>
    <bitfield name="DBusNameType" version="0.7.1" c:type="TpDBusNameType">
      <doc xml:whitespace="preserve">A set of flags indicating which D-Bus bus names are acceptable.
They can be combined with the bitwise-or operator to accept multiple
types. %TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON and %TP_DBUS_NAME_TYPE_ANY are
the bitwise-or of other appropriate types, for convenience.

Since 0.11.5, there is a corresponding #GFlagsClass type,
%TP_TYPE_DBUS_NAME_TYPE.</doc>
      <member name="unique" value="1" c:identifier="TP_DBUS_NAME_TYPE_UNIQUE"/>
      <member name="well_known"
              value="2"
              c:identifier="TP_DBUS_NAME_TYPE_WELL_KNOWN"/>
      <member name="bus_daemon"
              value="4"
              c:identifier="TP_DBUS_NAME_TYPE_BUS_DAEMON"/>
      <member name="not_bus_daemon"
              value="3"
              c:identifier="TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON"/>
      <member name="any" value="7" c:identifier="TP_DBUS_NAME_TYPE_ANY"/>
    </bitfield>
    <bitfield name="DBusPropertiesMixinFlags"
              version="0.7.3"
              c:type="TpDBusPropertiesMixinFlags">
      <doc xml:whitespace="preserve">Bitfield representing allowed access to a property. At most one of
%TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_CHANGED and
%TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_INVALIDATED may be specified for a
property.

Since 0.11.5, there is a corresponding #GFlagsClass type,
%TP_TYPE_DBUS_PROPERTIES_MIXIN_FLAGS.</doc>
      <member name="read"
              value="1"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_READ"/>
      <member name="write"
              value="2"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_WRITE"/>
      <member name="emits_changed"
              value="4"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_CHANGED"/>
      <member name="emits_invalidated"
              value="8"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_INVALIDATED"/>
    </bitfield>
    <callback name="DBusPropertiesMixinGetter"
              c:type="TpDBusPropertiesMixinGetter">
      <doc xml:whitespace="preserve">Signature of a callback used to get the value of a property.

For simplicity, in this mixin we don't allow getting a property to fail;
implementations must always be prepared to return *something*.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="getter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The getter_data from the #TpDBusPropertiesMixinPropImpl</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusPropertiesMixinIfaceImpl"
            c:type="TpDBusPropertiesMixinIfaceImpl"
            version="0.7.3">
      <doc xml:whitespace="preserve">Structure representing an implementation of an interface's properties.

In addition to the documented fields, there are four pointers which must
be initialized to %NULL.

This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="getter" writable="1">
        <type name="DBusPropertiesMixinGetter"
              c:type="TpDBusPropertiesMixinGetter"/>
      </field>
      <field name="setter" writable="1">
        <type name="DBusPropertiesMixinSetter"
              c:type="TpDBusPropertiesMixinSetter"/>
      </field>
      <field name="props" writable="1">
        <type name="DBusPropertiesMixinPropImpl"
              c:type="TpDBusPropertiesMixinPropImpl*"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="mixin_next" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="mixin_priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinIfaceInfo"
            c:type="TpDBusPropertiesMixinIfaceInfo"
            version="0.7.3">
      <doc xml:whitespace="preserve">Semi-abstract description of an interface. Each service GInterface that
has properties must have one of these attached to it via
tp_svc_interface_set_dbus_properties_info() in its base_init function;
service GInterfaces that do not have properties may have one of these
with no properties.

This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.

In addition to the documented members, there are two private pointers
for future expansion, which must always be initialized to %NULL.</doc>
      <field name="dbus_interface" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="props" writable="1">
        <type name="DBusPropertiesMixinPropInfo"
              c:type="TpDBusPropertiesMixinPropInfo*"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinPropImpl"
            c:type="TpDBusPropertiesMixinPropImpl"
            version="0.7.3">
      <doc xml:whitespace="preserve">Structure representing an implementation of a property.

In addition to the documented fields, there are three pointers which must
be initialized to %NULL.

This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="getter_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="setter_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="mixin_priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinPropInfo"
            c:type="TpDBusPropertiesMixinPropInfo"
            version="0.7.3">
      <doc xml:whitespace="preserve">Semi-abstract description of a property, as attached to a service
GInterface. This structure must either be statically allocated, or
duplicated and never freed, so it always remains valid.

In addition to the documented members, there are two private pointers
for future expansion, which must always be initialized to %NULL.</doc>
      <field name="name" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="flags" writable="1">
        <type name="DBusPropertiesMixinFlags"
              c:type="TpDBusPropertiesMixinFlags"/>
      </field>
      <field name="dbus_signature" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <callback name="DBusPropertiesMixinSetter"
              c:type="TpDBusPropertiesMixinSetter"
              throws="1">
      <doc xml:whitespace="preserve">Signature of a callback used to get the value of a property.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE (setting @error) on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new value for the property</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="setter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The setter_data from the #TpDBusPropertiesMixinPropImpl</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DBusTubeChannel"
           c:symbol-prefix="dbus_tube_channel"
           c:type="TpDBusTubeChannel"
           version="0.18.0"
           parent="Channel"
           glib:type-name="TpDBusTubeChannel"
           glib:get-type="tp_dbus_tube_channel_get_type"
           glib:type-struct="DBusTubeChannelClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpDBusTubeChannel.</doc>
      <function name="feature_quark_core"
                c:identifier="tp_dbus_tube_channel_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="accept_async"
              c:identifier="tp_dbus_tube_channel_accept_async"
              version="0.18.0">
        <doc xml:whitespace="preserve">Accept an incoming D-Bus tube. When the tube has been accepted
@callback will be called. You can then call
tp_dbus_tube_channel_accept_finish() to get the #GDBusConnection that will
be used to communicate through the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the tube has been offered</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="tp_dbus_tube_channel_accept_finish"
              version="0.18.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to accept an incoming D-Bus tube. The returned #GDBusConnection
is ready to be used to exchange data through the tube.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference on a #GDBusConnection if the tube has been successfully accepted and opened; %NULL otherwise.</doc>
          <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_parameters_vardict"
              c:identifier="tp_dbus_tube_channel_dup_parameters_vardict"
              version="0.19.10">
        <doc xml:whitespace="preserve">Return the parameters of the dbus-tube channel in a variant of
type %G_VARIANT_TYPE_VARDICT whose keys are strings representing
parameter names and values are variants representing corresponding
parameter values set by the offerer when offering this channel.

The GVariant returned is %NULL if this is an outgoing tube that has not
yet been offered or the parameters property has not been set.

Use g_variant_lookup(), g_variant_lookup_value(), or tp_vardict_get_uint32()
and similar functions for convenient access to the values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to a #GVariant</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_parameters"
              c:identifier="tp_dbus_tube_channel_get_parameters"
              version="0.18.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpDBusTubeChannel:parameters property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpDBusTubeChannel:parameters</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_service_name"
              c:identifier="tp_dbus_tube_channel_get_service_name"
              version="0.18.0">
        <doc xml:whitespace="preserve">Return the #TpDBusTubeChannel:service-name property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpDBusTubeChannel:service-name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="offer_async"
              c:identifier="tp_dbus_tube_channel_offer_async"
              version="0.18.0">
        <doc xml:whitespace="preserve">Offer an outgoing D-Bus tube. When the tube has been offered and accepted
@callback will be called. You can then call
tp_dbus_tube_channel_offer_finish() to get the #GDBusConnection that will
be used to communicate through the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">parameters of the tube, or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the tube has been offered</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="offer_finish"
              c:identifier="tp_dbus_tube_channel_offer_finish"
              version="0.18.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes offering an outgoing D-Bus tube. The returned #GDBusConnection
is ready to be used to exchange data through the tube.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference on a #GDBusConnection if the tube has been successfully offered and opened; %NULL otherwise.</doc>
          <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="parameters"
                version="0.18.0"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A string to #GValue #GHashTable representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.

In high-level language bindings, use
tp_dbus_tube_channel_dup_parameters_vardict() to get the same information
in a more convenient format.</doc>
        <type/>
      </property>
      <property name="parameters-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A %G_VARIANT_TYPE_VARDICT representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="service-name" version="0.18.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string representing the service name that will be used over the tube.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBusTubeChannelPrivate"
              c:type="TpDBusTubeChannelPrivate*"/>
      </field>
    </class>
    <record name="DBusTubeChannelClass"
            c:type="TpDBusTubeChannelClass"
            glib:is-gtype-struct-for="DBusTubeChannel"
            version="0.18.0">
      <doc xml:whitespace="preserve">The class of a #TpDBusTubeChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="DBusTubeChannelPrivate"
            c:type="TpDBusTubeChannelPrivate"
            disguised="1">
    </record>
    <constant name="DEBUG_OBJECT_PATH"
              value="/org/freedesktop/Telepathy/debug"
              c:type="TP_DEBUG_OBJECT_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="DTMFEvent" c:type="TpDTMFEvent">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="digit_0" value="0" c:identifier="TP_DTMF_EVENT_DIGIT_0"/>
      <member name="digit_1" value="1" c:identifier="TP_DTMF_EVENT_DIGIT_1"/>
      <member name="digit_2" value="2" c:identifier="TP_DTMF_EVENT_DIGIT_2"/>
      <member name="digit_3" value="3" c:identifier="TP_DTMF_EVENT_DIGIT_3"/>
      <member name="digit_4" value="4" c:identifier="TP_DTMF_EVENT_DIGIT_4"/>
      <member name="digit_5" value="5" c:identifier="TP_DTMF_EVENT_DIGIT_5"/>
      <member name="digit_6" value="6" c:identifier="TP_DTMF_EVENT_DIGIT_6"/>
      <member name="digit_7" value="7" c:identifier="TP_DTMF_EVENT_DIGIT_7"/>
      <member name="digit_8" value="8" c:identifier="TP_DTMF_EVENT_DIGIT_8"/>
      <member name="digit_9" value="9" c:identifier="TP_DTMF_EVENT_DIGIT_9"/>
      <member name="asterisk"
              value="10"
              c:identifier="TP_DTMF_EVENT_ASTERISK"/>
      <member name="hash" value="11" c:identifier="TP_DTMF_EVENT_HASH"/>
      <member name="letter_a"
              value="12"
              c:identifier="TP_DTMF_EVENT_LETTER_A"/>
      <member name="letter_b"
              value="13"
              c:identifier="TP_DTMF_EVENT_LETTER_B"/>
      <member name="letter_c"
              value="14"
              c:identifier="TP_DTMF_EVENT_LETTER_C"/>
      <member name="letter_d"
              value="15"
              c:identifier="TP_DTMF_EVENT_LETTER_D"/>
    </enumeration>
    <class name="DebugClient"
           c:symbol-prefix="debug_client"
           c:type="TpDebugClient"
           version="0.19.0"
           parent="Proxy"
           glib:type-name="TpDebugClient"
           glib:get-type="tp_debug_client_get_type"
           glib:type-struct="DebugClientClass">
      <doc xml:whitespace="preserve">A proxy object for the debug interface of a Telepathy component.</doc>
      <constructor name="new"
                   c:identifier="tp_debug_client_new"
                   version="0.19.0"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new debug client proxy, or %NULL on invalid arguments</doc>
          <type name="DebugClient" c:type="TpDebugClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="unique_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the unique name of the process to be debugged; may not be %NULL or a well-known name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_debug_client_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_debug_client_init_known_interfaces"
                version="0.19.0">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpDebugClient have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_DEBUG_CLIENT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="get_messages_async"
              c:identifier="tp_debug_client_get_messages_async"
              version="0.19.0">
        <doc xml:whitespace="preserve">Retrieve buffered messages from @self. Once @callback is called,
use tp_debug_client_get_messages_finish() to retrieve the #TpDebugMessage
objects.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">callback to call when the messages have been retrieved</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_messages_finish"
              c:identifier="tp_debug_client_get_messages_finish"
              version="0.19.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_debug_client_set_enabled_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GPtrArray of #TpDebugMessage</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="DebugMessage"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_enabled"
              c:identifier="tp_debug_client_is_enabled"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpDebugClient:enabled property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpDebugClient:enabled property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_enabled_async"
              c:identifier="tp_debug_client_set_enabled_async"
              version="0.19.0">
        <doc xml:whitespace="preserve">Enable or disable publishing of debug messages on the bus by the component
owning @self's bus name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if debug messages should be published on the bus, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_finish"
              c:identifier="tp_debug_client_set_enabled_finish"
              version="0.19.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_debug_client_set_enabled_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, if the operation suceeded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="enabled" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if debug messages are published on the bus.

This property is meaningless until the
%TP_DEBUG_CLIENT_FEATURE_CORE feature has been prepared.</doc>
        <type name="gboolean"/>
      </property>
      <glib:signal name="new-debug-message" when="last" version="0.19.0">
        <doc xml:whitespace="preserve">Emitted when a #TpDebugMessage is generated if the TpDebugMessage:enabled
property is set to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDebugMessage</doc>
            <type name="DebugMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DebugClientClass"
            c:type="TpDebugClientClass"
            disguised="1"
            glib:is-gtype-struct-for="DebugClient"
            version="0.19.0">
      <doc xml:whitespace="preserve">The class of a #TpDebugClient.</doc>
    </record>
    <record name="DebugClientPrivate"
            c:type="TpDebugClientPrivate"
            disguised="1">
    </record>
    <enumeration name="DebugLevel" c:type="TpDebugLevel">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="error" value="0" c:identifier="TP_DEBUG_LEVEL_ERROR"/>
      <member name="critical"
              value="1"
              c:identifier="TP_DEBUG_LEVEL_CRITICAL"/>
      <member name="warning" value="2" c:identifier="TP_DEBUG_LEVEL_WARNING"/>
      <member name="message" value="3" c:identifier="TP_DEBUG_LEVEL_MESSAGE"/>
      <member name="info" value="4" c:identifier="TP_DEBUG_LEVEL_INFO"/>
      <member name="debug" value="5" c:identifier="TP_DEBUG_LEVEL_DEBUG"/>
    </enumeration>
    <class name="DebugMessage"
           c:symbol-prefix="debug_message"
           c:type="TpDebugMessage"
           version="0.19.0"
           parent="GObject.Object"
           glib:type-name="TpDebugMessage"
           glib:get-type="tp_debug_message_get_type"
           glib:type-struct="DebugMessageClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpDebugMessage.</doc>
      <method name="get_category"
              c:identifier="tp_debug_message_get_category"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpDebugMessage:category property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpDebugMessage:category property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_domain"
              c:identifier="tp_debug_message_get_domain"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpDebugMessage:domain property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpDebugMessage:domain property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_level"
              c:identifier="tp_debug_message_get_level"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpDebugMessage:level property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpDebugMessage:level property</doc>
          <type name="GLib.LogLevelFlags" c:type="GLogLevelFlags"/>
        </return-value>
      </method>
      <method name="get_message"
              c:identifier="tp_debug_message_get_message"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpDebugMessage:message property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpDebugMessage:message property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_time"
              c:identifier="tp_debug_message_get_time"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpDebugMessage:time property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpDebugMessage:time property</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
      </method>
      <property name="category" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Category of the debug message, or %NULL if none was specified.</doc>
        <type name="utf8"/>
      </property>
      <property name="domain" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Domain of the debug message.</doc>
        <type name="utf8"/>
      </property>
      <property name="level" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GLogLevelFlags representing the level of the debug message.</doc>
        <type name="guint"/>
      </property>
      <property name="message" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Text of the debug message, stripped from its trailing whitespaces.</doc>
        <type name="utf8"/>
      </property>
      <property name="time" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Timestamp of the debug message.</doc>
        <type name="GLib.DateTime"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DebugMessagePriv" c:type="TpDebugMessagePriv*"/>
      </field>
    </class>
    <record name="DebugMessageClass"
            c:type="TpDebugMessageClass"
            glib:is-gtype-struct-for="DebugMessage"
            version="0.19.0">
      <doc xml:whitespace="preserve">The class of a #TpDebugMessage.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="DebugMessagePriv" c:type="TpDebugMessagePriv" disguised="1">
    </record>
    <bitfield name="DeliveryReportingSupportFlags"
              c:type="TpDeliveryReportingSupportFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Flags indicating the level of support for delivery reporting on this         channel, as found on the         DeliveryReportingSupport property. Any         future flags added to this set will conform to the         convention that the presence of an extra flag implies that         more operations will succeed. Note that CMs may always provide more         reports than are requested in the         Message_Sending_Flags passed to         SendMessage.                     If senders want delivery reports, they should ask for them.  If they           don't want delivery reports, they can just ignore them, so there's no           need to have capability discovery for what will happen if a delivery           report isn't requested.                ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="failures"
              value="1"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_FAILURES"/>
      <member name="successes"
              value="2"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_SUCCESSES"/>
      <member name="read"
              value="4"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_READ"/>
      <member name="deleted"
              value="8"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_DELETED"/>
    </bitfield>
    <enumeration name="DeliveryStatus" c:type="TpDeliveryStatus">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The status of a message as indicated by a delivery report.          If this enum is extended in future specifications, this should           only be to add new, non-overlapping conditions (i.e. all failures           should still be signalled as either Temporarily_Failed           or Permanently_Failed). If additional detail is required (e.g.           distinguishing between the various types of permanent failure) this           will be done using additional           Delivery_Report_Header_Keys.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_DELIVERY_STATUS_UNKNOWN"/>
      <member name="delivered"
              value="1"
              c:identifier="TP_DELIVERY_STATUS_DELIVERED"/>
      <member name="temporarily_failed"
              value="2"
              c:identifier="TP_DELIVERY_STATUS_TEMPORARILY_FAILED"/>
      <member name="permanently_failed"
              value="3"
              c:identifier="TP_DELIVERY_STATUS_PERMANENTLY_FAILED"/>
      <member name="accepted"
              value="4"
              c:identifier="TP_DELIVERY_STATUS_ACCEPTED"/>
      <member name="read" value="5" c:identifier="TP_DELIVERY_STATUS_READ"/>
      <member name="deleted"
              value="6"
              c:identifier="TP_DELIVERY_STATUS_DELETED"/>
    </enumeration>
    <constant name="ERROR_PREFIX"
              value="org.freedesktop.Telepathy.Error"
              c:type="TP_ERROR_PREFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="Error" c:type="TpError" glib:error-domain="tp_errors">
      <doc xml:whitespace="preserve">Enumerated type representing the Telepathy D-Bus errors.</doc>
      <member name="network_error"
              value="0"
              c:identifier="TP_ERROR_NETWORK_ERROR"/>
      <member name="not_implemented"
              value="1"
              c:identifier="TP_ERROR_NOT_IMPLEMENTED"/>
      <member name="invalid_argument"
              value="2"
              c:identifier="TP_ERROR_INVALID_ARGUMENT"/>
      <member name="not_available"
              value="3"
              c:identifier="TP_ERROR_NOT_AVAILABLE"/>
      <member name="permission_denied"
              value="4"
              c:identifier="TP_ERROR_PERMISSION_DENIED"/>
      <member name="disconnected"
              value="5"
              c:identifier="TP_ERROR_DISCONNECTED"/>
      <member name="invalid_handle"
              value="6"
              c:identifier="TP_ERROR_INVALID_HANDLE"/>
      <member name="channel_banned"
              value="7"
              c:identifier="TP_ERROR_CHANNEL_BANNED"/>
      <member name="channel_full"
              value="8"
              c:identifier="TP_ERROR_CHANNEL_FULL"/>
      <member name="channel_invite_only"
              value="9"
              c:identifier="TP_ERROR_CHANNEL_INVITE_ONLY"/>
      <member name="not_yours" value="10" c:identifier="TP_ERROR_NOT_YOURS"/>
      <member name="cancelled" value="11" c:identifier="TP_ERROR_CANCELLED"/>
      <member name="authentication_failed"
              value="12"
              c:identifier="TP_ERROR_AUTHENTICATION_FAILED"/>
      <member name="encryption_not_available"
              value="13"
              c:identifier="TP_ERROR_ENCRYPTION_NOT_AVAILABLE"/>
      <member name="encryption_error"
              value="14"
              c:identifier="TP_ERROR_ENCRYPTION_ERROR"/>
      <member name="cert_not_provided"
              value="15"
              c:identifier="TP_ERROR_CERT_NOT_PROVIDED"/>
      <member name="cert_untrusted"
              value="16"
              c:identifier="TP_ERROR_CERT_UNTRUSTED"/>
      <member name="cert_expired"
              value="17"
              c:identifier="TP_ERROR_CERT_EXPIRED"/>
      <member name="cert_not_activated"
              value="18"
              c:identifier="TP_ERROR_CERT_NOT_ACTIVATED"/>
      <member name="cert_fingerprint_mismatch"
              value="19"
              c:identifier="TP_ERROR_CERT_FINGERPRINT_MISMATCH"/>
      <member name="cert_hostname_mismatch"
              value="20"
              c:identifier="TP_ERROR_CERT_HOSTNAME_MISMATCH"/>
      <member name="cert_self_signed"
              value="21"
              c:identifier="TP_ERROR_CERT_SELF_SIGNED"/>
      <member name="cert_invalid"
              value="22"
              c:identifier="TP_ERROR_CERT_INVALID"/>
      <member name="not_capable"
              value="23"
              c:identifier="TP_ERROR_NOT_CAPABLE"/>
      <member name="offline" value="24" c:identifier="TP_ERROR_OFFLINE"/>
      <member name="channel_kicked"
              value="25"
              c:identifier="TP_ERROR_CHANNEL_KICKED"/>
      <member name="busy" value="26" c:identifier="TP_ERROR_BUSY"/>
      <member name="no_answer" value="27" c:identifier="TP_ERROR_NO_ANSWER"/>
      <member name="does_not_exist"
              value="28"
              c:identifier="TP_ERROR_DOES_NOT_EXIST"/>
      <member name="terminated" value="29" c:identifier="TP_ERROR_TERMINATED"/>
      <member name="connection_refused"
              value="30"
              c:identifier="TP_ERROR_CONNECTION_REFUSED"/>
      <member name="connection_failed"
              value="31"
              c:identifier="TP_ERROR_CONNECTION_FAILED"/>
      <member name="connection_lost"
              value="32"
              c:identifier="TP_ERROR_CONNECTION_LOST"/>
      <member name="already_connected"
              value="33"
              c:identifier="TP_ERROR_ALREADY_CONNECTED"/>
      <member name="connection_replaced"
              value="34"
              c:identifier="TP_ERROR_CONNECTION_REPLACED"/>
      <member name="registration_exists"
              value="35"
              c:identifier="TP_ERROR_REGISTRATION_EXISTS"/>
      <member name="service_busy"
              value="36"
              c:identifier="TP_ERROR_SERVICE_BUSY"/>
      <member name="resource_unavailable"
              value="37"
              c:identifier="TP_ERROR_RESOURCE_UNAVAILABLE"/>
      <member name="would_break_anonymity"
              value="38"
              c:identifier="TP_ERROR_WOULD_BREAK_ANONYMITY"/>
      <member name="cert_revoked"
              value="39"
              c:identifier="TP_ERROR_CERT_REVOKED"/>
      <member name="cert_insecure"
              value="40"
              c:identifier="TP_ERROR_CERT_INSECURE"/>
      <member name="cert_limit_exceeded"
              value="41"
              c:identifier="TP_ERROR_CERT_LIMIT_EXCEEDED"/>
      <member name="not_yet" value="42" c:identifier="TP_ERROR_NOT_YET"/>
      <member name="rejected" value="43" c:identifier="TP_ERROR_REJECTED"/>
      <member name="picked_up_elsewhere"
              value="44"
              c:identifier="TP_ERROR_PICKED_UP_ELSEWHERE"/>
      <member name="confused" value="45" c:identifier="TP_ERROR_CONFUSED"/>
      <member name="service_confused"
              value="46"
              c:identifier="TP_ERROR_SERVICE_CONFUSED"/>
      <member name="emergency_calls_not_supported"
              value="47"
              c:identifier="TP_ERROR_EMERGENCY_CALLS_NOT_SUPPORTED"/>
      <member name="software_upgrade_required"
              value="48"
              c:identifier="TP_ERROR_SOFTWARE_UPGRADE_REQUIRED"/>
      <member name="insufficient_balance"
              value="49"
              c:identifier="TP_ERROR_INSUFFICIENT_BALANCE"/>
      <member name="media_codecs_incompatible"
              value="50"
              c:identifier="TP_ERROR_MEDIA_CODECS_INCOMPATIBLE"/>
      <member name="media_unsupported_type"
              value="51"
              c:identifier="TP_ERROR_MEDIA_UNSUPPORTED_TYPE"/>
      <member name="media_streaming_error"
              value="52"
              c:identifier="TP_ERROR_MEDIA_STREAMING_ERROR"/>
      <member name="captcha_not_supported"
              value="53"
              c:identifier="TP_ERROR_CAPTCHA_NOT_SUPPORTED"/>
    </enumeration>
    <enumeration name="FileHashType" c:type="TpFileHashType">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_FILE_HASH_TYPE_NONE"/>
      <member name="md5" value="1" c:identifier="TP_FILE_HASH_TYPE_MD5"/>
      <member name="sha1" value="2" c:identifier="TP_FILE_HASH_TYPE_SHA1"/>
      <member name="sha256" value="3" c:identifier="TP_FILE_HASH_TYPE_SHA256"/>
    </enumeration>
    <class name="FileTransferChannel"
           c:symbol-prefix="file_transfer_channel"
           c:type="TpFileTransferChannel"
           version="0.15.5"
           parent="Channel"
           glib:type-name="TpFileTransferChannel"
           glib:get-type="tp_file_transfer_channel_get_type"
           glib:type-struct="FileTransferChannelClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpFileTransferChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_file_transfer_channel_new"
                   version="0.15.5"
                   deprecated="Use tp_simple_client_factory_ensure_channel() instead."
                   throws="1">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpFileTransferChannel</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpFileTransferChannel</doc>
          <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable properties of the channel, as signalled by the NewChannel D-Bus signal or returned by the CreateChannel and EnsureChannel D-Bus methods: a mapping from strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_file_transfer_channel_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="accept_file_async"
              c:identifier="tp_file_transfer_channel_accept_file_async"
              version="0.17.1">
        <doc xml:whitespace="preserve">Accept an incoming file transfer in the
%TP_FILE_TRANSFER_STATE_PENDING state. Once the accept has been
processed, @callback will be called. You can then call
tp_file_transfer_channel_accept_file_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFile where the file should be saved</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">Offset from the start of @file where transfer begins</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the transfer has been accepted</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_file_finish"
              c:identifier="tp_file_transfer_channel_accept_file_finish"
              version="0.17.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a call to tp_file_transfer_channel_accept_file_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the accept operation was a success, or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date"
              c:identifier="tp_file_transfer_channel_get_date"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:date property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:date property</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
      </method>
      <method name="get_description"
              c:identifier="tp_file_transfer_channel_get_description"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:description property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:description property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_filename"
              c:identifier="tp_file_transfer_channel_get_filename"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:filename property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:filename property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_metadata"
              c:identifier="tp_file_transfer_channel_get_metadata"
              version="0.17.1"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:metadata property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:metadata property</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Strv"/>
          </type>
        </return-value>
      </method>
      <method name="get_mime_type"
              c:identifier="tp_file_transfer_channel_get_mime_type"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:mime-type property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:mime-type property</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
      </method>
      <method name="get_service_name"
              c:identifier="tp_file_transfer_channel_get_service_name"
              version="0.17.1">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:service-name property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:service-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_size"
              c:identifier="tp_file_transfer_channel_get_size"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:size property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:size property</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="get_state"
              c:identifier="tp_file_transfer_channel_get_state"
              version="0.17.1">
        <doc xml:whitespace="preserve">Returns the #TpFileTransferChannel:state property.

If @reason is not %NULL it is set to the reason why
#TpFileTransferChannel:state changed to its current value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:state property</doc>
          <type name="FileTransferState" c:type="TpFileTransferState"/>
        </return-value>
        <parameters>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #TpFileTransferStateChangeReason, or %NULL</doc>
            <type name="FileTransferStateChangeReason"
                  c:type="TpFileTransferStateChangeReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_transferred_bytes"
              c:identifier="tp_file_transfer_channel_get_transferred_bytes"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:transferred-bytes property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:transferred-bytes property</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="provide_file_async"
              c:identifier="tp_file_transfer_channel_provide_file_async"
              version="0.17.1">
        <doc xml:whitespace="preserve">Provide a file transfer. This should be called when the file
transfer state changes (tp_file_transfer_channel_get_state() and
the "notify::state" signal) to
%TP_FILE_TRANSFER_STATE_ACCEPTED or
%TP_FILE_TRANSFER_STATE_PENDING. Once the file has been provided,
the channel #TpFileTransferChannel:state will change to
%TP_FILE_TRANSFER_STATE_OPEN.

Once the file has been provided, @callback will be called. You
should then call tp_file_transfer_channel_provide_file_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFile to send to the remote contact</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the transfer has been accepted</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="provide_file_finish"
              c:identifier="tp_file_transfer_channel_provide_file_finish"
              version="0.17.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a call to tp_file_transfer_channel_provide_file_async().


Successful return from this function does not mean that the file
transfer has completed or has even started at all. The state of the
file transfer should be monitored with the "notify::state" signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file has been successfully provided, or %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="date" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GDateTime representing the last modification time of the file to be
transferred.

Since 0.15.5</doc>
        <type name="GLib.DateTime"/>
      </property>
      <property name="description" transfer-ownership="none">
        <doc xml:whitespace="preserve">The description of the file transfer, defined by the sender when
sending the file transfer offer.

Since 0.15.5</doc>
        <type name="utf8"/>
      </property>
      <property name="file" version="0.17.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">For incoming file transfers, this property will be set to a
#GFile for the location where the file will be saved (given by
tp_file_transfer_channel_accept_file_async()) when the transfer
starts. The feature %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE must
already be prepared for this property to have a meaningful
value, and to receive change notification.  Once the initial
value is set, this property will not be changed.

For outgoing file transfers, this property is a #GFile for the
location of the file being sent (given by
tp_file_transfer_channel_provide_file_async()). The feature
%TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE does not have to be
prepared and there is no change notification.</doc>
        <type name="Gio.File"/>
      </property>
      <property name="filename" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the file on the sender's side. This is therefore given as a
suggested filename for the receiver.

Since 0.15.5</doc>
        <type name="utf8"/>
      </property>
      <property name="initial-offset"
                version="0.17.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The offset in bytes from where the file should be sent.

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful and kept up to date.</doc>
        <type name="guint64"/>
      </property>
      <property name="metadata"
                version="0.17.1"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Additional information about the file transfer set by the channel
initiator, or an empty #GHashTable if the initiator did not
provide any additional information.

To provide metadata along with a file offer, include
%TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA in the
channel request. For example:

|[
GHashTable *request;
GHashTable *metadata = g_hash_table_new (g_str_hash, g_str_equal);
const gchar * const values[] = { "Jason Derulo", "Tinie Tempah", NULL };

g_hash_table_insert (metadata, "best buds", values);

request = tp_asv_new (
    TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING, TP_IFACE_CHANNEL_TYPE_FILE_TRANSFER,
    TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_CONTACT,
    TP_PROP_CHANNEL_TARGET_ID, G_TYPE_STRING, "foo@bar.com",
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE, G_TYPE_STRING, "text/plain",
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE, G_TYPE_INT64, 1320925992,
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION, G_TYPE_STRING, "",
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME, G_TYPE_STRING, "test.pdf",
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET, G_TYPE_UINT64, 0,
    TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE, G_TYPE_UINT64, 165710,
    TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA, TP_TYPE_METADATA, metadata,
    NULL);

...
]|

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful.</doc>
        <type/>
      </property>
      <property name="mime-type" version="0.15.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">The MIME type of the file to be transferred.</doc>
        <type name="utf8"/>
      </property>
      <property name="service-name" version="0.17.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string representing the name of the service suggested to handle
this file transfer channel, or %NULL if the initiator did not
provide one.

This is a useful way of requesting file transfer channels with a
hint of what handler they should be handled by on the remote
side. If a channel request is made with this property set (to a
contact who also supports the metadata extension; see the
requestable channel classes for said contact), this property will
be set to the same value on the remote incoming channel and
handlers can match on this in their handler filter. For example,
a remote handler could call the following:

|[
tp_base_client_take_handler_filter (handler, tp_asv_new (
              TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING, TP_IFACE_CHANNEL_TYPE_FILE_TRANSFER,
              TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_CONTACT,
              TP_PROP_CHANNEL_REQUESTED, G_TYPE_BOOLEAN, FALSE,
              TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME, G_TYPE_STRING, "service.name",
              NULL));
]|

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful.</doc>
        <type name="utf8"/>
      </property>
      <property name="size" transfer-ownership="none">
        <doc xml:whitespace="preserve">The size of the file to be transferred,
or %G_MAXUINT64 if not known.

Since 0.15.5</doc>
        <type name="guint64"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:whitespace="preserve">A TpFileTransferState holding the state of the file transfer.

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful and kept up to date.

Since 0.17.1</doc>
        <type name="guint"/>
      </property>
      <property name="transferred-bytes"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The number of bytes transferred so far in this
file transfer.

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful and kept up to date.</doc>
        <type name="guint64"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FileTransferChannelPrivate"
              c:type="TpFileTransferChannelPrivate*"/>
      </field>
    </class>
    <record name="FileTransferChannelClass"
            c:type="TpFileTransferChannelClass"
            glib:is-gtype-struct-for="FileTransferChannel"
            version="0.15.5">
      <doc xml:whitespace="preserve">The class of a #TpFileTransferChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="8">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="FileTransferChannelPrivate"
            c:type="TpFileTransferChannelPrivate"
            disguised="1">
    </record>
    <enumeration name="FileTransferState" c:type="TpFileTransferState">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_FILE_TRANSFER_STATE_NONE"/>
      <member name="pending"
              value="1"
              c:identifier="TP_FILE_TRANSFER_STATE_PENDING"/>
      <member name="accepted"
              value="2"
              c:identifier="TP_FILE_TRANSFER_STATE_ACCEPTED"/>
      <member name="open"
              value="3"
              c:identifier="TP_FILE_TRANSFER_STATE_OPEN"/>
      <member name="completed"
              value="4"
              c:identifier="TP_FILE_TRANSFER_STATE_COMPLETED"/>
      <member name="cancelled"
              value="5"
              c:identifier="TP_FILE_TRANSFER_STATE_CANCELLED"/>
    </enumeration>
    <enumeration name="FileTransferStateChangeReason"
                 c:type="TpFileTransferStateChangeReason">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_NONE"/>
      <member name="requested"
              value="1"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REQUESTED"/>
      <member name="local_stopped"
              value="2"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_STOPPED"/>
      <member name="remote_stopped"
              value="3"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_STOPPED"/>
      <member name="local_error"
              value="4"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_ERROR"/>
      <member name="remote_error"
              value="5"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_ERROR"/>
    </enumeration>
    <record name="GroupMixin" c:type="TpGroupMixin">
      <doc xml:whitespace="preserve">Structure representing the group mixin as used in a particular class.
To be placed in the implementation's instance structure.

All fields should be considered read-only.</doc>
      <field name="handle_repo" writable="1">
        <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
      </field>
      <field name="self_handle" writable="1">
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="group_flags" writable="1">
        <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
      </field>
      <field name="members" writable="1">
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="local_pending" writable="1">
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="remote_pending" writable="1">
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="priv" writable="1">
        <type name="GroupMixinPrivate" c:type="TpGroupMixinPrivate*"/>
      </field>
      <function name="add_handle_owner"
                c:identifier="tp_group_mixin_add_handle_owner"
                introspectable="0">
        <doc xml:whitespace="preserve">Note that the given local handle is an alias within this group
for the given globally-valid handle. It will be returned from subsequent
GetHandleOwner queries where appropriate.

Changed in 0.7.10: The @owner_handle may be 0. To comply with telepathy-spec
 0.17.6, before adding any channel-specific handle to the members,
 local-pending members or remote-pending members, you must call either
 this function or tp_group_mixin_add_handle_owners().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="local_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">A contact handle valid within this group (may not be 0)</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="owner_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">A contact handle valid globally, or 0 if the owner of the @local_handle is unknown</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="add_handle_owners"
                c:identifier="tp_group_mixin_add_handle_owners"
                version="0.7.10"
                introspectable="0">
        <doc xml:whitespace="preserve">Note that the given local handles are aliases within this group
for the given globally-valid handles.

To comply with telepathy-spec 0.17.6, before adding any channel-specific
handle to the members, local-pending members or remote-pending members, you
must call either this function or tp_group_mixin_add_handle_owner().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="local_to_owner_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">A map from contact handles valid within this group (which may not be 0) to either contact handles valid globally, or 0 if the owner of the corresponding key is unknown; all handles are stored using GUINT_TO_POINTER</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="add_members"
                c:identifier="tp_group_mixin_add_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Request that the given contacts be added to the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
Otherwise attempt to add the contacts by calling the callbacks provided
by the channel implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A message associated with the addition request, if supported</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="change_flags"
                c:identifier="tp_group_mixin_change_flags"
                introspectable="0">
        <doc xml:whitespace="preserve">Request a change to be made to the flags. If any flags were actually
set or cleared, emits the GroupFlagsChanged signal with the changes.

It is an error to set any of the same bits in both @add and @del.

Changed in 0.7.7: the signal is not emitted if adding @add and
 removing @del had no effect on the existing group flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the groups interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags to be added</doc>
            <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
          </parameter>
          <parameter name="del" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags to be removed</doc>
            <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="change_members"
                c:identifier="tp_group_mixin_change_members"
                introspectable="0">
        <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed) signals were emitted; %FALSE if nothing actually changed and the signals were suppressed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A message to be sent to the affected contacts if possible; %NULL is allowed, and is mapped to an empty string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="del" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="add_local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="add_remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle of the contact responsible for this change</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">The reason for this change</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason"/>
          </parameter>
        </parameters>
      </function>
      <function name="change_members_detailed"
                c:identifier="tp_group_mixin_change_members_detailed"
                version="0.7.21"
                introspectable="0">
        <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.

details may contain, among other entries, the well-known
keys (and corresponding type, wrapped in a GValue) defined by the
Group.MembersChangedDetailed signal's specification; these include "actor"
(a handle as G_TYPE_UINT), "change-reason" (an element of
#TpChannelGroupChangeReason as G_TYPE_UINT), "message" (G_TYPE_STRING),
"error" (G_TYPE_STRING), "debug-message" (G_TYPE_STRING).

If all of the information in details could be passed to
tp_group_mixin_change_members() then calling this function instead provides
no benefit. Calling this function without setting
#TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED with
tp_group_mixin_change_members() first is not very useful, as clients will
not know to listen for MembersChangedDetailed and thus will miss the
details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed) signals were emitted; %FALSE if nothing actually changed and the signals were suppressed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="del" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="add_local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="add_remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">a map from strings to GValues detailing the change</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="change_self_handle"
                c:identifier="tp_group_mixin_change_self_handle"
                introspectable="0">
        <doc xml:whitespace="preserve">Change the self-handle for this group to the given value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="new_self_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new self-handle for this group</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="finalize"
                c:identifier="tp_group_mixin_finalize"
                introspectable="0">
        <doc xml:whitespace="preserve">Unreference handles and free resources used by this mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_all_members"
                c:identifier="tp_group_mixin_get_all_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's current and pending members.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="members" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's local pending members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_dbus_property"
                c:identifier="tp_group_mixin_get_dbus_property"
                version="0.7.10"
                introspectable="0">
        <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
@object has the group mixin. It can only be used for the Group interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:whitespace="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A quark representing the D-Bus property name, either "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members", "RemotePendingMembers" or "SelfHandle"</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="unused" transfer-ownership="none">
            <doc xml:whitespace="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_group_flags"
                c:identifier="tp_group_mixin_get_group_flags"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Set the guint pointed to by ret to this group's flags, to be
interpreted according to TpChannelGroupFlags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return the flags</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_handle_owners"
                c:identifier="tp_group_mixin_get_handle_owners"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">If the mixin has the flag %TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES,
return the global owners of the given local handles, or 0 where
unavailable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE (setting @ret) on success, %FALSE (setting @error) on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of guint representing locally valid handles</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return an array of guint representing globally valid handles, or 0 where unavailable, if %TRUE is returned</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_local_pending_members"
                c:identifier="tp_group_mixin_get_local_pending_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's local-pending members.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_local_pending_members_with_info"
                c:identifier="tp_group_mixin_get_local_pending_members_with_info"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's local-pending members and information about their
requests to join the channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GPtrArray of D-Bus structures each containing the handle of a local-pending contact, the handle of a contact responsible for adding them to the group (or 0), the reason code and a related message (e.g. their request to join the group)</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_members"
                c:identifier="tp_group_mixin_get_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's current members</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_group_mixin_get_offset_quark"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_remote_pending_members"
                c:identifier="tp_group_mixin_get_remote_pending_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's remote-pending members.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_self_handle"
                c:identifier="tp_group_mixin_get_self_handle"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Set the guint pointed to by ret to the local user's handle in this
group, or to 0 if the local user is not present in this group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return the local user's handle in this group</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="iface_init"
                c:identifier="tp_group_mixin_iface_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the group interface using
this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Unused</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init"
                c:identifier="tp_group_mixin_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The offset of the TpGroupMixin structure within the instance structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
          <parameter name="handle_repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">The connection's handle repository for contacts</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="self_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle of the local user in this group, if any</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_dbus_properties"
                c:identifier="tp_group_mixin_init_dbus_properties"
                version="0.7.10"
                introspectable="0">
        <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.

This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to any channels of this class
with tp_group_mixin_change_flags() to indicate that the DBus properties are
available.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_members"
                c:identifier="tp_group_mixin_remove_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_members_with_reason"
                c:identifier="tp_group_mixin_remove_members_with_reason"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #TpChannelGroupChangeReason</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="GroupMixinAddMemberFunc"
              c:type="TpGroupMixinAddMemberFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to add a member to the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be added.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to be added</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="GroupMixinClass" c:type="TpGroupMixinClass">
      <doc xml:whitespace="preserve">Structure representing the group mixin as used in a particular class.
To be placed in the implementation's class structure.

Initialize this with tp_group_mixin_class_init().

All fields should be considered read-only.</doc>
      <field name="add_member" writable="1">
        <type name="GroupMixinAddMemberFunc"
              c:type="TpGroupMixinAddMemberFunc"/>
      </field>
      <field name="remove_member" writable="1">
        <type name="GroupMixinRemMemberFunc"
              c:type="TpGroupMixinRemMemberFunc"/>
      </field>
      <field name="priv" writable="1">
        <type name="GroupMixinClassPrivate"
              c:type="TpGroupMixinClassPrivate*"/>
      </field>
      <function name="allow_self_removal"
                c:identifier="tp_group_mixin_class_allow_self_removal"
                version="0.7.27"
                introspectable="0">
        <doc xml:whitespace="preserve">Configure the mixin to allow attempts to remove the SelfHandle from this
Group, even if the group flags would otherwise disallow this. The
channel's #TpGroupMixinRemMemberFunc or
#TpGroupMixinRemMemberWithReasonFunc will be called as usual for such
attempts, and may make them fail with %TP_ERROR_PERMISSION_DENIED if
required.

This function should be called from the GObject @class_init callback,
after calling tp_group_mixin_class_init().

(Recent telepathy-spec changes make it valid to try to remove the
self-handle at all times, regardless of group flags. However, if this was
implemented automatically in TpGroupMixin, this would risk crashing
connection manager implementations that assume that TpGroupMixin will
enforce the group flags strictly. As a result, connection managers should
call this function to indicate to the TpGroupMixin that it may call their
removal callback with the self-handle regardless of flag settings.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_group_mixin_class_get_offset_quark"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init"
                c:identifier="tp_group_mixin_class_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Configure the mixin for use with the given class.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The offset of the TpGroupMixinClass structure within the class structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
          <parameter name="add_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to add contacts to this group</doc>
            <type name="GroupMixinAddMemberFunc"
                  c:type="TpGroupMixinAddMemberFunc"/>
          </parameter>
          <parameter name="rem_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group. This must be %NULL if you will subsequently call tp_group_mixin_class_set_remove_with_reason_func().</doc>
            <type name="GroupMixinRemMemberFunc"
                  c:type="TpGroupMixinRemMemberFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_remove_with_reason_func"
                c:identifier="tp_group_mixin_class_set_remove_with_reason_func"
                version="0.5.13"
                introspectable="0">
        <doc xml:whitespace="preserve">Set a callback to be used to implement RemoveMembers() and
RemoveMembersWithReason(). If this function is called during class
initialization, the given callback will be used instead of the remove
callback passed to tp_group_mixin_class_init() (which must be %NULL
in this case).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group with a specified reason.</doc>
            <type name="GroupMixinRemMemberWithReasonFunc"
                  c:type="TpGroupMixinRemMemberWithReasonFunc"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="GroupMixinClassPrivate"
            c:type="TpGroupMixinClassPrivate"
            disguised="1">
    </record>
    <record name="GroupMixinPrivate"
            c:type="TpGroupMixinPrivate"
            disguised="1">
    </record>
    <callback name="GroupMixinRemMemberFunc"
              c:type="TpGroupMixinRemMemberFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to remove a member from the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be removed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to be removed</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="GroupMixinRemMemberWithReasonFunc"
              c:type="TpGroupMixinRemMemberWithReasonFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to remove a member from the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be removed.

Set this with tp_group_mixin_class_set_remove_with_reason_func(), .</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to be removed</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpChannelGroupChangeReason indicating the reason</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="HTTPMethod" c:type="TpHTTPMethod">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The HTTP Method with which to request a URL.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="get" value="0" c:identifier="TP_HTTP_METHOD_GET"/>
      <member name="post" value="1" c:identifier="TP_HTTP_METHOD_POST"/>
    </enumeration>
    <class name="HandleChannelsContext"
           c:symbol-prefix="handle_channels_context"
           c:type="TpHandleChannelsContext"
           version="0.11.6"
           parent="GObject.Object"
           glib:type-name="TpHandleChannelsContext"
           glib:get-type="tp_handle_channels_context_get_type"
           glib:type-struct="HandleChannelsContextClass">
      <doc xml:whitespace="preserve">Data structure representing the context of a Handler.HandleChannels()
call.</doc>
      <method name="accept"
              c:identifier="tp_handle_channels_context_accept"
              version="0.11.6">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl when it's done so
the D-Bus method can return.

The caller is responsible for closing channels with
tp_cli_channel_call_close() when it has finished handling them.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="delay"
              c:identifier="tp_handle_channels_context_delay"
              version="0.11.6">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpHandleChannelsContext before calling this function, and
is responsible for calling either
tp_handle_channels_context_accept() or
tp_handle_channels_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fail"
              c:identifier="tp_handle_channels_context_fail"
              version="0.11.6">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_handler_info"
              c:identifier="tp_handle_channels_context_get_handler_info"
              version="0.11.14">
        <doc xml:whitespace="preserve">Return any extra information that accompanied this request to handle
channels (the Handler_Info argument from the HandleChannels D-Bus method).
Well-known keys for this map will be defined by the Telepathy D-Bus
Interface Specification; at the time of writing, none have been defined.

The returned hash table is only valid for as long as @self is.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">extensible extra handler information, in a form suitable for use with tp_asv_get_string() etc.</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_requests"
              c:identifier="tp_handle_channels_context_get_requests"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return a list of the #TpChannelRequest which have been satisfied by the
channels associated with #self.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GList of reffed #TpChannelRequest.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
      </method>
      <property name="account"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAccount object representing the Account of the DispatchOperation
that has been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channels"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection object representing the Connection of the DispatchOperation
that has been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="dbus-context"
                version="0.11.6"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
HandleChannels call.
Can only be written during construction.</doc>
        <type name="gpointer"/>
      </property>
      <property name="handler-info"
                version="0.11.6"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GHashTable where the keys are string and values are GValue instances.
It represents the Handler_info hash table that has been passed to
HandleChannels.

This property can't be %NULL.</doc>
        <type/>
      </property>
      <property name="requests-satisfied"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannelRequest objects representing the
requests that have been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="user-action-time"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The time at which user action occurred, or one of the
special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
%TP_USER_ACTION_TIME_CURRENT_TIME
(see #TpAccountChannelRequest:user-action-time for details)

Read-only except during construction.</doc>
        <type name="gint64"/>
      </property>
      <glib:signal name="done" when="last" detailed="1" version="0.11.6">
        <doc xml:whitespace="preserve">Emitted when tp_handle_channels_context_accept has been called on @self.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="HandleChannelsContextClass"
            c:type="TpHandleChannelsContextClass"
            disguised="1"
            glib:is-gtype-struct-for="HandleChannelsContext"
            version="0.11.6">
      <doc xml:whitespace="preserve">The class of a #TpHandleChannelsContext.</doc>
    </record>
    <record name="HandleChannelsContextPrivate"
            c:type="TpHandleChannelsContextPrivate"
            disguised="1">
    </record>
    <interface name="HandleRepoIface"
               c:symbol-prefix="handle_repo_iface"
               c:type="TpHandleRepoIface"
               glib:type-name="TpHandleRepoIface"
               glib:get-type="tp_handle_repo_iface_get_type">
      <doc xml:whitespace="preserve">Dummy typedef representing any implementation of this interface.</doc>
      <property name="handle-type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
    </interface>
    <record name="HandleRepoIfaceClass"
            c:type="TpHandleRepoIfaceClass"
            disguised="1">
      <doc xml:whitespace="preserve">The class of a handle repository interface. The structure layout is
only available within telepathy-glib, for the handle repository
implementations' benefit.</doc>
    </record>
    <record name="HandleSet"
            c:type="TpHandleSet"
            glib:type-name="TpHandleSet"
            glib:get-type="tp_handle_set_get_type"
            c:symbol-prefix="handle_set">
      <doc xml:whitespace="preserve">A set of handles. This is similar to a #TpIntset (and implemented using
one), but adding a handle to the set also references it.</doc>
      <constructor name="new"
                   c:identifier="tp_handle_set_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_containing"
                   c:identifier="tp_handle_set_new_containing"
                   version="0.13.0"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet from a specified handle repository and single
handle.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a valid handle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_array"
                   c:identifier="tp_handle_set_new_from_array"
                   version="0.11.7"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:whitespace="preserve">array of handles to be referenced by this set</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="guint"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_intset"
                   c:identifier="tp_handle_set_new_from_intset"
                   version="0.13.0"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet from a specified handle repository and
set of handles.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="intset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of handles, which must all be valid</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="tp_handle_set_add" introspectable="0">
        <doc xml:whitespace="preserve">Add a handle to a #TpHandleSet, and reference it in the attached
#TpHandleRepoIface</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">handle to add</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear"
              c:identifier="tp_handle_set_clear"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Remove every handle from @set, releasing the references it holds.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="copy"
              c:identifier="tp_handle_set_copy"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet with the same contents as @other.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new set</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
      </method>
      <method name="destroy"
              c:identifier="tp_handle_set_destroy"
              introspectable="0">
        <doc xml:whitespace="preserve">Delete a #TpHandleSet and unreference any handles that it holds</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="difference_update"
              c:identifier="tp_handle_set_difference_update"
              introspectable="0">
        <doc xml:whitespace="preserve">Remove a set of handles from a handle set, dereferencing those which are
members. The TpIntset returned must be freed with tp_intset_destroy.

If you want to be able to inspect the handles in the set returned,
you must ensure that this function does not cause their refcount to drop
to zero, for instance by temporarily taking a reference to all the
handles in @remove, calling this function, doing something with the
result and discarding the temporary references.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the handles which were dereferenced and removed (some subset of @remove).</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="remove" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpIntset of handles to remove</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="tp_handle_set_dump">
        <doc xml:whitespace="preserve">Format a #TpHandleSet for debug output.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string representation of the handle set suitable for debug output</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="foreach"
              c:identifier="tp_handle_set_foreach"
              introspectable="0">
        <doc xml:whitespace="preserve">Call @func(@set, @handle, @userdata) for each handle in @set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">A callback</doc>
            <type name="HandleSetMemberFunc" c:type="TpHandleSetMemberFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Arbitrary data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="tp_handle_set_is_empty"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the same thing as &lt;code&gt;(tp_handle_set_size (set) == 0)&lt;/code&gt;,
but calculated more efficiently.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the set has no members</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_member"
              c:identifier="tp_handle_set_is_member"
              introspectable="0">
        <doc xml:whitespace="preserve">Check if the handle is in this set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the handle is in this set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">handle to check</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="tp_handle_set_peek" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all, this comment is just to keep gtkdoc happy--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the underlying #TpIntset used by this #TpHandleSet</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </method>
      <method name="remove"
              c:identifier="tp_handle_set_remove"
              introspectable="0">
        <doc xml:whitespace="preserve">Remove a handle from a #TpHandleSet, and unreference it in the attached
#TpHandleRepoIface</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if the handle was invalid, or was not in this set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">handle to remove</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="size" c:identifier="tp_handle_set_size" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no further documentation needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of handles in this set</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="to_array"
              c:identifier="tp_handle_set_to_array"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all, this comment is just to keep gtkdoc happy--&gt;</doc>
        <return-value>
          <doc xml:whitespace="preserve">a newly-allocated GArray of guint representing the handles in the set</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="guint"/>
          </array>
        </return-value>
      </method>
      <method name="to_identifier_map"
              c:identifier="tp_handle_set_to_identifier_map">
        <doc xml:whitespace="preserve">Returns a dictionary mapping each handle in @self to the corresponding
identifier, as if retrieved by calling tp_handle_inspect() on each handle.
The type of the returned value is described as
&lt;code&gt;Handle_Identifier_Map&lt;/code&gt; in the Telepathy specification.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a map from the handles in @self to the corresponding identifier.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="Handle"/>
            <type name="utf8"/>
          </type>
        </return-value>
      </method>
      <method name="update"
              c:identifier="tp_handle_set_update"
              introspectable="0">
        <doc xml:whitespace="preserve">Add a set of handles to a handle set, referencing those which are not
already members. The TpIntset returned must be freed with tp_intset_destroy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the handles which were added (some subset of @add)</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="add" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpIntset of handles to add</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <function name="qdata"
                c:identifier="tp_handle_set_qdata"
                introspectable="0"
                deprecated="Since 0.19.9. It is not recommended to use this function because the associated data won&apos;t be freed until the connection disconnects.">
        <doc xml:whitespace="preserve">Associates a blob of data with a given handle and a given key

If @destroy is set, then the data is freed when the handle is freed.

Since version 0.13.8, handles always last as long as the
connection, so @destroy will not be called until the connection
disconnects.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">A handle repository implementation</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">A handle to set data on</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="key_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">Key id to associate data with</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to associate with handle</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">A #GDestroyNotify to call to destroy the data, or NULL if not needed.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="HandleSetMemberFunc"
              c:type="TpHandleSetMemberFunc"
              introspectable="0">
      <doc xml:whitespace="preserve">Signature of the callback used to iterate over the handle set in
tp_handle_set_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <doc xml:whitespace="preserve">The set of handles on which tp_handle_set_foreach() was called</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle in the set</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">Arbitrary user data as supplied to tp_handle_set_foreach()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="HandleType" c:type="TpHandleType">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_HANDLE_TYPE_NONE"/>
      <member name="contact" value="1" c:identifier="TP_HANDLE_TYPE_CONTACT"/>
      <member name="room" value="2" c:identifier="TP_HANDLE_TYPE_ROOM"/>
      <member name="list" value="3" c:identifier="TP_HANDLE_TYPE_LIST"/>
      <member name="group" value="4" c:identifier="TP_HANDLE_TYPE_GROUP"/>
    </enumeration>
    <constant name="IFACE_ACCOUNT"
              value="org.freedesktop.Telepathy.Account"
              c:type="TP_IFACE_ACCOUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_ADDRESSING"
              value="org.freedesktop.Telepathy.Account.Interface.Addressing"
              c:type="TP_IFACE_ACCOUNT_INTERFACE_ADDRESSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_AVATAR"
              value="org.freedesktop.Telepathy.Account.Interface.Avatar"
              c:type="TP_IFACE_ACCOUNT_INTERFACE_AVATAR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_STORAGE"
              value="org.freedesktop.Telepathy.Account.Interface.Storage"
              c:type="TP_IFACE_ACCOUNT_INTERFACE_STORAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_MANAGER"
              value="org.freedesktop.Telepathy.AccountManager"
              c:type="TP_IFACE_ACCOUNT_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_AUTHENTICATION_TLS_CERTIFICATE"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate"
              c:type="TP_IFACE_AUTHENTICATION_TLS_CERTIFICATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT"
              value="org.freedesktop.Telepathy.Call1.Content"
              c:type="TP_IFACE_CALL_CONTENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_INTERFACE_AUDIO_CONTROL"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.AudioControl"
              c:type="TP_IFACE_CALL_CONTENT_INTERFACE_AUDIO_CONTROL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_INTERFACE_DTMF"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.DTMF"
              c:type="TP_IFACE_CALL_CONTENT_INTERFACE_DTMF">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_INTERFACE_MEDIA"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media"
              c:type="TP_IFACE_CALL_CONTENT_INTERFACE_MEDIA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_INTERFACE_VIDEO_CONTROL"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl"
              c:type="TP_IFACE_CALL_CONTENT_INTERFACE_VIDEO_CONTROL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_MEDIA_DESCRIPTION"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription"
              c:type="TP_IFACE_CALL_CONTENT_MEDIA_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports"
              c:type="TP_IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPFeedback"
              c:type="TP_IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTPHeaderExtensions"
              c:type="TP_IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_STREAM"
              value="org.freedesktop.Telepathy.Call1.Stream"
              c:type="TP_IFACE_CALL_STREAM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_STREAM_ENDPOINT"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint"
              c:type="TP_IFACE_CALL_STREAM_ENDPOINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CALL_STREAM_INTERFACE_MEDIA"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media"
              c:type="TP_IFACE_CALL_STREAM_INTERFACE_MEDIA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL"
              value="org.freedesktop.Telepathy.Channel"
              c:type="TP_IFACE_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCHER"
              value="org.freedesktop.Telepathy.ChannelDispatcher"
              c:type="TP_IFACE_CHANNEL_DISPATCHER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interface.OperationList"
              c:type="TP_IFACE_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCH_OPERATION"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation"
              c:type="TP_IFACE_CHANNEL_DISPATCH_OPERATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ANONYMITY"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity"
              c:type="TP_IFACE_CHANNEL_INTERFACE_ANONYMITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CALL_STATE"
              value="org.freedesktop.Telepathy.Channel.Interface.CallState"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CALL_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CHAT_STATE"
              value="org.freedesktop.Telepathy.Channel.Interface.ChatState"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CHAT_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CONFERENCE"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CONFERENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_DESTROYABLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Destroyable"
              c:type="TP_IFACE_CHANNEL_INTERFACE_DESTROYABLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_DTMF"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF"
              c:type="TP_IFACE_CHANNEL_INTERFACE_DTMF">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA"
              value="org.freedesktop.Telepathy.Channel.Interface.FileTransfer.Metadata"
              c:type="TP_IFACE_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_GROUP"
              value="org.freedesktop.Telepathy.Channel.Interface.Group"
              c:type="TP_IFACE_CHANNEL_INTERFACE_GROUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_HOLD"
              value="org.freedesktop.Telepathy.Channel.Interface.Hold"
              c:type="TP_IFACE_CHANNEL_INTERFACE_HOLD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_MEDIA_SIGNALLING"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling"
              c:type="TP_IFACE_CHANNEL_INTERFACE_MEDIA_SIGNALLING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_MESSAGES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages"
              c:type="TP_IFACE_CHANNEL_INTERFACE_MESSAGES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_PASSWORD"
              value="org.freedesktop.Telepathy.Channel.Interface.Password"
              c:type="TP_IFACE_CHANNEL_INTERFACE_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ROOM"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2"
              c:type="TP_IFACE_CHANNEL_INTERFACE_ROOM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ROOM_CONFIG"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1"
              c:type="TP_IFACE_CHANNEL_INTERFACE_ROOM_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SASL_AUTHENTICATION"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SASL_AUTHENTICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SECURABLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Securable"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SECURABLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SMS"
              value="org.freedesktop.Telepathy.Channel.Interface.SMS"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SUBJECT"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SUBJECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_TUBE"
              value="org.freedesktop.Telepathy.Channel.Interface.Tube"
              c:type="TP_IFACE_CHANNEL_INTERFACE_TUBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_REQUEST"
              value="org.freedesktop.Telepathy.ChannelRequest"
              c:type="TP_IFACE_CHANNEL_REQUEST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CALL"
              value="org.freedesktop.Telepathy.Channel.Type.Call1"
              c:type="TP_IFACE_CHANNEL_TYPE_CALL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CONTACT_LIST"
              value="org.freedesktop.Telepathy.Channel.Type.ContactList"
              c:type="TP_IFACE_CHANNEL_TYPE_CONTACT_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CONTACT_SEARCH"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch"
              c:type="TP_IFACE_CHANNEL_TYPE_CONTACT_SEARCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_DBUS_TUBE"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube"
              c:type="TP_IFACE_CHANNEL_TYPE_DBUS_TUBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_FILE_TRANSFER"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer"
              c:type="TP_IFACE_CHANNEL_TYPE_FILE_TRANSFER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_ROOM_LIST"
              value="org.freedesktop.Telepathy.Channel.Type.RoomList"
              c:type="TP_IFACE_CHANNEL_TYPE_ROOM_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_SERVER_AUTHENTICATION"
              value="org.freedesktop.Telepathy.Channel.Type.ServerAuthentication"
              c:type="TP_IFACE_CHANNEL_TYPE_SERVER_AUTHENTICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_SERVER_TLS_CONNECTION"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection"
              c:type="TP_IFACE_CHANNEL_TYPE_SERVER_TLS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_STREAMED_MEDIA"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia"
              c:type="TP_IFACE_CHANNEL_TYPE_STREAMED_MEDIA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_STREAM_TUBE"
              value="org.freedesktop.Telepathy.Channel.Type.StreamTube"
              c:type="TP_IFACE_CHANNEL_TYPE_STREAM_TUBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_TEXT"
              value="org.freedesktop.Telepathy.Channel.Type.Text"
              c:type="TP_IFACE_CHANNEL_TYPE_TEXT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_TUBES"
              value="org.freedesktop.Telepathy.Channel.Type.Tubes"
              c:type="TP_IFACE_CHANNEL_TYPE_TUBES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT"
              value="org.freedesktop.Telepathy.Client"
              c:type="TP_IFACE_CLIENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_APPROVER"
              value="org.freedesktop.Telepathy.Client.Approver"
              c:type="TP_IFACE_CLIENT_APPROVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_HANDLER"
              value="org.freedesktop.Telepathy.Client.Handler"
              c:type="TP_IFACE_CLIENT_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_INTERFACE_REQUESTS"
              value="org.freedesktop.Telepathy.Client.Interface.Requests"
              c:type="TP_IFACE_CLIENT_INTERFACE_REQUESTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_OBSERVER"
              value="org.freedesktop.Telepathy.Client.Observer"
              c:type="TP_IFACE_CLIENT_OBSERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION"
              value="org.freedesktop.Telepathy.Connection"
              c:type="TP_IFACE_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ADDRESSING"
              value="org.freedesktop.Telepathy.Connection.Interface.Addressing1"
              c:type="TP_IFACE_CONNECTION_INTERFACE_ADDRESSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ALIASING"
              value="org.freedesktop.Telepathy.Connection.Interface.Aliasing"
              c:type="TP_IFACE_CONNECTION_INTERFACE_ALIASING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ANONYMITY"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity"
              c:type="TP_IFACE_CONNECTION_INTERFACE_ANONYMITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_AVATARS"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars"
              c:type="TP_IFACE_CONNECTION_INTERFACE_AVATARS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_BALANCE"
              value="org.freedesktop.Telepathy.Connection.Interface.Balance"
              c:type="TP_IFACE_CONNECTION_INTERFACE_BALANCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.Capabilities"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CELLULAR"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CELLULAR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CLIENT_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.ClientTypes"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CLIENT_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACTS"
              value="org.freedesktop.Telepathy.Connection.Interface.Contacts"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_BLOCKING"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactBlocking"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_BLOCKING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_INFO"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_LIST"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_LOCATION"
              value="org.freedesktop.Telepathy.Connection.Interface.Location"
              c:type="TP_IFACE_CONNECTION_INTERFACE_LOCATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_MAIL_NOTIFICATION"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification"
              c:type="TP_IFACE_CONNECTION_INTERFACE_MAIL_NOTIFICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_POWER_SAVING"
              value="org.freedesktop.Telepathy.Connection.Interface.PowerSaving"
              c:type="TP_IFACE_CONNECTION_INTERFACE_POWER_SAVING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_PRESENCE"
              value="org.freedesktop.Telepathy.Connection.Interface.Presence"
              c:type="TP_IFACE_CONNECTION_INTERFACE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_REQUESTS"
              value="org.freedesktop.Telepathy.Connection.Interface.Requests"
              c:type="TP_IFACE_CONNECTION_INTERFACE_REQUESTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Connection.Interface.ServicePoint"
              c:type="TP_IFACE_CONNECTION_INTERFACE_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence"
              c:type="TP_IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_MANAGER"
              value="org.freedesktop.Telepathy.ConnectionManager"
              c:type="TP_IFACE_CONNECTION_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_DAEMON"
              value="org.freedesktop.DBus"
              c:type="TP_IFACE_DBUS_DAEMON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_INTROSPECTABLE"
              value="org.freedesktop.DBus.Introspectable"
              c:type="TP_IFACE_DBUS_INTROSPECTABLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_PEER"
              value="org.freedesktop.DBus.Peer"
              c:type="TP_IFACE_DBUS_PEER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_PROPERTIES"
              value="org.freedesktop.DBus.Properties"
              c:type="TP_IFACE_DBUS_PROPERTIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DEBUG"
              value="org.freedesktop.Telepathy.Debug"
              c:type="TP_IFACE_DEBUG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_MEDIA_SESSION_HANDLER"
              value="org.freedesktop.Telepathy.Media.SessionHandler"
              c:type="TP_IFACE_MEDIA_SESSION_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_MEDIA_STREAM_HANDLER"
              value="org.freedesktop.Telepathy.Media.StreamHandler"
              c:type="TP_IFACE_MEDIA_STREAM_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROPERTIES_INTERFACE"
              value="org.freedesktop.Telepathy.Properties"
              c:type="TP_IFACE_PROPERTIES_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL"
              value="org.freedesktop.Telepathy.Protocol"
              c:type="TP_IFACE_PROTOCOL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL_INTERFACE_ADDRESSING"
              value="org.freedesktop.Telepathy.Protocol.Interface.Addressing"
              c:type="TP_IFACE_PROTOCOL_INTERFACE_ADDRESSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL_INTERFACE_AVATARS"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars"
              c:type="TP_IFACE_PROTOCOL_INTERFACE_AVATARS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL_INTERFACE_PRESENCE"
              value="org.freedesktop.Telepathy.Protocol.Interface.Presence"
              c:type="TP_IFACE_PROTOCOL_INTERFACE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <callback name="IntFunc" c:type="TpIntFunc">
      <doc xml:whitespace="preserve">A callback function acting on unsigned integers.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="i" transfer-ownership="none">
          <doc xml:whitespace="preserve">The relevant integer</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">Opaque user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Intset"
            c:type="TpIntset"
            glib:type-name="TpIntset"
            glib:get-type="tp_intset_get_type"
            c:symbol-prefix="intset">
      <doc xml:whitespace="preserve">Opaque type representing a set of unsigned integers.

Before 0.11.16, this type was called &lt;type&gt;TpIntSet&lt;/type&gt;, which is
now a backwards compatibility typedef.</doc>
      <constructor name="new" c:identifier="tp_intset_new">
        <doc xml:whitespace="preserve">Allocate a new integer set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new, empty integer set to be destroyed with tp_intset_destroy()</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </constructor>
      <constructor name="new_containing"
                   c:identifier="tp_intset_new_containing"
                   version="0.7.26">
        <doc xml:whitespace="preserve">Allocate a new integer set containing the given integer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new integer set containing @element, to be destroyed with tp_intset_destroy()</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to add to a new set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="sized_new" c:identifier="tp_intset_sized_new">
        <doc xml:whitespace="preserve">Allocate a new integer set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new, empty integer set to be destroyed with tp_intset_destroy()</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">ignored (it was previously 1 more than the largest integer you expect to store)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="tp_intset_add">
        <doc xml:whitespace="preserve">Add an integer into a TpIntset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to add</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="tp_intset_clear">
        <doc xml:whitespace="preserve">Unset every integer in the set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="copy" c:identifier="tp_intset_copy">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A set containing the same integers as @orig, to be freed with tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </method>
      <method name="destroy" c:identifier="tp_intset_destroy">
        <doc xml:whitespace="preserve">Free all memory used by the set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="difference" c:identifier="tp_intset_difference">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in @left and not in @right (analogous to the bitwise operation left &amp; (~right)), to be freed with tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="difference_update"
              c:identifier="tp_intset_difference_update"
              version="0.13.10">
        <doc xml:whitespace="preserve">Remove each integer in @other from @self, analogous to the bitwise
operation self &amp;= (~other).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">members to remove</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="tp_intset_dump">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string which the caller must free with g_free, listing the numbers in @set in a human-readable format</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="foreach" c:identifier="tp_intset_foreach">
        <doc xml:whitespace="preserve">Call @func(element, @userdata) for each element of @set, in order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">@TpIntFunc to use to iterate the set</doc>
            <type name="IntFunc" c:type="TpIntFunc"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to each call of @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersection" c:identifier="tp_intset_intersection">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in both @left and @right (analogous to the bitwise operation left &amp; right), to be freed with tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="tp_intset_is_empty"
              version="0.11.6">
        <doc xml:whitespace="preserve">Return the same thing as &lt;code&gt;(tp_intset_size (set) == 0)&lt;/code&gt;,
but calculated more efficiently.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @set is empty</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_equal" c:identifier="tp_intset_is_equal">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @left and @right contain the same bits</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of integers</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_member" c:identifier="tp_intset_is_member">
        <doc xml:whitespace="preserve">Tests if @element is a member of @set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @element is in @set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to test</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="tp_intset_remove">
        <doc xml:whitespace="preserve">Remove an integer from a TpIntset</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @element was previously in @set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to add</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="size" c:identifier="tp_intset_size">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of integers in @set</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="symmetric_difference"
              c:identifier="tp_intset_symmetric_difference">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in either @left or @right but not both (analogous to the bitwise operation left ^ right), to be freed with tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_array" c:identifier="tp_intset_to_array">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a GArray of guint (which must be freed by the caller) containing the same integers as @set.</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="guint"/>
          </array>
        </return-value>
      </method>
      <method name="union" c:identifier="tp_intset_union">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in either @left or @right (analogous to the bitwise operation left | right), to be freed with tp_intset_destroy() by the caller</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="union_update"
              c:identifier="tp_intset_union_update"
              version="0.13.10">
        <doc xml:whitespace="preserve">Add each integer in @other to @self, analogous to the bitwise operation
self |= other.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">members to add</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <function name="from_array" c:identifier="tp_intset_from_array">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A set containing the same integers as @array.</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of guint</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="guint"/>
            </array>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="IntsetFastIter" c:type="TpIntsetFastIter" version="0.11.6">
      <doc xml:whitespace="preserve">An opaque structure representing iteration in undefined order over a set of
integers. Must be initialized with tp_intset_fast_iter_init().

Before 0.11.16, this type was called &lt;type&gt;TpIntSetFastIter&lt;/type&gt;,
which is now a backwards compatibility typedef.

Usage is similar to #GHashTableIter:

&lt;informalexample&gt;&lt;programlisting&gt;
TpIntsetFastIter iter;
guint element;

tp_intset_fast_iter_init (&amp;amp;iter, intset);

while (tp_intset_fast_iter_next (&amp;amp;iter, &amp;amp;element))
{
  printf ("%u is in the intset\n", element);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <field name="_dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="16">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="init"
              c:identifier="tp_intset_fast_iter_init"
              version="0.11.6">
        <doc xml:whitespace="preserve">Initialize @iter to iterate over @set in arbitrary order. @iter will become
invalid if @set is modified.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="set" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next"
              c:identifier="tp_intset_fast_iter_next"
              version="0.11.6">
        <doc xml:whitespace="preserve">Advances @iter and retrieves the integer it now points to. Iteration
is not necessarily in numerical order.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE if the end of the set has been reached</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="output" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store a new integer, in arbitrary order</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="IntsetIter"
            c:type="TpIntsetIter"
            deprecated="since 0.19.0. Use #TpIntsetFastIter instead">
      <doc xml:whitespace="preserve">A structure representing iteration over a set of integers. Must be
initialized with either TP_INTSET_ITER_INIT() or tp_intset_iter_init().

Since 0.11.6, consider using #TpIntsetFastIter if iteration in
numerical order is not required.

Before 0.11.16, this type was called &lt;type&gt;TpIntSetIter&lt;/type&gt;,
which is now a backwards compatibility typedef.</doc>
      <field name="set" writable="1">
        <type name="Intset" c:type="const TpIntset*"/>
      </field>
      <field name="element" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="init"
              c:identifier="tp_intset_iter_init"
              deprecated="since 0.19.0. Use #TpIntsetFastIter instead">
        <doc xml:whitespace="preserve">Reset the iterator @iter to the beginning and make it iterate over @set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="set" transfer-ownership="none">
            <doc xml:whitespace="preserve">An integer set to be used by that iterator</doc>
            <type name="Intset" c:type="const TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="tp_intset_iter_next">
        <doc xml:whitespace="preserve">If there are integers in (@iter-&gt;set) higher than (@iter-&gt;element), set
(iter-&gt;element) to the next one and return %TRUE. Otherwise return %FALSE.

Usage:

&lt;informalexample&gt;&lt;programlisting&gt;
TpIntsetIter iter = TP_INTSET_INIT (intset);
while (tp_intset_iter_next (&amp;amp;iter))
{
  printf ("%u is in the intset\n", iter.element);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

Since 0.11.6, consider using #TpIntsetFastIter if iteration in
numerical order is not required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if (@iter-&gt;element) has been advanced</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="reset"
              c:identifier="tp_intset_iter_reset"
              deprecated="since 0.19.0. Use #TpIntsetFastIter instead">
        <doc xml:whitespace="preserve">Reset the iterator @iter to the beginning. It must already be associated
with a set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="LocalHoldState" c:type="TpLocalHoldState">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The hold state of a channel.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unheld"
              value="0"
              c:identifier="TP_LOCAL_HOLD_STATE_UNHELD"/>
      <member name="held" value="1" c:identifier="TP_LOCAL_HOLD_STATE_HELD"/>
      <member name="pending_hold"
              value="2"
              c:identifier="TP_LOCAL_HOLD_STATE_PENDING_HOLD"/>
      <member name="pending_unhold"
              value="3"
              c:identifier="TP_LOCAL_HOLD_STATE_PENDING_UNHOLD"/>
    </enumeration>
    <enumeration name="LocalHoldStateReason" c:type="TpLocalHoldStateReason">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The reason for a change to the Local_Hold_State. Clients MUST         treat unknown values as equivalent to Local_Hold_State_Reason_None.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_LOCAL_HOLD_STATE_REASON_NONE"/>
      <member name="requested"
              value="1"
              c:identifier="TP_LOCAL_HOLD_STATE_REASON_REQUESTED"/>
      <member name="resource_not_available"
              value="2"
              c:identifier="TP_LOCAL_HOLD_STATE_REASON_RESOURCE_NOT_AVAILABLE"/>
    </enumeration>
    <bitfield name="LocationFeatures" c:type="TpLocationFeatures">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Flags describing the Location features which may be supported on any         given connection.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="location_feature_can_set"
              value="1"
              c:identifier="TP_LOCATION_FEATURE_CAN_SET"/>
    </bitfield>
    <bitfield name="MailNotificationFlags" c:type="TpMailNotificationFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Flags representing capabilities provided by a connection manager.           Those values can be used as bitfield. Some flags depend on, or           conflict with, each other.          Connections SHOULD implement as many of these features as the           underlying protocol allows, preferring to implement           Supports_Unread_Mails instead of Emits_Mails_Received if both are           possible.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="supports_unread_mail_count"
              value="1"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_UNREAD_MAIL_COUNT"/>
      <member name="supports_unread_mails"
              value="2"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_UNREAD_MAILS"/>
      <member name="emits_mails_received"
              value="4"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_EMITS_MAILS_RECEIVED"/>
      <member name="supports_request_inbox_url"
              value="8"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_REQUEST_INBOX_URL"/>
      <member name="supports_request_mail_url"
              value="16"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_REQUEST_MAIL_URL"/>
      <member name="thread_based"
              value="32"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_THREAD_BASED"/>
    </bitfield>
    <enumeration name="MediaStreamBaseProto" c:type="TpMediaStreamBaseProto">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="udp"
              value="0"
              c:identifier="TP_MEDIA_STREAM_BASE_PROTO_UDP"/>
      <member name="tcp"
              value="1"
              c:identifier="TP_MEDIA_STREAM_BASE_PROTO_TCP"/>
    </enumeration>
    <enumeration name="MediaStreamDirection" c:type="TpMediaStreamDirection">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none"
              value="0"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_NONE"/>
      <member name="send"
              value="1"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_SEND"/>
      <member name="receive"
              value="2"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_RECEIVE"/>
      <member name="bidirectional"
              value="3"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_BIDIRECTIONAL"/>
    </enumeration>
    <enumeration name="MediaStreamError" c:type="TpMediaStreamError">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_MEDIA_STREAM_ERROR_UNKNOWN"/>
      <member name="eos" value="1" c:identifier="TP_MEDIA_STREAM_ERROR_EOS"/>
      <member name="codec_negotiation_failed"
              value="2"
              c:identifier="TP_MEDIA_STREAM_ERROR_CODEC_NEGOTIATION_FAILED"/>
      <member name="connection_failed"
              value="3"
              c:identifier="TP_MEDIA_STREAM_ERROR_CONNECTION_FAILED"/>
      <member name="network_error"
              value="4"
              c:identifier="TP_MEDIA_STREAM_ERROR_NETWORK_ERROR"/>
      <member name="no_codecs"
              value="5"
              c:identifier="TP_MEDIA_STREAM_ERROR_NO_CODECS"/>
      <member name="invalid_cm_behavior"
              value="6"
              c:identifier="TP_MEDIA_STREAM_ERROR_INVALID_CM_BEHAVIOR"/>
      <member name="media_error"
              value="7"
              c:identifier="TP_MEDIA_STREAM_ERROR_MEDIA_ERROR"/>
    </enumeration>
    <bitfield name="MediaStreamPendingSend" c:type="TpMediaStreamPendingSend">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local_send"
              value="1"
              c:identifier="TP_MEDIA_STREAM_PENDING_LOCAL_SEND"/>
      <member name="remote_send"
              value="2"
              c:identifier="TP_MEDIA_STREAM_PENDING_REMOTE_SEND"/>
    </bitfield>
    <enumeration name="MediaStreamState" c:type="TpMediaStreamState">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="disconnected"
              value="0"
              c:identifier="TP_MEDIA_STREAM_STATE_DISCONNECTED"/>
      <member name="connecting"
              value="1"
              c:identifier="TP_MEDIA_STREAM_STATE_CONNECTING"/>
      <member name="connected"
              value="2"
              c:identifier="TP_MEDIA_STREAM_STATE_CONNECTED"/>
    </enumeration>
    <enumeration name="MediaStreamTransportType"
                 c:type="TpMediaStreamTransportType">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local"
              value="0"
              c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_LOCAL"/>
      <member name="derived"
              value="1"
              c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_DERIVED"/>
      <member name="relay"
              value="2"
              c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_RELAY"/>
    </enumeration>
    <enumeration name="MediaStreamType" c:type="TpMediaStreamType">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="audio"
              value="0"
              c:identifier="TP_MEDIA_STREAM_TYPE_AUDIO"/>
      <member name="video"
              value="1"
              c:identifier="TP_MEDIA_STREAM_TYPE_VIDEO"/>
    </enumeration>
    <class name="Message"
           c:symbol-prefix="message"
           c:type="TpMessage"
           parent="GObject.Object"
           glib:type-name="TpMessage"
           glib:get-type="tp_message_get_type"
           glib:type-struct="MessageClass">
      <doc xml:whitespace="preserve">Opaque structure representing a message in the Telepathy messages interface
(an array of at least one mapping from string to variant, where the first
mapping contains message headers and subsequent mappings contain the
message body).

This base class provides convenience API for most of the common keys that
can appear in the header. One notable exception is the sender of the
message. Inside a connection manager, messages are represented by the
#TpCMMessage subclass, and you should use tp_cm_message_get_sender().
When composing a message in a client using #TpClientMessage, messages do
not have an explicit sender (the sender is automatically the local user).
When a client sees a sent or received message signalled by the connection
manager (represented by #TpSignalledMessage), the message's sender (if any)
can be accessed with tp_signalled_message_get_sender().</doc>
      <method name="append_part"
              c:identifier="tp_message_append_part"
              version="0.7.21">
        <doc xml:whitespace="preserve">Append a body part to the message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the part number</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="count_parts"
              c:identifier="tp_message_count_parts"
              version="0.7.21">
        <doc xml:whitespace="preserve">&lt;!-- nothing more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of parts in the message, including the headers in part 0</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="delete_key"
              c:identifier="tp_message_delete_key"
              version="0.7.21">
        <doc xml:whitespace="preserve">Remove the given key and its value from the given part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the key previously existed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_part"
              c:identifier="tp_message_delete_part"
              version="0.7.21">
        <doc xml:whitespace="preserve">Delete the given body part from the message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly greater than 0, and strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="tp_message_destroy"
              version="0.7.21">
        <doc xml:whitespace="preserve">Since 0.13.9 this function is a simple wrapper around
g_object_unref()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="dup_part"
              c:identifier="tp_message_dup_part"
              version="0.19.10">
        <doc xml:whitespace="preserve">&lt;!-- nothing more to say --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current contents of the given part, or %NULL if the part number is out of range</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_type"
              c:identifier="tp_message_get_message_type"
              version="0.13.10">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of this message</doc>
          <type name="ChannelTextMessageType"
                c:type="TpChannelTextMessageType"/>
        </return-value>
      </method>
      <method name="get_pending_message_id"
              c:identifier="tp_message_get_pending_message_id"
              version="0.15.3">
        <doc xml:whitespace="preserve">Return the incoming message ID of @self. Only incoming messages have such
ID, for outgoing ones this function returns 0 and set @valid to %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the incoming message ID.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <parameter name="valid"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">either %NULL, or a location in which to store %TRUE if @self contains a pending message ID.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_received_timestamp"
              c:identifier="tp_message_get_received_timestamp"
              version="0.13.9">
        <doc xml:whitespace="preserve">Return when this message was received locally, as a number of seconds since
the beginning of 1970 in the UTC timezone (the same representation used by
g_date_time_new_from_unix_utc(), for instance), or 0 if not known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a Unix timestamp, or 0</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_sent_timestamp"
              c:identifier="tp_message_get_sent_timestamp"
              version="0.13.9">
        <doc xml:whitespace="preserve">Return when this message was sent, as a number of seconds since the
beginning of 1970 in the UTC timezone (the same representation used by
g_date_time_new_from_unix_utc(), for instance), or 0 if not known.

If this protocol does not track the time at which the message was
initially sent, this timestamp might be approximated by using the
time at which it arrived at a central server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a Unix timestamp, or 0</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_specific_to_interface"
              c:identifier="tp_message_get_specific_to_interface"
              version="0.13.9">
        <doc xml:whitespace="preserve">If this message is specific to a particular D-Bus interface and should
be ignored by clients without knowledge of that interface, return the
name of the interface.

If this message is an ordinary message or delivery report, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus interface name, or %NULL for ordinary messages and delivery reports</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_supersedes"
              c:identifier="tp_message_get_supersedes"
              version="0.13.9">
        <doc xml:whitespace="preserve">If this message replaces a previous message, return the value of
tp_message_get_token() for that previous message. Otherwise, return %NULL.

For instance, a user interface could replace the superseded
message with this message, or grey out the superseded message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-empty opaque identifier, or %NULL if none</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_token"
              c:identifier="tp_message_get_token"
              version="0.13.9">
        <doc xml:whitespace="preserve">Return this message's identifier in the underlying protocol. This is
&lt;emphasis&gt;not&lt;/emphasis&gt; guaranteed to be unique, even within the scope
of a single channel or contact: the only guarantee made is that two
messages with different non-empty tokens are different messages.

If there is no suitable token, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-empty opaque identifier, or %NULL if none</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="is_delivery_report"
              c:identifier="tp_message_is_delivery_report"
              version="0.13.9">
        <doc xml:whitespace="preserve">If this message is a delivery report indicating success or failure of
delivering a message, return %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this is a delivery report</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_mutable"
              c:identifier="tp_message_is_mutable"
              version="0.13.9">
        <doc xml:whitespace="preserve">Check if @self is mutable. Only mutable messages can be modified using
functions such as tp_message_set_string().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message is mutable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_rescued"
              c:identifier="tp_message_is_rescued"
              version="0.13.9">
        <doc xml:whitespace="preserve">Returns %TRUE if this incoming message has been seen in a previous channel
during the lifetime of the Connection, but had not been acknowledged when
that channel closed, causing an identical channel (in which the message now
appears) to open.

Loggers should check this flag to avoid duplicating messages, for instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this message was seen in a previous Channel on this Connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_scrollback"
              c:identifier="tp_message_is_scrollback"
              version="0.13.9">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this message is part of a replay of message history, for instance in an XMPP chatroom.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="peek" c:identifier="tp_message_peek" version="0.7.21">
        <doc xml:whitespace="preserve">&lt;!-- nothing more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GHashTable used to implement the given part, or %NULL if the part number is out of range. The hash table is only valid as long as the message is valid and the part is not deleted.</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref_handle"
              c:identifier="tp_message_ref_handle"
              version="0.7.21"
              deprecated="since 0.13.9. Handles are now immortal so there is no point to ref them. Furthermore, the only handle that should be stored in a TpMessage is message-sender which should be set using tp_cm_message_set_sender().">
        <doc xml:whitespace="preserve">Reference the given handle until this message is destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle type, greater than %TP_HANDLE_TYPE_NONE and less than %TP_NUM_HANDLE_TYPES</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle of the given type</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="tp_message_set" version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have a copy of @source as its value.

If @source represents a data structure containing handles, they should
all be referenced with tp_message_ref_handle() first.

In high-level language bindings, use tp_message_set_variant() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a value, encoded as dbus-glib would</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean"
              c:identifier="tp_message_set_boolean"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @b as a boolean value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">a boolean value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_bytes"
              c:identifier="tp_message_set_bytes"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @bytes as a byte-array value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">a number of bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of @len bytes</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handle"
              c:identifier="tp_message_set_handle"
              version="0.7.21"
              deprecated="since 0.13.9. Use tp_cm_message_set_sender()">
        <doc xml:whitespace="preserve">If @handle_or_0 is not zero, reference it with tp_message_ref_handle().

Set @key in part @part of @self to have @handle_or_0 as an unsigned integer
value.

Since 0.13.9 this function has been deprecated in favor or
tp_cm_message_set_sender() as 'message-sender' is the only handle
you can put in a #TpCMMessage.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="handle_or_0" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle of that type, or 0</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int32"
              c:identifier="tp_message_set_int32"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @i as a signed integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer value</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int64"
              c:identifier="tp_message_set_int64"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @i as a signed integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string"
              c:identifier="tp_message_set_string"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @s as a string value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="s" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string_printf"
              c:identifier="tp_message_set_string_printf"
              version="0.7.21"
              introspectable="0">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have a string value constructed from a
printf-style format string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fmt" transfer-ownership="none">
            <doc xml:whitespace="preserve">a printf-style format string for the string value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint32"
              c:identifier="tp_message_set_uint32"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @u as an unsigned integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="u" transfer-ownership="none">
            <doc xml:whitespace="preserve">an unsigned integer value</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint64"
              c:identifier="tp_message_set_uint64"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @u as an unsigned integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="u" transfer-ownership="none">
            <doc xml:whitespace="preserve">an unsigned integer value</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_variant"
              c:identifier="tp_message_set_variant"
              version="0.19.10">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @value as its value.

If @value is a floating reference (see g_variant_ref_sink()), then this
function will take ownership of it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_message"
              c:identifier="tp_message_take_message"
              version="0.7.21"
              deprecated="since 0.13.9. Use tp_cm_message_take_message()">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @message as an aa{sv} value (that
is, an array of Message_Part), and take ownership of @message.  The caller
should not use @message after passing it to this function.  All handle
references owned by @message will subsequently belong to and be released
with @self.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">another (distinct) message created for the same #TpBaseConnection</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_text"
              c:identifier="tp_message_to_text"
              version="0.13.9">
        <doc xml:whitespace="preserve">Concatene all the text parts contained in @message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated string containing the text content of #message</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="out_flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, the #TpChannelTextMessageFlags of @message</doc>
            <type name="ChannelTextMessageFlags"
                  c:type="TpChannelTextMessageFlags*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="MessageClass"
            c:type="TpMessageClass"
            disguised="1"
            glib:is-gtype-struct-for="Message">
    </record>
    <bitfield name="MessagePartSupportFlags"
              c:type="TpMessagePartSupportFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Flags indicating the level of support for message parts on this           channel. They are designed such that setting more flags always           implies that the channel has more capabilities.          If no flags are set, this indicates that messages may contain           a single message part whose content-type is any of the types           from SupportedContentTypes, possibly with some alternatives.          There is no flag indicating support for alternatives. This is           because the SendMessage implementation can always accept messages           containing alternatives, even if the underlying protocol does not,           by deleting all alternatives except the first (most preferred)           that is supported.                     Each of the flags so far implies the previous flag, so we could           have used a simple enumeration here; however, we've defined           the message-part support indicator as a flag set for future           expansion.                   See SupportedContentTypes for some           examples.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="one_attachment"
              value="1"
              c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_ONE_ATTACHMENT"/>
      <member name="multiple_attachments"
              value="2"
              c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_MULTIPLE_ATTACHMENTS"/>
    </bitfield>
    <bitfield name="MessageSendingFlags" c:type="TpMessageSendingFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Flags altering the way a message is sent. The "most usual" action         should always be to have these flags unset. Some indication of which         flags are supported is provided by the         DeliveryReportingSupport property.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="delivery"
              value="1"
              c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_DELIVERY"/>
      <member name="read"
              value="2"
              c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_READ"/>
      <member name="deleted"
              value="4"
              c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_DELETED"/>
    </bitfield>
    <constant name="NUM_ACCESS_CONTROL_TYPES"
              value="7"
              c:type="TP_NUM_ACCESS_CONTROL_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_CONTENT_DISPOSITIONS"
              value="2"
              c:type="TP_NUM_CALL_CONTENT_DISPOSITIONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_CONTENT_PACKETIZATION_TYPES"
              value="3"
              c:type="TP_NUM_CALL_CONTENT_PACKETIZATION_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_STATES" value="7" c:type="TP_NUM_CALL_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_STATE_CHANGE_REASONS"
              value="14"
              c:type="TP_NUM_CALL_STATE_CHANGE_REASONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CALL_STREAM_CANDIDATE_TYPES"
              value="6"
              c:type="TP_NUM_CALL_STREAM_CANDIDATE_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CAPTCHA_CANCEL_REASONS"
              value="3"
              c:type="TP_NUM_CAPTCHA_CANCEL_REASONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CAPTCHA_STATUSES"
              value="5"
              c:type="TP_NUM_CAPTCHA_STATUSES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_CHAT_STATES"
              value="5"
              c:type="TP_NUM_CHANNEL_CHAT_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_CONTACT_SEARCH_STATES"
              value="5"
              c:type="TP_NUM_CHANNEL_CONTACT_SEARCH_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_GROUP_CHANGE_REASONS"
              value="12"
              c:type="TP_NUM_CHANNEL_GROUP_CHANGE_REASONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_TEXT_MESSAGE_TYPES"
              value="5"
              c:type="TP_NUM_CHANNEL_TEXT_MESSAGE_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CHANNEL_TEXT_SEND_ERRORS"
              value="6"
              c:type="TP_NUM_CHANNEL_TEXT_SEND_ERRORS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONNECTION_PRESENCE_TYPES"
              value="9"
              c:type="TP_NUM_CONNECTION_PRESENCE_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONNECTION_STATUSES"
              value="3"
              c:type="TP_NUM_CONNECTION_STATUSES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONNECTION_STATUS_REASONS"
              value="17"
              c:type="TP_NUM_CONNECTION_STATUS_REASONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONTACT_FEATURES"
              value="1"
              c:type="TP_NUM_CONTACT_FEATURES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONTACT_LIST_STATES"
              value="4"
              c:type="TP_NUM_CONTACT_LIST_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_CONTACT_METADATA_STORAGE_TYPES"
              value="4"
              c:type="TP_NUM_CONTACT_METADATA_STORAGE_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_DBUS_ERRORS" value="1" c:type="TP_NUM_DBUS_ERRORS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_DEBUG_LEVELS" value="6" c:type="TP_NUM_DEBUG_LEVELS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_DELIVERY_STATUSES"
              value="7"
              c:type="TP_NUM_DELIVERY_STATUSES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_DTMF_EVENTS" value="16" c:type="TP_NUM_DTMF_EVENTS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_FILE_HASH_TYPES"
              value="4"
              c:type="TP_NUM_FILE_HASH_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_FILE_TRANSFER_STATES"
              value="6"
              c:type="TP_NUM_FILE_TRANSFER_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_FILE_TRANSFER_STATE_CHANGE_REASONS"
              value="6"
              c:type="TP_NUM_FILE_TRANSFER_STATE_CHANGE_REASONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_HANDLE_TYPES" value="5" c:type="TP_NUM_HANDLE_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_HTTP_METHODS" value="2" c:type="TP_NUM_HTTP_METHODS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_LOCAL_HOLD_STATES"
              value="4"
              c:type="TP_NUM_LOCAL_HOLD_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_LOCAL_HOLD_STATE_REASONS"
              value="3"
              c:type="TP_NUM_LOCAL_HOLD_STATE_REASONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_BASE_PROTOS"
              value="2"
              c:type="TP_NUM_MEDIA_STREAM_BASE_PROTOS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_DIRECTIONS"
              value="4"
              c:type="TP_NUM_MEDIA_STREAM_DIRECTIONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_ERRORS"
              value="8"
              c:type="TP_NUM_MEDIA_STREAM_ERRORS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_STATES"
              value="3"
              c:type="TP_NUM_MEDIA_STREAM_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_TRANSPORT_TYPES"
              value="3"
              c:type="TP_NUM_MEDIA_STREAM_TRANSPORT_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_MEDIA_STREAM_TYPES"
              value="2"
              c:type="TP_NUM_MEDIA_STREAM_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_RCPT_XR_RTT_MODES"
              value="2"
              c:type="TP_NUM_RCPT_XR_RTT_MODES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_RICH_PRESENCE_ACCESS_CONTROL_TYPES"
              value="4"
              c:type="TP_NUM_RICH_PRESENCE_ACCESS_CONTROL_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SASL_ABORT_REASONS"
              value="2"
              c:type="TP_NUM_SASL_ABORT_REASONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SASL_STATUSES" value="7" c:type="TP_NUM_SASL_STATUSES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SENDING_STATES"
              value="4"
              c:type="TP_NUM_SENDING_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SERVICE_POINT_TYPES"
              value="3"
              c:type="TP_NUM_SERVICE_POINT_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SOCKET_ACCESS_CONTROLS"
              value="4"
              c:type="TP_NUM_SOCKET_ACCESS_CONTROLS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SOCKET_ADDRESS_TYPES"
              value="4"
              c:type="TP_NUM_SOCKET_ADDRESS_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_STREAM_COMPONENTS"
              value="3"
              c:type="TP_NUM_STREAM_COMPONENTS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_STREAM_ENDPOINT_STATES"
              value="5"
              c:type="TP_NUM_STREAM_ENDPOINT_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_STREAM_FLOW_STATES"
              value="4"
              c:type="TP_NUM_STREAM_FLOW_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_STREAM_TRANSPORT_TYPES"
              value="7"
              c:type="TP_NUM_STREAM_TRANSPORT_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_SUBSCRIPTION_STATES"
              value="5"
              c:type="TP_NUM_SUBSCRIPTION_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TLS_CERTIFICATE_REJECT_REASONS"
              value="10"
              c:type="TP_NUM_TLS_CERTIFICATE_REJECT_REASONS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TLS_CERTIFICATE_STATES"
              value="3"
              c:type="TP_NUM_TLS_CERTIFICATE_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TUBE_CHANNEL_STATES"
              value="4"
              c:type="TP_NUM_TUBE_CHANNEL_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TUBE_STATES" value="3" c:type="TP_NUM_TUBE_STATES">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NUM_TUBE_TYPES" value="2" c:type="TP_NUM_TUBE_TYPES">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="ObserveChannelsContext"
           c:symbol-prefix="observe_channels_context"
           c:type="TpObserveChannelsContext"
           version="0.11.5"
           parent="GObject.Object"
           glib:type-name="TpObserveChannelsContext"
           glib:get-type="tp_observe_channels_context_get_type"
           glib:type-struct="ObserveChannelsContextClass">
      <doc xml:whitespace="preserve">Data structure representing the context of a Observer.ObserveChannels()
call.</doc>
      <method name="accept"
              c:identifier="tp_observe_channels_context_accept"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassObserveChannelsImpl when it's done so the D-Bus
method can return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="delay"
              c:identifier="tp_observe_channels_context_delay"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassObserveChannelsImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpObserveChannelsContext before calling this function, and
is responsible for calling either tp_observe_channels_context_accept() or
tp_observe_channels_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fail"
              c:identifier="tp_observe_channels_context_fail"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassObserveChannelsImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_requests"
              c:identifier="tp_observe_channels_context_get_requests"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return a list of the #TpChannelRequest which have been satisfied by the
channels associated with #self.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GList of reffed #TpChannelRequest.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
      </method>
      <method name="is_recovering"
              c:identifier="tp_observe_channels_context_is_recovering"
              version="0.11.5">
        <doc xml:whitespace="preserve">If this call to ObserveChannels is for channels that already
existed before this observer started (because the observer used
tp_base_client_set_observer_recover()), return %TRUE.

In most cases, the result is %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for pre-existing channels, %FALSE for new channels</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="account"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAccount object representing the Account that has been passed to
ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channels"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection object representing the Connection that has been passed
to ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="dbus-context"
                version="0.11.5"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
ObserveChannels call.
Can only be written during construction.</doc>
        <type name="gpointer"/>
      </property>
      <property name="dispatch-operation"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpChannelDispatchOperation object representing the
ChannelDispatchOperation that has been passed to ObserveChannels,
or %NULL if none has been passed.
Read-only except during construction.</doc>
        <type name="ChannelDispatchOperation"/>
      </property>
      <property name="observer-info"
                version="0.11.5"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GHashTable where the keys are string and values are GValue instances.
It represents the Observer_Info hash table that has been passed to
ObserveChannels.
It's recommended to use high-level method such as
tp_observe_channels_context_is_recovering() to access to its content.

This property can't be %NULL.</doc>
        <type/>
      </property>
      <property name="requests"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannelRequest objects representing the
requests that have been passed to ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
    </class>
    <record name="ObserveChannelsContextClass"
            c:type="TpObserveChannelsContextClass"
            disguised="1"
            glib:is-gtype-struct-for="ObserveChannelsContext"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpObserveChannelsContext.</doc>
    </record>
    <record name="ObserveChannelsContextPrivate"
            c:type="TpObserveChannelsContextPrivate"
            disguised="1">
    </record>
    <constant name="PROP_ACCOUNT_AUTOMATIC_PRESENCE"
              value="org.freedesktop.Telepathy.Account.AutomaticPresence"
              c:type="TP_PROP_ACCOUNT_AUTOMATIC_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CHANGING_PRESENCE"
              value="org.freedesktop.Telepathy.Account.ChangingPresence"
              c:type="TP_PROP_ACCOUNT_CHANGING_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION"
              value="org.freedesktop.Telepathy.Account.Connection"
              c:type="TP_PROP_ACCOUNT_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_ERROR"
              value="org.freedesktop.Telepathy.Account.ConnectionError"
              c:type="TP_PROP_ACCOUNT_CONNECTION_ERROR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_ERROR_DETAILS"
              value="org.freedesktop.Telepathy.Account.ConnectionErrorDetails"
              c:type="TP_PROP_ACCOUNT_CONNECTION_ERROR_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_STATUS"
              value="org.freedesktop.Telepathy.Account.ConnectionStatus"
              c:type="TP_PROP_ACCOUNT_CONNECTION_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_STATUS_REASON"
              value="org.freedesktop.Telepathy.Account.ConnectionStatusReason"
              c:type="TP_PROP_ACCOUNT_CONNECTION_STATUS_REASON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECT_AUTOMATICALLY"
              value="org.freedesktop.Telepathy.Account.ConnectAutomatically"
              c:type="TP_PROP_ACCOUNT_CONNECT_AUTOMATICALLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CURRENT_PRESENCE"
              value="org.freedesktop.Telepathy.Account.CurrentPresence"
              c:type="TP_PROP_ACCOUNT_CURRENT_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_DISPLAY_NAME"
              value="org.freedesktop.Telepathy.Account.DisplayName"
              c:type="TP_PROP_ACCOUNT_DISPLAY_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_ENABLED"
              value="org.freedesktop.Telepathy.Account.Enabled"
              c:type="TP_PROP_ACCOUNT_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_HAS_BEEN_ONLINE"
              value="org.freedesktop.Telepathy.Account.HasBeenOnline"
              c:type="TP_PROP_ACCOUNT_HAS_BEEN_ONLINE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_ICON"
              value="org.freedesktop.Telepathy.Account.Icon"
              c:type="TP_PROP_ACCOUNT_ICON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACES"
              value="org.freedesktop.Telepathy.Account.Interfaces"
              c:type="TP_PROP_ACCOUNT_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_ADDRESSING_URI_SCHEMES"
              value="org.freedesktop.Telepathy.Account.Interface.Addressing.URISchemes"
              c:type="TP_PROP_ACCOUNT_INTERFACE_ADDRESSING_URI_SCHEMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_AVATAR_AVATAR"
              value="org.freedesktop.Telepathy.Account.Interface.Avatar.Avatar"
              c:type="TP_PROP_ACCOUNT_INTERFACE_AVATAR_AVATAR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_IDENTIFIER"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageIdentifier"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_IDENTIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_PROVIDER"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageProvider"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_PROVIDER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_RESTRICTIONS"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageRestrictions"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_RESTRICTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_SPECIFIC_INFORMATION"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageSpecificInformation"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_SPECIFIC_INFORMATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_INTERFACES"
              value="org.freedesktop.Telepathy.AccountManager.Interfaces"
              c:type="TP_PROP_ACCOUNT_MANAGER_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_INVALID_ACCOUNTS"
              value="org.freedesktop.Telepathy.AccountManager.InvalidAccounts"
              c:type="TP_PROP_ACCOUNT_MANAGER_INVALID_ACCOUNTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_SUPPORTED_ACCOUNT_PROPERTIES"
              value="org.freedesktop.Telepathy.AccountManager.SupportedAccountProperties"
              c:type="TP_PROP_ACCOUNT_MANAGER_SUPPORTED_ACCOUNT_PROPERTIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_VALID_ACCOUNTS"
              value="org.freedesktop.Telepathy.AccountManager.ValidAccounts"
              c:type="TP_PROP_ACCOUNT_MANAGER_VALID_ACCOUNTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_NICKNAME"
              value="org.freedesktop.Telepathy.Account.Nickname"
              c:type="TP_PROP_ACCOUNT_NICKNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_NORMALIZED_NAME"
              value="org.freedesktop.Telepathy.Account.NormalizedName"
              c:type="TP_PROP_ACCOUNT_NORMALIZED_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_PARAMETERS"
              value="org.freedesktop.Telepathy.Account.Parameters"
              c:type="TP_PROP_ACCOUNT_PARAMETERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_REQUESTED_PRESENCE"
              value="org.freedesktop.Telepathy.Account.RequestedPresence"
              c:type="TP_PROP_ACCOUNT_REQUESTED_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_SERVICE"
              value="org.freedesktop.Telepathy.Account.Service"
              c:type="TP_PROP_ACCOUNT_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_SUPERSEDES"
              value="org.freedesktop.Telepathy.Account.Supersedes"
              c:type="TP_PROP_ACCOUNT_SUPERSEDES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_VALID"
              value="org.freedesktop.Telepathy.Account.Valid"
              c:type="TP_PROP_ACCOUNT_VALID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_CHAIN_DATA"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.CertificateChainData"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_CHAIN_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_TYPE"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.CertificateType"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_REJECTIONS"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.Rejections"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_REJECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_STATE"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.State"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_DISPOSITION"
              value="org.freedesktop.Telepathy.Call1.Content.Disposition"
              c:type="TP_PROP_CALL_CONTENT_DISPOSITION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACES"
              value="org.freedesktop.Telepathy.Call1.Content.Interfaces"
              c:type="TP_PROP_CALL_CONTENT_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_INPUT_VOLUME"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.AudioControl.RequestedInputVolume"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_INPUT_VOLUME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_OUTPUT_VOLUME"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.AudioControl.RequestedOutputVolume"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_OUTPUT_VOLUME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_DTMF_CURRENTLY_SENDING_TONES"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.DTMF.CurrentlySendingTones"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_DTMF_CURRENTLY_SENDING_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_DTMF_DEFERRED_TONES"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.DTMF.DeferredTones"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_DTMF_DEFERRED_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_EVENT"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.CurrentDTMFEvent"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_EVENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_STATE"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.CurrentDTMFState"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_LOCAL_MEDIA_DESCRIPTIONS"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.LocalMediaDescriptions"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_LOCAL_MEDIA_DESCRIPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_MEDIA_DESCRIPTION_OFFER"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.MediaDescriptionOffer"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_MEDIA_DESCRIPTION_OFFER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_PACKETIZATION"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.Packetization"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_PACKETIZATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_MEDIA_REMOTE_MEDIA_DESCRIPTIONS"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.Media.RemoteMediaDescriptions"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_MEDIA_REMOTE_MEDIA_DESCRIPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_BITRATE"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.Bitrate"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_FRAMERATE"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.Framerate"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_FRAMERATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MANUAL_KEY_FRAMES"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.ManualKeyFrames"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MANUAL_KEY_FRAMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MTU"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.MTU"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_VIDEO_RESOLUTION"
              value="org.freedesktop.Telepathy.Call1.Content.Interface.VideoControl.VideoResolution"
              c:type="TP_PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_VIDEO_RESOLUTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_CODECS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Codecs"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_CODECS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_FURTHER_NEGOTIATION_REQUIRED"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.FurtherNegotiationRequired"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_FURTHER_NEGOTIATION_REQUIRED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_HAS_REMOTE_INFORMATION"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.HasRemoteInformation"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_HAS_REMOTE_INFORMATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACES"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interfaces"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DLRR_MAX_SIZE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.DLRRMaxSize"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DLRR_MAX_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DUPLICATE_RLE_MAX_SIZE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.DuplicateRLEMaxSize"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DUPLICATE_RLE_MAX_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_ENABLE_METRICS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.EnableMetrics"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_ENABLE_METRICS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_LOSS_RLE_MAX_SIZE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.LossRLEMaxSize"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_LOSS_RLE_MAX_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_PACKET_RECEIPT_TIMES_MAX_SIZE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.PacketReceiptTimesMaxSize"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_PACKET_RECEIPT_TIMES_MAX_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_RTT_MODE"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.RTTMode"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_RTT_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_STATISTICS_FLAGS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPExtendedReports.StatisticsFlags"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_STATISTICS_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_DOES_AVPF"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPFeedback.DoesAVPF"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_DOES_AVPF">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_FEEDBACK_MESSAGES"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTCPFeedback.FeedbackMessages"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_FEEDBACK_MESSAGES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS_HEADER_EXTENSIONS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.Interface.RTPHeaderExtensions.HeaderExtensions"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS_HEADER_EXTENSIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_REMOTE_CONTACT"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.RemoteContact"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_REMOTE_CONTACT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_MEDIA_DESCRIPTION_SSRCS"
              value="org.freedesktop.Telepathy.Call1.Content.MediaDescription.SSRCs"
              c:type="TP_PROP_CALL_CONTENT_MEDIA_DESCRIPTION_SSRCS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_NAME"
              value="org.freedesktop.Telepathy.Call1.Content.Name"
              c:type="TP_PROP_CALL_CONTENT_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_STREAMS"
              value="org.freedesktop.Telepathy.Call1.Content.Streams"
              c:type="TP_PROP_CALL_CONTENT_STREAMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_CONTENT_TYPE"
              value="org.freedesktop.Telepathy.Call1.Content.Type"
              c:type="TP_PROP_CALL_CONTENT_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_CAN_REQUEST_RECEIVING"
              value="org.freedesktop.Telepathy.Call1.Stream.CanRequestReceiving"
              c:type="TP_PROP_CALL_STREAM_CAN_REQUEST_RECEIVING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_CONTROLLING"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.Controlling"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_CONTROLLING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_ENDPOINT_STATE"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.EndpointState"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_ENDPOINT_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_IS_ICE_LITE"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.IsICELite"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_IS_ICE_LITE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_REMOTE_CANDIDATES"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.RemoteCandidates"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_REMOTE_CANDIDATES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_REMOTE_CREDENTIALS"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.RemoteCredentials"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_REMOTE_CREDENTIALS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_SELECTED_CANDIDATE_PAIRS"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.SelectedCandidatePairs"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_SELECTED_CANDIDATE_PAIRS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_ENDPOINT_TRANSPORT"
              value="org.freedesktop.Telepathy.Call1.Stream.Endpoint.Transport"
              c:type="TP_PROP_CALL_STREAM_ENDPOINT_TRANSPORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACES"
              value="org.freedesktop.Telepathy.Call1.Stream.Interfaces"
              c:type="TP_PROP_CALL_STREAM_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_ENDPOINTS"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.Endpoints"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_ENDPOINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_HAS_SERVER_INFO"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.HasServerInfo"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_HAS_SERVER_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_ICE_RESTART_PENDING"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.ICERestartPending"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_ICE_RESTART_PENDING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CANDIDATES"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.LocalCandidates"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CANDIDATES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CREDENTIALS"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.LocalCredentials"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CREDENTIALS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_RECEIVING_STATE"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.ReceivingState"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_RECEIVING_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_RELAY_INFO"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.RelayInfo"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_RELAY_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_SENDING_STATE"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.SendingState"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_SENDING_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_STUN_SERVERS"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.STUNServers"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_STUN_SERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_INTERFACE_MEDIA_TRANSPORT"
              value="org.freedesktop.Telepathy.Call1.Stream.Interface.Media.Transport"
              c:type="TP_PROP_CALL_STREAM_INTERFACE_MEDIA_TRANSPORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_LOCAL_SENDING_STATE"
              value="org.freedesktop.Telepathy.Call1.Stream.LocalSendingState"
              c:type="TP_PROP_CALL_STREAM_LOCAL_SENDING_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_REMOTE_MEMBERS"
              value="org.freedesktop.Telepathy.Call1.Stream.RemoteMembers"
              c:type="TP_PROP_CALL_STREAM_REMOTE_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CALL_STREAM_REMOTE_MEMBER_IDENTIFIERS"
              value="org.freedesktop.Telepathy.Call1.Stream.RemoteMemberIdentifiers"
              c:type="TP_PROP_CALL_STREAM_REMOTE_MEMBER_IDENTIFIERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_CHANNEL_TYPE"
              value="org.freedesktop.Telepathy.Channel.ChannelType"
              c:type="TP_PROP_CHANNEL_CHANNEL_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_INTERFACES"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interfaces"
              c:type="TP_PROP_CHANNEL_DISPATCHER_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST_DISPATCH_OPERATIONS"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interface.OperationList.DispatchOperations"
              c:type="TP_PROP_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST_DISPATCH_OPERATIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_SUPPORTS_REQUEST_HINTS"
              value="org.freedesktop.Telepathy.ChannelDispatcher.SupportsRequestHints"
              c:type="TP_PROP_CHANNEL_DISPATCHER_SUPPORTS_REQUEST_HINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_ACCOUNT"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Account"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_ACCOUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_CHANNELS"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Channels"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_CONNECTION"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Connection"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_INTERFACES"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Interfaces"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_POSSIBLE_HANDLERS"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.PossibleHandlers"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_POSSIBLE_HANDLERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INITIATOR_HANDLE"
              value="org.freedesktop.Telepathy.Channel.InitiatorHandle"
              c:type="TP_PROP_CHANNEL_INITIATOR_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INITIATOR_ID"
              value="org.freedesktop.Telepathy.Channel.InitiatorID"
              c:type="TP_PROP_CHANNEL_INITIATOR_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACES"
              value="org.freedesktop.Telepathy.Channel.Interfaces"
              c:type="TP_PROP_CHANNEL_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymityMandatory"
              c:type="TP_PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MODES"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymityModes"
              c:type="TP_PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MODES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMOUS_ID"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymousID"
              c:type="TP_PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMOUS_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAN_RETRY_CAPTCHA"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1.CanRetryCaptcha"
              c:type="TP_PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAN_RETRY_CAPTCHA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1.CaptchaError"
              c:type="TP_PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR_DETAILS"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1.CaptchaErrorDetails"
              c:type="TP_PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_STATUS"
              value="org.freedesktop.Telepathy.Channel.Interface.CaptchaAuthentication1.CaptchaStatus"
              c:type="TP_PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CHAT_STATE_CHAT_STATES"
              value="org.freedesktop.Telepathy.Channel.Interface.ChatState.ChatStates"
              c:type="TP_PROP_CHANNEL_INTERFACE_CHAT_STATE_CHAT_STATES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_CHANNELS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.Channels"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_CHANNELS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InitialChannels"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_HANDLES"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InitialInviteeHandles"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_HANDLES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_IDS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InitialInviteeIDs"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_IDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INVITATION_MESSAGE"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InvitationMessage"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INVITATION_MESSAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_ORIGINAL_CHANNELS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.OriginalChannels"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_ORIGINAL_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_CURRENTLY_SENDING_TONES"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF.CurrentlySendingTones"
              c:type="TP_PROP_CHANNEL_INTERFACE_DTMF_CURRENTLY_SENDING_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_DEFERRED_TONES"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF.DeferredTones"
              c:type="TP_PROP_CHANNEL_INTERFACE_DTMF_DEFERRED_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_INITIAL_TONES"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF.InitialTones"
              c:type="TP_PROP_CHANNEL_INTERFACE_DTMF_INITIAL_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA"
              value="org.freedesktop.Telepathy.Channel.Interface.FileTransfer.Metadata.Metadata"
              c:type="TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME"
              value="org.freedesktop.Telepathy.Channel.Interface.FileTransfer.Metadata.ServiceName"
              c:type="TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_GROUP_FLAGS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.GroupFlags"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_GROUP_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_HANDLE_OWNERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.HandleOwners"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_HANDLE_OWNERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_LOCAL_PENDING_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.LocalPendingMembers"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_LOCAL_PENDING_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.Members"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_MEMBER_IDENTIFIERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.MemberIdentifiers"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_MEMBER_IDENTIFIERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_REMOTE_PENDING_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.RemotePendingMembers"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_REMOTE_PENDING_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_SELF_HANDLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.SelfHandle"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_SELF_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_DELIVERY_REPORTING_SUPPORT"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.DeliveryReportingSupport"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_DELIVERY_REPORTING_SUPPORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_PART_SUPPORT_FLAGS"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.MessagePartSupportFlags"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_PART_SUPPORT_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_TYPES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.MessageTypes"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_PENDING_MESSAGES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.PendingMessages"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_PENDING_MESSAGES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_SUPPORTED_CONTENT_TYPES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.SupportedContentTypes"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_SUPPORTED_CONTENT_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_ANONYMOUS"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Anonymous"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_ANONYMOUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CAN_UPDATE_CONFIGURATION"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.CanUpdateConfiguration"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CAN_UPDATE_CONFIGURATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CONFIGURATION_RETRIEVED"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.ConfigurationRetrieved"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CONFIGURATION_RETRIEVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_DESCRIPTION"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Description"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_INVITEONLY"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.InviteOnly"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_INVITEONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_LIMIT"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Limit"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MODERATED"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Moderated"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MODERATED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MUTABLE_PROPERTIES"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.MutableProperties"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MUTABLE_PROPERTIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Password"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_HINT"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.PasswordHint"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_HINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_PROTECTED"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.PasswordProtected"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_PROTECTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PERSISTENT"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Persistent"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PERSISTENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PRIVATE"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Private"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PRIVATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_TITLE"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Title"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_TITLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CREATION_TIMESTAMP"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.CreationTimestamp"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CREATION_TIMESTAMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CREATOR"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.Creator"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CREATOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CREATOR_HANDLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.CreatorHandle"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CREATOR_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_ROOM_NAME"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.RoomName"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_ROOM_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_SERVER"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.Server"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_SERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AUTHORIZATION_IDENTITY"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.AuthorizationIdentity"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AUTHORIZATION_IDENTITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AVAILABLE_MECHANISMS"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.AvailableMechanisms"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AVAILABLE_MECHANISMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_CAN_TRY_AGAIN"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.CanTryAgain"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_CAN_TRY_AGAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_REALM"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.DefaultRealm"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_REALM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_USERNAME"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.DefaultUsername"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_HAS_INITIAL_DATA"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.HasInitialData"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_HAS_INITIAL_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_MAY_SAVE_RESPONSE"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.MaySaveResponse"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_MAY_SAVE_RESPONSE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.SASLError"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR_DETAILS"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.SASLErrorDetails"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_STATUS"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.SASLStatus"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SECURABLE_ENCRYPTED"
              value="org.freedesktop.Telepathy.Channel.Interface.Securable.Encrypted"
              c:type="TP_PROP_CHANNEL_INTERFACE_SECURABLE_ENCRYPTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SECURABLE_VERIFIED"
              value="org.freedesktop.Telepathy.Channel.Interface.Securable.Verified"
              c:type="TP_PROP_CHANNEL_INTERFACE_SECURABLE_VERIFIED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SERVICE_POINT_CURRENT_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint.CurrentServicePoint"
              c:type="TP_PROP_CHANNEL_INTERFACE_SERVICE_POINT_CURRENT_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SERVICE_POINT_INITIAL_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint.InitialServicePoint"
              c:type="TP_PROP_CHANNEL_INTERFACE_SERVICE_POINT_INITIAL_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SMS_FLASH"
              value="org.freedesktop.Telepathy.Channel.Interface.SMS.Flash"
              c:type="TP_PROP_CHANNEL_INTERFACE_SMS_FLASH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL"
              value="org.freedesktop.Telepathy.Channel.Interface.SMS.SMSChannel"
              c:type="TP_PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.Actor"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR_HANDLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.ActorHandle"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_CAN_SET"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.CanSet"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_CAN_SET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_SUBJECT"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.Subject"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_SUBJECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_TIMESTAMP"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.Timestamp"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_TIMESTAMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_TUBE_PARAMETERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Tube.Parameters"
              c:type="TP_PROP_CHANNEL_INTERFACE_TUBE_PARAMETERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_TUBE_STATE"
              value="org.freedesktop.Telepathy.Channel.Interface.Tube.State"
              c:type="TP_PROP_CHANNEL_INTERFACE_TUBE_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUESTED"
              value="org.freedesktop.Telepathy.Channel.Requested"
              c:type="TP_PROP_CHANNEL_REQUESTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_ACCOUNT"
              value="org.freedesktop.Telepathy.ChannelRequest.Account"
              c:type="TP_PROP_CHANNEL_REQUEST_ACCOUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_HINTS"
              value="org.freedesktop.Telepathy.ChannelRequest.Hints"
              c:type="TP_PROP_CHANNEL_REQUEST_HINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_INTERFACES"
              value="org.freedesktop.Telepathy.ChannelRequest.Interfaces"
              c:type="TP_PROP_CHANNEL_REQUEST_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_PREFERRED_HANDLER"
              value="org.freedesktop.Telepathy.ChannelRequest.PreferredHandler"
              c:type="TP_PROP_CHANNEL_REQUEST_PREFERRED_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_REQUESTS"
              value="org.freedesktop.Telepathy.ChannelRequest.Requests"
              c:type="TP_PROP_CHANNEL_REQUEST_REQUESTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_USER_ACTION_TIME"
              value="org.freedesktop.Telepathy.ChannelRequest.UserActionTime"
              c:type="TP_PROP_CHANNEL_REQUEST_USER_ACTION_TIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_HANDLE"
              value="org.freedesktop.Telepathy.Channel.TargetHandle"
              c:type="TP_PROP_CHANNEL_TARGET_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_HANDLE_TYPE"
              value="org.freedesktop.Telepathy.Channel.TargetHandleType"
              c:type="TP_PROP_CHANNEL_TARGET_HANDLE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_ID"
              value="org.freedesktop.Telepathy.Channel.TargetID"
              c:type="TP_PROP_CHANNEL_TARGET_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_FLAGS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallFlags"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallMembers"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_STATE"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallState"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_STATE_DETAILS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallStateDetails"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_STATE_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CALL_STATE_REASON"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.CallStateReason"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CALL_STATE_REASON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_CONTENTS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.Contents"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_CONTENTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_HARDWARE_STREAMING"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.HardwareStreaming"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_HARDWARE_STREAMING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialAudio"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO_NAME"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialAudioName"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_TRANSPORT"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialTransport"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_TRANSPORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialVideo"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO_NAME"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.InitialVideoName"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_MEMBER_IDENTIFIERS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.MemberIdentifiers"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_MEMBER_IDENTIFIERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CALL_MUTABLE_CONTENTS"
              value="org.freedesktop.Telepathy.Channel.Type.Call1.MutableContents"
              c:type="TP_PROP_CHANNEL_TYPE_CALL_MUTABLE_CONTENTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_AVAILABLE_SEARCH_KEYS"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.AvailableSearchKeys"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_AVAILABLE_SEARCH_KEYS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_LIMIT"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.Limit"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_SEARCH_STATE"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.SearchState"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_SEARCH_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_SERVER"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.Server"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_SERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_DBUS_NAMES"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube.DBusNames"
              c:type="TP_PROP_CHANNEL_TYPE_DBUS_TUBE_DBUS_NAMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube.ServiceName"
              c:type="TP_PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_SUPPORTED_ACCESS_CONTROLS"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube.SupportedAccessControls"
              c:type="TP_PROP_CHANNEL_TYPE_DBUS_TUBE_SUPPORTED_ACCESS_CONTROLS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_AVAILABLE_SOCKET_TYPES"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.AvailableSocketTypes"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_AVAILABLE_SOCKET_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentHash"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH_TYPE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentHashType"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentType"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Date"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Description"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Filename"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.InitialOffset"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Size"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_STATE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.State"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_TRANSFERRED_BYTES"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.TransferredBytes"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_TRANSFERRED_BYTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_URI"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.URI"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_ROOM_LIST_SERVER"
              value="org.freedesktop.Telepathy.Channel.Type.RoomList.Server"
              c:type="TP_PROP_CHANNEL_TYPE_ROOM_LIST_SERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_AUTHENTICATION_AUTHENTICATION_METHOD"
              value="org.freedesktop.Telepathy.Channel.Type.ServerAuthentication.AuthenticationMethod"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_AUTHENTICATION_AUTHENTICATION_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_HOSTNAME"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection.Hostname"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_REFERENCE_IDENTITIES"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection.ReferenceIdentities"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_REFERENCE_IDENTITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_SERVER_CERTIFICATE"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection.ServerCertificate"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_SERVER_CERTIFICATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_IMMUTABLE_STREAMS"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.ImmutableStreams"
              c:type="TP_PROP_CHANNEL_TYPE_STREAMED_MEDIA_IMMUTABLE_STREAMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_AUDIO"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.InitialAudio"
              c:type="TP_PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_AUDIO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_VIDEO"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.InitialVideo"
              c:type="TP_PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_VIDEO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE"
              value="org.freedesktop.Telepathy.Channel.Type.StreamTube.Service"
              c:type="TP_PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAM_TUBE_SUPPORTED_SOCKET_TYPES"
              value="org.freedesktop.Telepathy.Channel.Type.StreamTube.SupportedSocketTypes"
              c:type="TP_PROP_CHANNEL_TYPE_STREAM_TUBE_SUPPORTED_SOCKET_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_APPROVER_APPROVER_CHANNEL_FILTER"
              value="org.freedesktop.Telepathy.Client.Approver.ApproverChannelFilter"
              c:type="TP_PROP_CLIENT_APPROVER_APPROVER_CHANNEL_FILTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_BYPASS_APPROVAL"
              value="org.freedesktop.Telepathy.Client.Handler.BypassApproval"
              c:type="TP_PROP_CLIENT_HANDLER_BYPASS_APPROVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_CAPABILITIES"
              value="org.freedesktop.Telepathy.Client.Handler.Capabilities"
              c:type="TP_PROP_CLIENT_HANDLER_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_HANDLED_CHANNELS"
              value="org.freedesktop.Telepathy.Client.Handler.HandledChannels"
              c:type="TP_PROP_CLIENT_HANDLER_HANDLED_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_HANDLER_CHANNEL_FILTER"
              value="org.freedesktop.Telepathy.Client.Handler.HandlerChannelFilter"
              c:type="TP_PROP_CLIENT_HANDLER_HANDLER_CHANNEL_FILTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_INTERFACES"
              value="org.freedesktop.Telepathy.Client.Interfaces"
              c:type="TP_PROP_CLIENT_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_DELAY_APPROVERS"
              value="org.freedesktop.Telepathy.Client.Observer.DelayApprovers"
              c:type="TP_PROP_CLIENT_OBSERVER_DELAY_APPROVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_OBSERVER_CHANNEL_FILTER"
              value="org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter"
              c:type="TP_PROP_CLIENT_OBSERVER_OBSERVER_CHANNEL_FILTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_RECOVER"
              value="org.freedesktop.Telepathy.Client.Observer.Recover"
              c:type="TP_PROP_CLIENT_OBSERVER_RECOVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_HAS_IMMORTAL_HANDLES"
              value="org.freedesktop.Telepathy.Connection.HasImmortalHandles"
              c:type="TP_PROP_CONNECTION_HAS_IMMORTAL_HANDLES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACES"
              value="org.freedesktop.Telepathy.Connection.Interfaces"
              c:type="TP_PROP_CONNECTION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.AnonymityMandatory"
              c:type="TP_PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MODES"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.AnonymityModes"
              c:type="TP_PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MODES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_SUPPORTED_ANONYMITY_MODES"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.SupportedAnonymityModes"
              c:type="TP_PROP_CONNECTION_INTERFACE_ANONYMITY_SUPPORTED_ANONYMITY_MODES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarBytes"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarHeight"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarWidth"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MinimumAvatarHeight"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MinimumAvatarWidth"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.RecommendedAvatarHeight"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.RecommendedAvatarWidth"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.SupportedAvatarMIMETypes"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_BALANCE_ACCOUNT_BALANCE"
              value="org.freedesktop.Telepathy.Connection.Interface.Balance.AccountBalance"
              c:type="TP_PROP_CONNECTION_INTERFACE_BALANCE_ACCOUNT_BALANCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_BALANCE_MANAGE_CREDIT_URI"
              value="org.freedesktop.Telepathy.Connection.Interface.Balance.ManageCreditURI"
              c:type="TP_PROP_CONNECTION_INTERFACE_BALANCE_MANAGE_CREDIT_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_IMSI"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.IMSI"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_IMSI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_NATIONAL_CHARACTER_SET"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageNationalCharacterSet"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_NATIONAL_CHARACTER_SET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_REDUCED_CHARACTER_SET"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageReducedCharacterSet"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_REDUCED_CHARACTER_SET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_SERVICE_CENTRE"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageServiceCentre"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_SERVICE_CENTRE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_VALIDITY_PERIOD"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageValidityPeriod"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_VALIDITY_PERIOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_OVERRIDE_MESSAGE_SERVICE_CENTRE"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.OverrideMessageServiceCentre"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_OVERRIDE_MESSAGE_SERVICE_CENTRE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACTS_CONTACT_ATTRIBUTE_INTERFACES"
              value="org.freedesktop.Telepathy.Connection.Interface.Contacts.ContactAttributeInterfaces"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACTS_CONTACT_ATTRIBUTE_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_BLOCKING_CONTACT_BLOCKING_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactBlocking.ContactBlockingCapabilities"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_BLOCKING_CONTACT_BLOCKING_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_DISJOINT_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups.DisjointGroups"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_DISJOINT_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups.Groups"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUP_STORAGE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups.GroupStorage"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUP_STORAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_INFO_CONTACT_INFO_FLAGS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo.ContactInfoFlags"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_INFO_CONTACT_INFO_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_INFO_SUPPORTED_FIELDS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo.SupportedFields"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_INFO_SUPPORTED_FIELDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_CAN_CHANGE_CONTACT_LIST"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.CanChangeContactList"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_CAN_CHANGE_CONTACT_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_PERSISTS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.ContactListPersists"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_PERSISTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_STATE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.ContactListState"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_DOWNLOAD_AT_CONNECTION"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.DownloadAtConnection"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_DOWNLOAD_AT_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_REQUEST_USES_MESSAGE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.RequestUsesMessage"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_REQUEST_USES_MESSAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL"
              value="org.freedesktop.Telepathy.Connection.Interface.Location.LocationAccessControl"
              c:type="TP_PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.Location.LocationAccessControlTypes"
              c:type="TP_PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_SUPPORTED_LOCATION_FEATURES"
              value="org.freedesktop.Telepathy.Connection.Interface.Location.SupportedLocationFeatures"
              c:type="TP_PROP_CONNECTION_INTERFACE_LOCATION_SUPPORTED_LOCATION_FEATURES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_ADDRESS"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.MailAddress"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_NOTIFICATION_FLAGS"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.MailNotificationFlags"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_NOTIFICATION_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAILS"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.UnreadMails"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAIL_COUNT"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.UnreadMailCount"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAIL_COUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_POWER_SAVING_POWER_SAVING_ACTIVE"
              value="org.freedesktop.Telepathy.Connection.Interface.PowerSaving.PowerSavingActive"
              c:type="TP_PROP_CONNECTION_INTERFACE_POWER_SAVING_POWER_SAVING_ACTIVE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_REQUESTS_CHANNELS"
              value="org.freedesktop.Telepathy.Connection.Interface.Requests.Channels"
              c:type="TP_PROP_CONNECTION_INTERFACE_REQUESTS_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_REQUESTS_REQUESTABLE_CHANNEL_CLASSES"
              value="org.freedesktop.Telepathy.Connection.Interface.Requests.RequestableChannelClasses"
              c:type="TP_PROP_CONNECTION_INTERFACE_REQUESTS_REQUESTABLE_CHANNEL_CLASSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SERVICE_POINT_KNOWN_SERVICE_POINTS"
              value="org.freedesktop.Telepathy.Connection.Interface.ServicePoint.KnownServicePoints"
              c:type="TP_PROP_CONNECTION_INTERFACE_SERVICE_POINT_KNOWN_SERVICE_POINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_MAXIMUM_STATUS_MESSAGE_LENGTH"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence.MaximumStatusMessageLength"
              c:type="TP_PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_MAXIMUM_STATUS_MESSAGE_LENGTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_STATUSES"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence.Statuses"
              c:type="TP_PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_STATUSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_MANAGER_INTERFACES"
              value="org.freedesktop.Telepathy.ConnectionManager.Interfaces"
              c:type="TP_PROP_CONNECTION_MANAGER_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_MANAGER_PROTOCOLS"
              value="org.freedesktop.Telepathy.ConnectionManager.Protocols"
              c:type="TP_PROP_CONNECTION_MANAGER_PROTOCOLS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_SELF_HANDLE"
              value="org.freedesktop.Telepathy.Connection.SelfHandle"
              c:type="TP_PROP_CONNECTION_SELF_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_STATUS"
              value="org.freedesktop.Telepathy.Connection.Status"
              c:type="TP_PROP_CONNECTION_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_DEBUG_ENABLED"
              value="org.freedesktop.Telepathy.Debug.Enabled"
              c:type="TP_PROP_DEBUG_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_CREATED_LOCALLY"
              value="org.freedesktop.Telepathy.Media.StreamHandler.CreatedLocally"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_CREATED_LOCALLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_NAT_TRAVERSAL"
              value="org.freedesktop.Telepathy.Media.StreamHandler.NATTraversal"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_NAT_TRAVERSAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_RELAY_INFO"
              value="org.freedesktop.Telepathy.Media.StreamHandler.RelayInfo"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_RELAY_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_STUN_SERVERS"
              value="org.freedesktop.Telepathy.Media.StreamHandler.STUNServers"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_STUN_SERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_AUTHENTICATION_TYPES"
              value="org.freedesktop.Telepathy.Protocol.AuthenticationTypes"
              c:type="TP_PROP_PROTOCOL_AUTHENTICATION_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_CONNECTION_INTERFACES"
              value="org.freedesktop.Telepathy.Protocol.ConnectionInterfaces"
              c:type="TP_PROP_PROTOCOL_CONNECTION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_ENGLISH_NAME"
              value="org.freedesktop.Telepathy.Protocol.EnglishName"
              c:type="TP_PROP_PROTOCOL_ENGLISH_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_ICON"
              value="org.freedesktop.Telepathy.Protocol.Icon"
              c:type="TP_PROP_PROTOCOL_ICON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACES"
              value="org.freedesktop.Telepathy.Protocol.Interfaces"
              c:type="TP_PROP_PROTOCOL_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_URI_SCHEMES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Addressing.AddressableURISchemes"
              c:type="TP_PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_URI_SCHEMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_VCARD_FIELDS"
              value="org.freedesktop.Telepathy.Protocol.Interface.Addressing.AddressableVCardFields"
              c:type="TP_PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_VCARD_FIELDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MaximumAvatarBytes"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MaximumAvatarHeight"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MaximumAvatarWidth"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MinimumAvatarHeight"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MinimumAvatarWidth"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.RecommendedAvatarHeight"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.RecommendedAvatarWidth"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.SupportedAvatarMIMETypes"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_PRESENCE_STATUSES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Presence.Statuses"
              c:type="TP_PROP_PROTOCOL_INTERFACE_PRESENCE_STATUSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_PARAMETERS"
              value="org.freedesktop.Telepathy.Protocol.Parameters"
              c:type="TP_PROP_PROTOCOL_PARAMETERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_REQUESTABLE_CHANNEL_CLASSES"
              value="org.freedesktop.Telepathy.Protocol.RequestableChannelClasses"
              c:type="TP_PROP_PROTOCOL_REQUESTABLE_CHANNEL_CLASSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_VCARD_FIELD"
              value="org.freedesktop.Telepathy.Protocol.VCardField"
              c:type="TP_PROP_PROTOCOL_VCARD_FIELD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="PresenceMixin" c:type="TpPresenceMixin">
      <doc xml:whitespace="preserve">Structure to be included in the instance structure of objects that
use this mixin. Initialize it with tp_presence_mixin_init().

There are no public fields.</doc>
      <field name="priv" readable="0" private="1">
        <type name="PresenceMixinPrivate" c:type="TpPresenceMixinPrivate*"/>
      </field>
      <function name="emit_one_presence_update"
                c:identifier="tp_presence_mixin_emit_one_presence_update"
                introspectable="0">
        <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for a single contact. This method is just a
convenience wrapper around #tp_presence_mixin_emit_presence_update.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A connection object with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle of the contact to emit the signal for</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new status to emit</doc>
            <type name="PresenceStatus" c:type="const TpPresenceStatus*"/>
          </parameter>
        </parameters>
      </function>
      <function name="emit_presence_update"
                c:identifier="tp_presence_mixin_emit_presence_update"
                introspectable="0">
        <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for multiple contacts. For emitting
PresenceUpdate for a single contact, there is a convenience wrapper called
#tp_presence_mixin_emit_one_presence_update.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A connection object with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contact_presences" transfer-ownership="none">
            <doc xml:whitespace="preserve">A mapping of contact handles to #TpPresenceStatus structures with the presence data to emit</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="finalize"
                c:identifier="tp_presence_mixin_finalize"
                introspectable="0">
        <doc xml:whitespace="preserve">Free resources held by the presence mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object with this mixin.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_presence_mixin_get_offset_quark"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="iface_init"
                c:identifier="tp_presence_mixin_iface_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the presence interface using
this mixin. This function should usually be called via G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfacePresenceClass in an object class</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init"
                c:identifier="tp_presence_mixin_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_init ((GObject *) self,
                        G_STRUCT_OFFSET (SomeObject, presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixin within the object structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </function>
      <function name="simple_presence_iface_init"
                c:identifier="tp_presence_mixin_simple_presence_iface_init"
                version="0.7.13"
                introspectable="0">
        <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the simple presence interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceSimplePresenceClass in an object class</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="simple_presence_init_dbus_properties"
                c:identifier="tp_presence_mixin_simple_presence_init_dbus_properties"
                version="0.7.13"
                introspectable="0">
        <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the SimplePresence interface's properties.

This automatically sets up a list of the supported properties for the
SimplePresence interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="simple_presence_register_with_contacts_mixin"
                c:identifier="tp_presence_mixin_simple_presence_register_with_contacts_mixin"
                introspectable="0">
        <doc xml:whitespace="preserve">Register the SimplePresence interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An instance that of the implementation that uses both the Contacts mixin and this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PresenceMixinClass" c:type="TpPresenceMixinClass">
      <doc xml:whitespace="preserve">Structure to be included in the class structure of objects that
use this mixin. Initialize it with tp_presence_mixin_class_init().

If the protocol imposes a limit on the length of status messages, one should
implement @get_maximum_status_message_length. If this callback is not
implemented, it is assumed that there is no limit. The callback function
should be set after calling tp_presence_mixin_class_init(), like so:

|[
TpPresenceMixinClass *mixin_class;

tp_presence_mixin_class_init ((GObjectClass *) klass,
    G_STRUCT_OFFSET (SomeObjectClass, presence_mixin));
mixin_class = TP_PRESENCE_MIXIN_CLASS (klass);
mixin_class-&gt;get_maximum_status_message_length =
    some_object_get_maximum_status_message_length;
]|

All other fields should be considered read-only.</doc>
      <field name="status_available" writable="1">
        <type name="PresenceMixinStatusAvailableFunc"
              c:type="TpPresenceMixinStatusAvailableFunc"/>
      </field>
      <field name="get_contact_statuses" writable="1">
        <type name="PresenceMixinGetContactStatusesFunc"
              c:type="TpPresenceMixinGetContactStatusesFunc"/>
      </field>
      <field name="set_own_status" writable="1">
        <type name="PresenceMixinSetOwnStatusFunc"
              c:type="TpPresenceMixinSetOwnStatusFunc"/>
      </field>
      <field name="statuses" writable="1">
        <type name="PresenceStatusSpec" c:type="const TpPresenceStatusSpec*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PresenceMixinClassPrivate"
              c:type="TpPresenceMixinClassPrivate*"/>
      </field>
      <field name="get_maximum_status_message_length" writable="1">
        <type name="PresenceMixinGetMaximumStatusMessageLengthFunc"
              c:type="TpPresenceMixinGetMaximumStatusMessageLengthFunc"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <function name="get_offset_quark"
                c:identifier="tp_presence_mixin_class_get_offset_quark"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init"
                c:identifier="tp_presence_mixin_class_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_class_init ((GObjectClass *) klass,
                              G_STRUCT_OFFSET (SomeObjectClass,
                                               presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixinClass within the class structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
          <parameter name="status_available" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to determine if a given presence status can be set on a particular connection. Should usually be %NULL, to consider all statuses with #TpPresenceStatusSpec.self set to %TRUE to be settable.</doc>
            <type name="PresenceMixinStatusAvailableFunc"
                  c:type="TpPresenceMixinStatusAvailableFunc"/>
          </parameter>
          <parameter name="get_contact_statuses" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used get the current presence status for contacts. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
            <type name="PresenceMixinGetContactStatusesFunc"
                  c:type="TpPresenceMixinGetContactStatusesFunc"/>
          </parameter>
          <parameter name="set_own_status" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to commit changes to the user's own presence status to the server. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
            <type name="PresenceMixinSetOwnStatusFunc"
                  c:type="TpPresenceMixinSetOwnStatusFunc"/>
          </parameter>
          <parameter name="statuses" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpPresenceStatusSpec structures representing all presence statuses supported by the protocol, terminated by a NULL name.</doc>
            <type name="PresenceStatusSpec"
                  c:type="const TpPresenceStatusSpec*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PresenceMixinClassPrivate"
            c:type="TpPresenceMixinClassPrivate"
            disguised="1">
    </record>
    <callback name="PresenceMixinGetContactStatusesFunc"
              c:type="TpPresenceMixinGetContactStatusesFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to get the stored presence status of
contacts. The returned hash table should have contact handles mapped to
their respective presence statuses in #TpPresenceStatus structs.

The returned hash table will be freed with g_hash_table_unref. The
callback is responsible for ensuring that this does any cleanup that
may be necessary.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">The contact presence on success, %NULL with error set on error</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #TpHandle for the contacts to get presence status for</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </callback>
    <callback name="PresenceMixinGetMaximumStatusMessageLengthFunc"
              c:type="TpPresenceMixinGetMaximumStatusMessageLengthFunc"
              version="0.14.5">
      <doc xml:whitespace="preserve">Signature of a callback used to determine the maximum length of status
messages. If this callback is provided and returns non-zero, the
#TpPresenceMixinSetOwnStatusFunc implementation is responsible for
truncating the message to fit this limit, if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maximum number of UTF-8 characters which may appear in a status message, or 0 if there is no limit.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PresenceMixinPrivate"
            c:type="TpPresenceMixinPrivate"
            disguised="1">
    </record>
    <callback name="PresenceMixinSetOwnStatusFunc"
              c:type="TpPresenceMixinSetOwnStatusFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to commit changes to the user's own presence
status in SetStatuses. It is also used in ClearStatus and RemoveStatus to
reset the user's own status back to the "default" one with a %NULL status
argument.

The optional_arguments hash table in @status, if not NULL, will have been
filtered so it only contains recognised parameters, so the callback
need not (and cannot) check for unrecognised parameters. However, the
types of the parameters are not currently checked, so the callback is
responsible for doing so.

The callback is responsible for emitting PresenceUpdate, if appropriate,
by calling tp_presence_mixin_emit_presence_update().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the operation was successful, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:whitespace="preserve">The status to set, or NULL for whatever the protocol defines as a "default" status</doc>
          <type name="PresenceStatus" c:type="const TpPresenceStatus*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PresenceMixinStatusAvailableFunc"
              c:type="TpPresenceMixinStatusAvailableFunc">
      <doc xml:whitespace="preserve">Signature of a callback to be used to determine if a given presence
status can be set on the connection. Most users of this mixin do not need to
supply an implementation of this callback: the value of
#TpPresenceStatusSpec.self is enough to determine whether this is a
user-settable presence, so %NULL should be passed to
tp_presence_mixin_class_init() for this callback.

One place where this callback may be needed is on XMPP: not all server
implementation support the user becoming invisible. So an XMPP
implementation would implement this function, so that—once connected—the
hidden status is only available if the server supports it. Before the
connection is connected, this callback should return %TRUE for every status
that might possibly be supported: this allows the user to at least try to
sign in as invisible.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the status can be set on this connection; %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of a #TpBaseConnection subclass implementing the presence interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="which" transfer-ownership="none">
          <doc xml:whitespace="preserve">An index into the array of #TpPresenceStatusSpec provided to tp_presence_mixin_class_init()</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PresenceStatus" c:type="TpPresenceStatus">
      <doc xml:whitespace="preserve">Structure representing a presence status.

In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.</doc>
      <field name="index" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="optional_arguments" writable="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="free"
              c:identifier="tp_presence_status_free"
              introspectable="0">
        <doc xml:whitespace="preserve">Deallocate all resources associated with a presence status structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <function name="new"
                c:identifier="tp_presence_status_new"
                introspectable="0">
        <doc xml:whitespace="preserve">Construct a presence status structure. You should free the returned
structure with #tp_presence_status_free.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A pointer to the newly allocated presence status structure.</doc>
          <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
        </return-value>
        <parameters>
          <parameter name="which" transfer-ownership="none">
            <doc xml:whitespace="preserve">Index of the presence status in the provided supported presence statuses array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="optional_arguments" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional arguments for the presence statuses. Can be NULL if there are no optional arguments. The presence status object makes a copy of the hashtable, so you should free the original.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PresenceStatusOptionalArgumentSpec"
            c:type="TpPresenceStatusOptionalArgumentSpec">
      <doc xml:whitespace="preserve">Structure specifying a supported optional argument for a presence status.

In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="dtype" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="PresenceStatusSpec" c:type="TpPresenceStatusSpec">
      <doc xml:whitespace="preserve">Structure specifying a supported presence status.

In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="presence_type" writable="1">
        <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
      </field>
      <field name="self" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="optional_arguments" writable="1">
        <type name="PresenceStatusOptionalArgumentSpec"
              c:type="const TpPresenceStatusOptionalArgumentSpec*"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <bitfield name="PropertyFlags" c:type="TpPropertyFlags">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="read" value="1" c:identifier="TP_PROPERTY_FLAG_READ"/>
      <member name="write" value="2" c:identifier="TP_PROPERTY_FLAG_WRITE"/>
    </bitfield>
    <class name="Protocol"
           c:symbol-prefix="protocol"
           c:type="TpProtocol"
           version="0.11.11"
           parent="Proxy"
           glib:type-name="TpProtocol"
           glib:get-type="tp_protocol_get_type"
           glib:type-struct="ProtocolClass">
      <doc xml:whitespace="preserve">A base class for connection managers' protocols.</doc>
      <constructor name="new"
                   c:identifier="tp_protocol_new"
                   version="0.11.11"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new protocol proxy, or %NULL on invalid arguments</doc>
          <type name="Protocol" c:type="TpProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">proxy for the D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="cm_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the connection manager name (such as "gabble")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the protocol name (such as "jabber")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable D-Bus properties for this protocol</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_protocol_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_parameters"
                c:identifier="tp_protocol_get_feature_quark_parameters">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_protocol_init_known_interfaces"
                version="0.11.11">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpProtocol have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_PROTOCOL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="borrow_params"
              c:identifier="tp_protocol_borrow_params"
              version="0.17.6"
              introspectable="0"
              deprecated="Since 0.19.9. New code should use tp_protocol_dup_params() instead.">
        <doc xml:whitespace="preserve">Returns an array of parameters supported by this connection manager,
without additional memory allocations. The returned array is owned by
@self, and must not be used after @self has been freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of #TpConnectionManagerParam structures, terminated by one whose @name is %NULL</doc>
          <type name="ConnectionManagerParam"
                c:type="const TpConnectionManagerParam*"/>
        </return-value>
      </method>
      <method name="can_register"
              c:identifier="tp_protocol_can_register"
              version="0.11.11">
        <doc xml:whitespace="preserve">Return whether a new account can be registered on this protocol, by setting
the special "register" parameter to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @protocol supports the parameter "register"</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="dup_param"
              c:identifier="tp_protocol_dup_param"
              version="0.17.6">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a structure representing the parameter @param, or %NULL if not supported. Free with tp_connection_manager_param_free()</doc>
          <type name="ConnectionManagerParam"
                c:type="TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_param_names"
              c:identifier="tp_protocol_dup_param_names"
              version="0.11.11">
        <doc xml:whitespace="preserve">Returns a list of parameter names supported by this connection manager
for this protocol.

The result is copied and must be freed by the caller with g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a copy of #TpProtocol:param-names</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="dup_params"
              c:identifier="tp_protocol_dup_params"
              version="0.17.6">
        <doc xml:whitespace="preserve">Returns a list of parameters supported by this connection manager.

The returned list must be freed by the caller, for instance with
&lt;literal&gt;g_list_free_full (l,
(GDestroyNotify) tp_connection_manager_param_free)&lt;/literal&gt;.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a list of #TpConnectionManagerParam structures, owned by the caller</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ConnectionManagerParam"/>
          </type>
        </return-value>
      </method>
      <method name="get_authentication_types"
              c:identifier="tp_protocol_get_authentication_types"
              version="0.13.9">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpProtocol:authentication-types</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_avatar_requirements"
              c:identifier="tp_protocol_get_avatar_requirements"
              version="0.15.6">
        <doc xml:whitespace="preserve">Return the #TpProtocol:avatar-requirements property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpProtocol:avatar-requirements</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
      </method>
      <method name="get_capabilities"
              c:identifier="tp_protocol_get_capabilities"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TpProtocol:capabilities, which must be referenced (if non-%NULL) if it will be kept</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
      </method>
      <method name="get_cm_name"
              c:identifier="tp_protocol_get_cm_name"
              version="0.19.1">
        <doc xml:whitespace="preserve">Return the #TpProtocol:cm-name property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpProtocol:cm-name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_english_name"
              c:identifier="tp_protocol_get_english_name"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the non-%NULL, non-empty value of #TpProtocol:english-name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_icon_name"
              c:identifier="tp_protocol_get_icon_name"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the non-%NULL, non-empty value of #TpProtocol:icon-name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_name"
              c:identifier="tp_protocol_get_name"
              version="0.11.11">
        <doc xml:whitespace="preserve">Return the same thing as the protocol-name property, for convenient use
in C code. The returned string is valid for as long as @self exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpProtocol:protocol-name property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_param"
              c:identifier="tp_protocol_get_param"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a structure representing the parameter @param, or %NULL if not supported</doc>
          <type name="ConnectionManagerParam"
                c:type="const TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vcard_field"
              c:identifier="tp_protocol_get_vcard_field"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpProtocol:vcard-field</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="has_param"
              c:identifier="tp_protocol_has_param"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @self supports the parameter @param.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="authentication-types"
                version="0.13.9"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A non-%NULL #GStrv of interfaces which provide information as to
what kind of authentication channels can possibly appear before
the connection reaches the CONNECTED state, or %NULL if
%TP_PROTOCOL_FEATURE_CORE has not been prepared.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="avatar-requirements"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAvatarRequirements representing the avatar requirements on this
protocol, or %NULL if %TP_PROTOCOL_FEATURE_CORE has not been prepared or
if the protocol doesn't support avatars.</doc>
        <type name="gpointer"/>
      </property>
      <property name="capabilities"
                version="0.11.11"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The classes of channel that can be requested from connections to this
protocol, or %NULL if this is unknown or the %TP_PROTOCOL_FEATURE_CORE
feature has not been prepared.</doc>
        <type name="Capabilities"/>
      </property>
      <property name="cm-name"
                version="0.19.1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the connection manager this protocol is on.</doc>
        <type name="utf8"/>
      </property>
      <property name="english-name"
                version="0.11.11"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the protocol in a form suitable for display to users,
such as "AIM" or "Yahoo!", or a string based on #TpProtocol:protocol-name
(currently constructed by putting the first character in title case,
but this is not guaranteed) if no better name is available or the
%TP_PROTOCOL_FEATURE_CORE feature has not been prepared.

This is effectively in the C locale (international English); user
interfaces requiring a localized protocol name should look one up in their
own message catalog based on either #TpProtocol:protocol-name or
#TpProtocol:english-name, but should use this English version as a
fallback if no translated version can be found.</doc>
        <type name="utf8"/>
      </property>
      <property name="icon-name" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of an icon in the system's icon theme. If none was supplied
by the Protocol, or the %TP_PROTOCOL_FEATURE_CORE feature has not been
prepared, a default is used; currently, this is "im-" plus
#TpProtocol:protocol-name.</doc>
        <type name="utf8"/>
      </property>
      <property name="param-names" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">A list of parameter names supported by this connection manager
for this protocol, or %NULL if %TP_PROTOCOL_FEATURE_PARAMETERS has not
been prepared.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="protocol-name"
                version="0.11.11"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The machine-readable name of the protocol, taken from the Telepathy
D-Bus Interface Specification, such as "jabber" or "local-xmpp".</doc>
        <type name="utf8"/>
      </property>
      <property name="protocol-properties"
                version="0.11.11"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The immutable properties of this Protocol, as provided at construction
time. This is a map from string to #GValue, which must not be modified.

If the immutable properties were not provided at construction time,
the %TP_PROTOCOL_FEATURE_PARAMETERS and %TP_PROTOCOL_FEATURE_CORE features
will both be unavailable, and this #TpProtocol object will only be useful
as a way to access lower-level D-Bus calls.</doc>
        <type/>
      </property>
      <property name="vcard-field" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">The most common vCard field used for this protocol's contact
identifiers, normalized to lower case, or %NULL if there is no such field
or the %TP_PROTOCOL_FEATURE_CORE feature has not been prepared.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProtocolPrivate" c:type="TpProtocolPrivate*"/>
      </field>
    </class>
    <record name="ProtocolClass"
            c:type="TpProtocolClass"
            disguised="1"
            glib:is-gtype-struct-for="Protocol"
            version="0.11.11">
      <doc xml:whitespace="preserve">The class of a #TpProtocol.</doc>
    </record>
    <record name="ProtocolClassPrivate"
            c:type="TpProtocolClassPrivate"
            disguised="1">
    </record>
    <record name="ProtocolPrivate" c:type="TpProtocolPrivate" disguised="1">
    </record>
    <class name="Proxy"
           c:symbol-prefix="proxy"
           c:type="TpProxy"
           version="0.7.1"
           parent="GObject.Object"
           glib:type-name="TpProxy"
           glib:get-type="tp_proxy_get_type"
           glib:type-struct="ProxyClass">
      <doc xml:whitespace="preserve">Structure representing a Telepathy client-side proxy.</doc>
      <method name="dbus_error_to_gerror"
              c:identifier="tp_proxy_dbus_error_to_gerror"
              version="0.7.24"
              throws="1">
        <doc xml:whitespace="preserve">Convert a D-Bus error name into a GError as if it was returned by a method
on this proxy. This method is useful when D-Bus error names are emitted in
signals, such as Connection.ConnectionError and
Group.MembersChangedDetailed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dbus_error" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus error name, for instance from the callback for tp_cli_connection_connect_to_connection_error()</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="debug_message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a debug message that accompanied the error name, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bus_name"
              c:identifier="tp_proxy_get_bus_name"
              version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the bus name of the application exporting the object. The caller must copy the string with g_strdup() if it will be kept.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_dbus_connection"
              c:identifier="tp_proxy_get_dbus_connection"
              version="0.7.17"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value>
          <doc xml:whitespace="preserve">a borrowed reference to the D-Bus connection used by this object. The caller must reference the returned pointer with dbus_g_connection_ref() if it will be kept.</doc>
          <type c:type="DBusGConnection*"/>
        </return-value>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_proxy_get_dbus_daemon"
              version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a borrowed reference to the #TpDBusDaemon for this object, if any; always %NULL if this object is itself a #TpDBusDaemon. The caller must reference the returned object with g_object_ref() if it will be kept.</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="get_factory"
              c:identifier="tp_proxy_get_factory"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same value as #TpProxy:factory property</doc>
          <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
        </return-value>
      </method>
      <method name="get_invalidated"
              c:identifier="tp_proxy_get_invalidated"
              version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the reason this proxy was invalidated, or %NULL if has not been invalidated. The caller must copy the error, for instance with g_error_copy(), if it will be kept.</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </return-value>
      </method>
      <method name="get_object_path"
              c:identifier="tp_proxy_get_object_path"
              version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the object path of the remote object. The caller must copy the string with g_strdup() if it will be kept.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="has_interface"
              c:identifier="tp_proxy_has_interface"
              version="0.7.1">
        <doc xml:whitespace="preserve">Return whether this proxy is known to have a particular interface. In
versions older than 0.11.11, this was a macro wrapper around
tp_proxy_has_interface_by_id().

For objects that discover their interfaces at runtime, this method will
indicate that interfaces are missing until they are known to be present.
In subclasses that define features for use with tp_proxy_prepare_async(),
successfully preparing the "core" feature for that subclass (such as
%TP_CHANNEL_FEATURE_CORE or %TP_CONNECTION_FEATURE_CORE) implies that the
interfaces are known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this proxy implements the given interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">the D-Bus interface required, as a string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_interface_by_id"
              c:identifier="tp_proxy_has_interface_by_id"
              version="0.7.1">
        <doc xml:whitespace="preserve">Return whether this proxy is known to have a particular interface, by its
quark ID. This is equivalent to using g_quark_to_string() followed by
tp_proxy_has_interface(), but more efficient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this proxy implements the given interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">quark representing the D-Bus interface required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_prepared"
              c:identifier="tp_proxy_is_prepared"
              version="0.11.3">
        <doc xml:whitespace="preserve">Return %TRUE if @feature has been prepared successfully, or %FALSE if
@feature has not been requested, has not been prepared yet, or is not
available on this object at all.

(For instance, if @feature is %TP_CHANNEL_FEATURE_CHAT_STATES and @self
is a #TpChannel in a protocol that doesn't actually implement chat states,
or is not a #TpChannel at all, then this method will return %FALSE.)

To prepare features, call tp_proxy_prepare_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @feature has been prepared successfully</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a feature that is supported by @self's class</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async"
              c:identifier="tp_proxy_prepare_async"
              version="0.11.3">
        <doc xml:whitespace="preserve">#TpProxy itself does not support any features, but subclasses like
#TpChannel can support features, which can either be core functionality like
%TP_CHANNEL_FEATURE_CORE, or extended functionality like
%TP_CHANNEL_FEATURE_CHAT_STATES.

Proxy instances start with no features prepared. When features are
requested via tp_proxy_prepare_async(), the proxy starts to do the
necessary setup to use those features.

tp_proxy_prepare_async() always waits for core functionality of the proxy's
class to be prepared, even if it is not specifically requested: for
instance, because %TP_CHANNEL_FEATURE_CORE is core functionality of a
#TpChannel,

|[
TpChannel *channel = ...;

tp_proxy_prepare_async (channel, NULL, callback, user_data);
]|

is equivalent to

|[
TpChannel *channel = ...;
GQuark features[] = { TP_CHANNEL_FEATURE_CORE, 0 };

tp_proxy_prepare_async (channel, features, callback, user_data);
]|

If a feature represents core functionality (like %TP_CHANNEL_FEATURE_CORE),
failure to prepare it will result in tp_proxy_prepare_async() finishing
unsuccessfully: if failure to prepare the feature indicates that the proxy
is no longer useful, it will also emit #TpProxy::invalidated.

If a feature represents non-essential functionality
(like %TP_CHANNEL_FEATURE_CHAT_STATES), or is not supported by the object
at all, then failure to prepare it is not fatal:
tp_proxy_prepare_async() will complete successfully, but
tp_proxy_is_prepared() will still return %FALSE for the feature, and
accessor methods for the feature will typically return a dummy value.

Some #TpProxy subclasses automatically start to prepare their core
features when instantiated, and features will sometimes become prepared as
a side-effect of other actions, but to ensure that a feature is present you
must generally call tp_proxy_prepare_async() and wait for the result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features, ending with 0; %NULL is equivalent to an array containing only 0</doc>
            <array c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">if not %NULL, called exactly once, when the features have all been prepared or failed to prepare, or after the proxy is invalidated</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish"
              c:identifier="tp_proxy_prepare_finish"
              version="0.11.3"
              throws="1">
        <doc xml:whitespace="preserve">Check for error in a call to tp_proxy_prepare_async(). An error here
generally indicates that either the asynchronous call was cancelled,
or @self has emitted #TpProxy::invalidated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE (setting @error) if tp_proxy_prepare_async() failed or was cancelled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to the callback of tp_proxy_prepare_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="bus-name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus bus name for this object. Read-only except during construction.</doc>
        <type name="utf8"/>
      </property>
      <property name="dbus-connection"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus connection for this object. Read-only except during
construction.</doc>
        <type/>
      </property>
      <property name="dbus-daemon"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus daemon for this object (this object itself, if it is a
TpDBusDaemon). Read-only except during construction.</doc>
        <type name="DBusDaemon"/>
      </property>
      <property name="factory"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpSimpleClientFactory used to create this proxy,
or %NULL if this proxy was not created through a factory.</doc>
        <type name="SimpleClientFactory"/>
      </property>
      <property name="interfaces" transfer-ownership="none">
        <doc xml:whitespace="preserve">Known D-Bus interface names for this object.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="object-path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus object path for this object. Read-only except during
construction.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="dbus_daemon" readable="0" private="1">
        <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
      </field>
      <field name="dbus_connection"
             introspectable="0"
             readable="0"
             private="1">
        <type c:type="DBusGConnection*"/>
      </field>
      <field name="bus_name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="object_path" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="invalidated" readable="0" private="1">
        <type name="GLib.Error" c:type="GError*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyPrivate" c:type="TpProxyPrivate*"/>
      </field>
      <glib:signal name="interface-added"
                   when="last"
                   detailed="1"
                   introspectable="0">
        <doc xml:whitespace="preserve">Emitted when this proxy has gained an interface. It is not guaranteed
to be emitted immediately, but will be emitted before the interface is
first used (at the latest: before it's returned from
tp_proxy_get_interface_by_id(), any signal is connected, or any
method is called).

The intended use is to call dbus_g_proxy_add_signals(). This signal
should only be used by TpProy implementations</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GQuark representing the interface</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:whitespace="preserve">the dbus-glib proxy representing the interface</doc>
            <type/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidated" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when this proxy has been become invalid for
whatever reason. Any more specific signal should be emitted first.

An invalidated proxy is one which can make no more method calls and will
emit no more D-Bus signals. This is typically because the D-Bus object
represented by the proxy ceased to exist, or there was some error
obtaining the initial state.

Any pending or future method calls made on this proxy will fail gracefully
with the same error as returned by tp_proxy_get_invalidated().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">domain of a GError indicating why this proxy was invalidated</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">error code of a GError indicating why this proxy was invalidated</doc>
            <type name="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message associated with the error</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ProxyClass"
            c:type="TpProxyClass"
            glib:is-gtype-struct-for="Proxy"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpProxy. The struct fields not documented here are reserved.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="interface">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="must_have_unique_name" bits="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="_reserved_flags" readable="0" bits="31" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_internal_list_features" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="3">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="ProxyFeature" c:type="TpProxyFeature" version="0.11.3">
      <doc xml:whitespace="preserve">Structure representing a feature.</doc>
      <field name="name" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="core" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="prepare_async" writable="1">
        <type name="ProxyPrepareAsync" c:type="TpProxyPrepareAsync"/>
      </field>
      <field name="prepare_before_signalling_connected_async" writable="1">
        <type name="ProxyPrepareAsync" c:type="TpProxyPrepareAsync"/>
      </field>
      <field name="interfaces_needed" writable="1">
        <type name="GLib.Quark" c:type="const GQuark*"/>
      </field>
      <field name="depends_on" writable="1">
        <type name="GLib.Quark" c:type="const GQuark*"/>
      </field>
      <field name="can_retry" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="4">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyFeaturePrivate" c:type="TpProxyFeaturePrivate*"/>
      </field>
    </record>
    <record name="ProxyFeaturePrivate"
            c:type="TpProxyFeaturePrivate"
            disguised="1">
    </record>
    <record name="ProxyPendingCall" c:type="TpProxyPendingCall" disguised="1">
      <method name="cancel" c:identifier="tp_proxy_pending_call_cancel">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <callback name="ProxyPrepareAsync" c:type="TpProxyPrepareAsync">
      <doc xml:whitespace="preserve">Function called when @feature has to be prepared for @proxy.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="proxy" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object on which @feature has to be prepared</doc>
          <type name="Proxy" c:type="TpProxy*"/>
        </parameter>
        <parameter name="feature" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GQuark representing the feature to prepare</doc>
          <type name="ProxyFeature" c:type="const TpProxyFeature*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="3">
          <doc xml:whitespace="preserve">called when the feature has been prepared, or the preparation failed</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ProxyPrivate" c:type="TpProxyPrivate" disguised="1">
    </record>
    <record name="ProxySignalConnection"
            c:type="TpProxySignalConnection"
            disguised="1">
      <method name="disconnect"
              c:identifier="tp_proxy_signal_connection_disconnect">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="RCPTXRRTTMode" c:type="TpRCPTXRRTTMode">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="all" value="0" c:identifier="TP_RCPT_XR_RTT_MODE_ALL"/>
      <member name="sender"
              value="1"
              c:identifier="TP_RCPT_XR_RTT_MODE_SENDER"/>
    </enumeration>
    <bitfield name="RTCPXRStatisticsFlags" c:type="TpRTCPXRStatisticsFlags">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="loss"
              value="1"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_LOSS"/>
      <member name="duplicate"
              value="2"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_DUPLICATE"/>
      <member name="jitter"
              value="4"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_JITTER"/>
      <member name="ttl"
              value="8"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_TTL"/>
      <member name="hl"
              value="16"
              c:identifier="TP_RTCP_XR_STATISTICS_FLAGS_HL"/>
    </bitfield>
    <enumeration name="RichPresenceAccessControlType"
                 c:type="TpRichPresenceAccessControlType">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A type of access control for Rich_Presence_Access_Control.           For most types, the exact access control is given by an associated           variant.                     These are the access control types from XMPP publish/subscribe           (XEP-0060).                   Location           uses this for historical reasons, new interfaces will use           Access_Control_Type.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="whitelist"
              value="0"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_WHITELIST"/>
      <member name="publish_list"
              value="1"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_PUBLISH_LIST"/>
      <member name="group"
              value="2"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_GROUP"/>
      <member name="open"
              value="3"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_OPEN"/>
    </enumeration>
    <class name="RoomInfo"
           c:symbol-prefix="room_info"
           c:type="TpRoomInfo"
           version="0.19.0"
           parent="GObject.Object"
           glib:type-name="TpRoomInfo"
           glib:get-type="tp_room_info_get_type"
           glib:type-struct="RoomInfoClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpRoomInfo.</doc>
      <method name="get_channel_type"
              c:identifier="tp_room_info_get_channel_type"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string representing the D-Bus interface name of the channel type of the room</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_description"
              c:identifier="tp_room_info_get_description"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a description of the room's overall purpose</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_handle"
              c:identifier="tp_room_info_get_handle"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #TpHandle of the room</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_handle_name"
              c:identifier="tp_room_info_get_handle_name"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the identifier of the room (as would be returned by inspecting the #TpHandle returned by tp_room_info_get_handle())</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_invite_only"
              c:identifier="tp_room_info_get_invite_only"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if you cannot join the room, but must be invited</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="known" transfer-ownership="none">
            <doc xml:whitespace="preserve">either %NULL, or a location in which to store %TRUE if the returned value is meaningful</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_members_count"
              c:identifier="tp_room_info_get_members_count"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of members in the room</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="known" transfer-ownership="none">
            <doc xml:whitespace="preserve">either %NULL, or a location in which to store %TRUE if the returned value is meaningful</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_room_info_get_name"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the human-readable name of the room if different from the handle</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_requires_password"
              c:identifier="tp_room_info_get_requires_password"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the room requires a password to enter</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="known" transfer-ownership="none">
            <doc xml:whitespace="preserve">either %NULL, or a location in which to store %TRUE if the returned value is meaningful</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_room_id"
              c:identifier="tp_room_info_get_room_id"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the human-readable identifier of the room</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_server"
              c:identifier="tp_room_info_get_server"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the DNS name of the server hosting the room</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_subject"
              c:identifier="tp_room_info_get_subject"
              version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current subject of conversation in the room</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="RoomInfoPriv" c:type="TpRoomInfoPriv*"/>
      </field>
    </class>
    <record name="RoomInfoClass"
            c:type="TpRoomInfoClass"
            glib:is-gtype-struct-for="RoomInfo"
            version="0.19.0">
      <doc xml:whitespace="preserve">The class of a #TpRoomInfo.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="RoomInfoPriv" c:type="TpRoomInfoPriv" disguised="1">
    </record>
    <class name="RoomList"
           c:symbol-prefix="room_list"
           c:type="TpRoomList"
           version="0.19.0"
           parent="GObject.Object"
           glib:type-name="TpRoomList"
           glib:get-type="tp_room_list_get_type"
           glib:type-struct="RoomListClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpRoomList.</doc>
      <implements name="Gio.AsyncInitable"/>
      <constructor name="new_finish"
                   c:identifier="tp_room_list_new_finish"
                   version="0.19.0"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpRoomList object, or %NULL in case of error.</doc>
          <type name="RoomList" c:type="TpRoomList*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult from the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async"
                c:identifier="tp_room_list_new_async"
                version="0.19.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount for the room listing</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="server" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DNS name of the server whose rooms should listed</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the initialization is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_account"
              c:identifier="tp_room_list_get_account"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpRoomList:account property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpRoomList:account property</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_server"
              c:identifier="tp_room_list_get_server"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpRoomList:server property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpRoomList:server property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="is_listing"
              c:identifier="tp_room_list_is_listing"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpRoomList:listing property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpRoomList:listing property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="start" c:identifier="tp_room_list_start" version="0.19.0">
        <doc xml:whitespace="preserve">Start listing rooms using @self. Use the TpRoomList::got-rooms
signal to get the rooms found.
Errors will be reported using the TpRoomList::failed signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="account"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccount to use for the room listing.</doc>
        <type name="Account"/>
      </property>
      <property name="listing" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the channel is currently listing rooms.

This property is meaningless until the
%TP_ROOM_LIST_FEATURE_LISTING feature has been prepared.</doc>
        <type name="gboolean"/>
      </property>
      <property name="server"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The DNS name of the server whose rooms are listed by this channel, or
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="RoomListPrivate" c:type="TpRoomListPrivate*"/>
      </field>
      <glib:signal name="failed" when="last" version="0.19.0">
        <doc xml:whitespace="preserve">Fired when something goes wrong while listing the channels; see @error
for details.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GError indicating the reason of the error</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="got-room" when="last" version="0.19.0">
        <doc xml:whitespace="preserve">Fired each time a room is found during the listing process.
User should take his own reference on @room if he plans to
continue using it once the signal callback has returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="room" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpRoomInfo</doc>
            <type name="RoomInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="RoomListClass"
            c:type="TpRoomListClass"
            glib:is-gtype-struct-for="RoomList"
            version="0.19.0">
      <doc xml:whitespace="preserve">The class of a #TpRoomList.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="RoomListPrivate" c:type="TpRoomListPrivate" disguised="1">
    </record>
    <enumeration name="SASLAbortReason" c:type="TpSASLAbortReason">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A reason why SASL authentication was aborted by the client.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="invalid_challenge"
              value="0"
              c:identifier="TP_SASL_ABORT_REASON_INVALID_CHALLENGE"/>
      <member name="user_abort"
              value="1"
              c:identifier="TP_SASL_ABORT_REASON_USER_ABORT"/>
    </enumeration>
    <enumeration name="SASLStatus" c:type="TpSASLStatus">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="not_started"
              value="0"
              c:identifier="TP_SASL_STATUS_NOT_STARTED"/>
      <member name="in_progress"
              value="1"
              c:identifier="TP_SASL_STATUS_IN_PROGRESS"/>
      <member name="server_succeeded"
              value="2"
              c:identifier="TP_SASL_STATUS_SERVER_SUCCEEDED"/>
      <member name="client_accepted"
              value="3"
              c:identifier="TP_SASL_STATUS_CLIENT_ACCEPTED"/>
      <member name="succeeded"
              value="4"
              c:identifier="TP_SASL_STATUS_SUCCEEDED"/>
      <member name="server_failed"
              value="5"
              c:identifier="TP_SASL_STATUS_SERVER_FAILED"/>
      <member name="client_failed"
              value="6"
              c:identifier="TP_SASL_STATUS_CLIENT_FAILED"/>
    </enumeration>
    <enumeration name="SendingState" c:type="TpSendingState">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Enum indicating whether a contact is sending media.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_SENDING_STATE_NONE"/>
      <member name="pending_send"
              value="1"
              c:identifier="TP_SENDING_STATE_PENDING_SEND"/>
      <member name="sending"
              value="2"
              c:identifier="TP_SENDING_STATE_SENDING"/>
      <member name="pending_stop_sending"
              value="3"
              c:identifier="TP_SENDING_STATE_PENDING_STOP_SENDING"/>
    </enumeration>
    <enumeration name="ServicePointType" c:type="TpServicePointType">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The various types of service points a channel might connect to.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="none" value="0" c:identifier="TP_SERVICE_POINT_TYPE_NONE"/>
      <member name="emergency"
              value="1"
              c:identifier="TP_SERVICE_POINT_TYPE_EMERGENCY"/>
      <member name="counseling"
              value="2"
              c:identifier="TP_SERVICE_POINT_TYPE_COUNSELING"/>
    </enumeration>
    <class name="SignalledMessage"
           c:symbol-prefix="signalled_message"
           c:type="TpSignalledMessage"
           version="0.13.9"
           parent="Message"
           glib:type-name="TpSignalledMessage"
           glib:get-type="tp_signalled_message_get_type"
           glib:type-struct="SignalledMessageClass">
      <doc xml:whitespace="preserve">Opaque structure representing a received message using the Telepathy
messages interface</doc>
      <function name="get_sender"
                c:identifier="tp_signalled_message_get_sender"
                version="0.13.9">
        <doc xml:whitespace="preserve">Returns a #TpContact representing the sender of @message if known, %NULL
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the sender of the message</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
        </parameters>
      </function>
      <property name="sender"
                version="0.13.9"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpContact representing the sender of the message, if known, or %NULL
otherwise.</doc>
        <type name="Contact"/>
      </property>
    </class>
    <record name="SignalledMessageClass"
            c:type="TpSignalledMessageClass"
            disguised="1"
            glib:is-gtype-struct-for="SignalledMessage">
    </record>
    <class name="SimpleApprover"
           c:symbol-prefix="simple_approver"
           c:type="TpSimpleApprover"
           version="0.11.5"
           parent="BaseClient"
           glib:type-name="TpSimpleApprover"
           glib:get-type="tp_simple_approver_get_type"
           glib:type-struct="SimpleApproverClass">
      <doc xml:whitespace="preserve">Data structure representing a simple Approver implementation.</doc>
      <constructor name="new"
                   c:identifier="tp_simple_approver_new"
                   version="0.11.5"
                   deprecated="New code should use tp_simple_approver_new_with_am() instead.">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleApprover instance.

If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_approver_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleApprover</doc>
          <type name="SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Approver (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">the function called when AddDispatchOperation is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl"
                  c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleApprover is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am"
                   c:identifier="tp_simple_approver_new_with_am"
                   version="0.11.14">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleApprover instance with a
specified #TpAccountManager.

It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleApprover</doc>
          <type name="SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Approver (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">the function called when AddDispatchOperation is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl"
                  c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleApprover is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_simple_approver_new_with_factory"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleApprover instance with a
specified #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleApprover</doc>
          <type name="SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #TpSimpleClientFactory, which may not be %NULL</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Approver (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">the function called when AddDispatchOperation is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl"
                  c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleApprover is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="callback"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpSimpleApproverAddDispatchOperationImpl callback implementing the
AddDispatchOperation D-Bus method.

This property can't be %NULL.</doc>
        <type name="gpointer"/>
      </property>
      <property name="destroy"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDestroyNotify function called to free #TpSimpleApprover:user-data
when the #TpSimpleApprover is destroyed.</doc>
        <type name="gpointer"/>
      </property>
      <property name="user-data"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-data pointer passed to #TpSimpleApprover:callback.</doc>
        <type name="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleApproverPrivate" c:type="TpSimpleApproverPrivate*"/>
      </field>
    </class>
    <callback name="SimpleApproverAddDispatchOperationImpl"
              c:type="TpSimpleApproverAddDispatchOperationImpl"
              version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the AddDispatchOperation method.

This function must call either tp_add_dispatch_operation_context_accept(),
tp_add_dispatch_operation_context_delay() or
tp_add_dispatch_operation_context_fail() on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="approver" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpSimpleApprover instance</doc>
          <type name="SimpleApprover" c:type="TpSimpleApprover*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, all having %TP_CHANNEL_FEATURE_CORE prepared</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation or %NULL; the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAddDispatchOperationContext representing the context of this D-Bus call</doc>
          <type name="AddDispatchOperationContext"
                c:type="TpAddDispatchOperationContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_simple_approver_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleApproverClass"
            c:type="TpSimpleApproverClass"
            glib:is-gtype-struct-for="SimpleApprover"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpSimpleApprover.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="SimpleApproverPrivate"
            c:type="TpSimpleApproverPrivate"
            disguised="1">
    </record>
    <class name="SimpleClientFactory"
           c:symbol-prefix="simple_client_factory"
           c:type="TpSimpleClientFactory"
           version="0.15.5"
           parent="GObject.Object"
           glib:type-name="TpSimpleClientFactory"
           glib:get-type="tp_simple_client_factory_get_type"
           glib:type-struct="SimpleClientFactoryClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpSimpleClientFactory</doc>
      <constructor name="new"
                   c:identifier="tp_simple_client_factory_new"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Creates a new #TpSimpleClientFactory instance. If @dbus is %NULL,
tp_dbus_daemon_dup() will be used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleClientFactory</doc>
          <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a #TpDBusDaemon, or %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="create_account" introspectable="0" throws="1">
        <return-value>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_channel" introspectable="0" throws="1">
        <return-value>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_connection" introspectable="0" throws="1">
        <return-value>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_contact" introspectable="0">
        <return-value>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_account_features"
                      invoker="dup_account_features"
                      version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpAccount features that
should be prepared on @account.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_channel_features"
                      invoker="dup_channel_features"
                      version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpChannel features that
should be prepared on @channel.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_connection_features"
                      invoker="dup_connection_features"
                      version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpConnection features that
should be prepared on @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_contact_features"
                      invoker="dup_contact_features"
                      version="0.15.5">
        <doc xml:whitespace="preserve">Return a #GArray containing the #TpContactFeature that should be prepared on
all contacts of @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="ContactFeature"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_account_features"
              c:identifier="tp_simple_client_factory_add_account_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add @features to the desired features to be prepared on #TpAccount
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_account_features().

It is not necessary to add %TP_ACCOUNT_FEATURE_CORE as it is already
included by default.

Note that these features will not be added to existing #TpAccount
objects; the user must call tp_proxy_prepare_async() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features, ending with 0; %NULL is equivalent to an array containing only 0</doc>
            <array c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_account_features_varargs"
              c:identifier="tp_simple_client_factory_add_account_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_simple_client_factory_add_account_features(), but with a more
convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features"
              c:identifier="tp_simple_client_factory_add_channel_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add @features to the desired features to be prepared on #TpChannel
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_channel_features().

It is not necessary to add %TP_CHANNEL_FEATURE_CORE as it is already
included by default.

Note that these features will not be added to existing #TpChannel
objects; the user must call tp_proxy_prepare_async() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features, ending with 0; %NULL is equivalent to an array containing only 0</doc>
            <array c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features_varargs"
              c:identifier="tp_simple_client_factory_add_channel_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_simple_client_factory_add_channel_features(), but with a
more convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features"
              c:identifier="tp_simple_client_factory_add_connection_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add @features to the desired features to be prepared on #TpConnection
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_connection_features().

It is not necessary to add %TP_CONNECTION_FEATURE_CORE as it is already
included by default.

Note that these features will not be added to existing #TpConnection
objects; the user must call tp_proxy_prepare_async() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features, ending with 0; %NULL is equivalent to an array containing only 0</doc>
            <array c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features_varargs"
              c:identifier="tp_simple_client_factory_add_connection_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_simple_client_factory_add_connection_features(), but with a
more convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_contact_features"
              c:identifier="tp_simple_client_factory_add_contact_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add @features to the desired features to be prepared on #TpContact
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_contact_features().

Note that these features will not be added to existing #TpContact
objects; the user must call tp_connection_upgrade_contacts() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features (may be %NULL if @n_features is 0)</doc>
            <array length="0" zero-terminated="0" c:type="TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_contact_features_varargs"
              c:identifier="tp_simple_client_factory_add_contact_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_simple_client_factory_add_contact_features(), but with a
more convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="ContactFeature" c:type="TpContactFeature"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="dup_account_features"
              c:identifier="tp_simple_client_factory_dup_account_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpAccount features that
should be prepared on @account.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_channel_features"
              c:identifier="tp_simple_client_factory_dup_channel_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpChannel features that
should be prepared on @channel.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_connection_features"
              c:identifier="tp_simple_client_factory_dup_connection_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpConnection features that
should be prepared on @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_features"
              c:identifier="tp_simple_client_factory_dup_contact_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return a #GArray containing the #TpContactFeature that should be prepared on
all contacts of @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="ContactFeature"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_account"
              c:identifier="tp_simple_client_factory_ensure_account"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Returns a #TpAccount proxy for the account at @object_path. The returned
#TpAccount is cached; the same #TpAccount object will be returned by this
function repeatedly, as long as at least one reference exists.

Note that the returned #TpAccount is not guaranteed to be ready; the caller
is responsible for calling tp_proxy_prepare_async() with the desired
features (as given by tp_simple_client_factory_dup_account_features()).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a #TpAccount; see tp_account_new().</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of an account</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable properties of the account, or %NULL.</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel"
              c:identifier="tp_simple_client_factory_ensure_channel"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Returns a #TpChannel proxy for the channel at @object_path on @connection.
The returned #TpChannel is cached; the same #TpChannel object
will be returned by this function repeatedly, as long as at least one
reference exists.

Note that the returned #TpChannel is not guaranteed to be ready; the
caller is responsible for calling tp_proxy_prepare_async() with the desired
features (as given by tp_simple_client_factory_dup_channel_features()).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a #TpChannel; see tp_channel_new_from_properties().</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of a channel on @connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable properties of the channel</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_connection"
              c:identifier="tp_simple_client_factory_ensure_connection"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Returns a #TpConnection proxy for the connection at @object_path.
The returned #TpConnection is cached; the same #TpConnection object
will be returned by this function repeatedly, as long as at least one
reference exists.

Note that the returned #TpConnection is not guaranteed to be ready; the
caller is responsible for calling tp_proxy_prepare_async() with the desired
features (as given by tp_simple_client_factory_dup_connection_features()).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a #TpConnection; see tp_connection_new().</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of a connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable properties of the connection.</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_contact"
              c:identifier="tp_simple_client_factory_ensure_contact"
              version="0.15.5">
        <doc xml:whitespace="preserve">Returns a #TpContact representing @identifier (and @handle) on @connection.
The returned #TpContact is cached; the same #TpContact object
will be returned by this function repeatedly, as long as at least one
reference exists.

Note that the returned #TpContact is not guaranteed to be ready; the caller
is responsible for calling tp_connection_upgrade_contacts() with the desired
features (as given by tp_simple_client_factory_dup_contact_features()).

For this function to work properly, tp_connection_has_immortal_handles()
must return %TRUE for @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a #TpContact.</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpHandle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string representing the contact's identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_contact_by_id_async"
              c:identifier="tp_simple_client_factory_ensure_contact_by_id_async"
              version="0.19.1">
        <doc xml:whitespace="preserve">Same as tp_connection_dup_contact_by_id_async(), but prepare the
contact with all features previously passed to
tp_simple_client_factory_add_contact_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string representing the contact's identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_contact_by_id_finish"
              c:identifier="tp_simple_client_factory_ensure_contact_by_id_finish"
              version="0.19.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_simple_client_factory_ensure_contact_by_id_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #TpContact or %NULL on error.</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_simple_client_factory_get_dbus_daemon"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpSimpleClientFactory:dbus-daemon property</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="upgrade_contacts_async"
              c:identifier="tp_simple_client_factory_upgrade_contacts_async"
              version="0.19.1">
        <doc xml:whitespace="preserve">Same as tp_connection_upgrade_contacts_async(), but prepare contacts with all
features previously passed to
tp_simple_client_factory_add_contact_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects associated with @self</doc>
            <array length="1" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts_finish"
              c:identifier="tp_simple_client_factory_upgrade_contacts_finish"
              version="0.19.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_simple_client_factory_upgrade_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="contacts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to set a #GPtrArray of upgraded #TpContact, or %NULL.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <property name="dbus-daemon"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus daemon for this object.</doc>
        <type name="DBusDaemon"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleClientFactoryPrivate"
              c:type="TpSimpleClientFactoryPrivate*"/>
      </field>
    </class>
    <record name="SimpleClientFactoryClass"
            c:type="TpSimpleClientFactoryClass"
            glib:is-gtype-struct-for="SimpleClientFactory"
            version="0.15.5">
      <doc xml:whitespace="preserve">The class structure for #TpSimpleClientFactory.

#TpSimpleClientFactory maintains a cache of previously-constructed proxy
objects, so the implementations of @create_account,
@create_connection, @create_channel, and @create_contact may assume that a
new object should be created when they are called. The default
implementations create unadorned instances of the relevant classes;
subclasses of the factory may choose to create more interesting proxy
subclasses.

The default implementation of @dup_channel_features returns
#TP_CHANNEL_FEATURE_CORE, plus all features passed to
tp_simple_client_factory_add_channel_features() by the application.
Subclasses may override this method to prepare more interesting features
from subclasses of #TpChannel, for instance. The default implementations of
the other &lt;function&gt;dup_x_features&lt;/function&gt; methods behave similarly.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="create_account" introspectable="0">
        <callback name="create_account" introspectable="0" throws="1">
          <return-value>
            <type name="Account" c:type="TpAccount*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="immutable_properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="const GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_account_features">
        <callback name="dup_account_features">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Quark"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #TpAccount</doc>
              <type name="Account" c:type="TpAccount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_connection" introspectable="0">
        <callback name="create_connection" introspectable="0" throws="1">
          <return-value>
            <type name="Connection" c:type="TpConnection*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="immutable_properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="const GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_connection_features">
        <callback name="dup_connection_features">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Quark"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #TpConnection</doc>
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_channel" introspectable="0">
        <callback name="create_channel" introspectable="0" throws="1">
          <return-value>
            <type name="Channel" c:type="TpChannel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="immutable_properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="const GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_channel_features">
        <callback name="dup_channel_features">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Quark"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="channel" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #TpChannel</doc>
              <type name="Channel" c:type="TpChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_contact" introspectable="0">
        <callback name="create_contact" introspectable="0">
          <return-value>
            <type name="Contact" c:type="TpContact*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="handle" transfer-ownership="none">
              <type name="Handle" c:type="TpHandle"/>
            </parameter>
            <parameter name="identifier" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_contact_features">
        <callback name="dup_contact_features">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="ContactFeature"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #TpConnection</doc>
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="20">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="SimpleClientFactoryPrivate"
            c:type="TpSimpleClientFactoryPrivate"
            disguised="1">
    </record>
    <class name="SimpleHandler"
           c:symbol-prefix="simple_handler"
           c:type="TpSimpleHandler"
           version="0.11.6"
           parent="BaseClient"
           glib:type-name="TpSimpleHandler"
           glib:get-type="tp_simple_handler_get_type"
           glib:type-struct="SimpleHandlerClass">
      <doc xml:whitespace="preserve">Data structure representing a simple Handler implementation.</doc>
      <constructor name="new"
                   c:identifier="tp_simple_handler_new"
                   version="0.11.6"
                   deprecated="New code should use tp_simple_handler_new_with_am() instead.">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleHandler instance.

If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_handler_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleHandler</doc>
          <type name="SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval D-Bus property (see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether this handler should implement Requests (see tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Handler (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl"
                  c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleHandler is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am"
                   c:identifier="tp_simple_handler_new_with_am"
                   version="0.11.14">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleHandler instance with a
specified #TpAccountManager.

It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleHandler</doc>
          <type name="SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval D-Bus property (see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether this handler should implement Requests (see tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Handler (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl"
                  c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleHandler is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_simple_handler_new_with_factory"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleHandler instance with a
specified #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleHandler</doc>
          <type name="SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSimpleClientFactory, which may not be %NULL</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval D-Bus property (see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether this handler should implement Requests (see tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Handler (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl"
                  c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleHandler is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="bypass-approval"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The value of the Handler.BypassApproval D-Bus property.</doc>
        <type name="gboolean"/>
      </property>
      <property name="callback"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpSimpleHandlerHandleChannelsImpl callback implementing the
HandleChannels D-Bus method.

This property can't be %NULL.</doc>
        <type name="gpointer"/>
      </property>
      <property name="destroy"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDestroyNotify function called to free #TpSimpleHandler:user-data
when the #TpSimpleHandler is destroyed.</doc>
        <type name="gpointer"/>
      </property>
      <property name="requests"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, the Handler will implement the Requests interface</doc>
        <type name="gboolean"/>
      </property>
      <property name="user-data"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-data pointer passed to #TpSimpleHandler:callback.</doc>
        <type name="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleHandlerPrivate" c:type="TpSimpleHandlerPrivate*"/>
      </field>
    </class>
    <record name="SimpleHandlerClass"
            c:type="TpSimpleHandlerClass"
            glib:is-gtype-struct-for="SimpleHandler"
            version="0.11.6">
      <doc xml:whitespace="preserve">The class of a #TpSimpleHandler.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <callback name="SimpleHandlerHandleChannelsImpl"
              c:type="TpSimpleHandlerHandleChannelsImpl"
              version="0.11.6">
      <doc xml:whitespace="preserve">Signature of the implementation of the HandleChannels method.

This function must call either tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpSimpleHandler instance</doc>
          <type name="SimpleHandler" c:type="TpSimpleHandler*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, all having %TP_CHANNEL_FEATURE_CORE prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="requests_satisfied" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time for details)</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpHandleChannelsContext representing the context of this D-Bus call</doc>
          <type name="HandleChannelsContext"
                c:type="TpHandleChannelsContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_simple_handler_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleHandlerPrivate"
            c:type="TpSimpleHandlerPrivate"
            disguised="1">
    </record>
    <class name="SimpleObserver"
           c:symbol-prefix="simple_observer"
           c:type="TpSimpleObserver"
           version="0.11.5"
           parent="BaseClient"
           glib:type-name="TpSimpleObserver"
           glib:get-type="tp_simple_observer_get_type"
           glib:type-struct="SimpleObserverClass">
      <doc xml:whitespace="preserve">Data structure representing a simple Observer implementation.</doc>
      <constructor name="new"
                   c:identifier="tp_simple_observer_new"
                   version="0.11.5"
                   deprecated="New code should use tp_simple_observer_new_with_am() instead.">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleObserver instance.

If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_observer_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleObserver</doc>
          <type name="SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name: property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">the function called when ObserveChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl"
                  c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleObserver is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am"
                   c:identifier="tp_simple_observer_new_with_am"
                   version="0.11.14">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleObserver instance with a
specified #TpAccountManager.

It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleObserver</doc>
          <type name="SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name: property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">the function called when ObserveChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl"
                  c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleObserver is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_simple_observer_new_with_factory"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleObserver instance with a
specified #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleObserver</doc>
          <type name="SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSimpleClientFactory, which may not be %NULL</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name: property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">the function called when ObserveChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl"
                  c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleObserver is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="callback"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The TpSimpleObserverObserveChannelsImpl callback implementing the
ObserveChannels D-Bus method.

This property can't be %NULL.</doc>
        <type name="gpointer"/>
      </property>
      <property name="destroy"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDestroyNotify function called to free the user-data pointer when
the #TpSimpleObserver is destroyed.</doc>
        <type name="gpointer"/>
      </property>
      <property name="recover"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The value of the Observer.Recover D-Bus property.</doc>
        <type name="gboolean"/>
      </property>
      <property name="user-data"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-data pointer passed to the callback implementing the
ObserveChannels D-Bus method.</doc>
        <type name="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleObserverPrivate" c:type="TpSimpleObserverPrivate*"/>
      </field>
    </class>
    <record name="SimpleObserverClass"
            c:type="TpSimpleObserverClass"
            glib:is-gtype-struct-for="SimpleObserver"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpSimpleObserver.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <callback name="SimpleObserverObserveChannelsImpl"
              c:type="TpSimpleObserverObserveChannelsImpl"
              version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the ObserveChannels method.

This function must call either tp_observe_channels_context_accept(),
tp_observe_channels_context_delay() or tp_observe_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="observer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpSimpleObserver instance</doc>
          <type name="SimpleObserver" c:type="TpSimpleObserver*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, all having %TP_CHANNEL_FEATURE_CORE prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation or %NULL; the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="requests" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest, all having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpObserveChannelsContext representing the context of this D-Bus call</doc>
          <type name="ObserveChannelsContext"
                c:type="TpObserveChannelsContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_simple_observer_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleObserverPrivate"
            c:type="TpSimpleObserverPrivate"
            disguised="1">
    </record>
    <enumeration name="SocketAccessControl" c:type="TpSocketAccessControl">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="localhost"
              value="0"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_LOCALHOST"/>
      <member name="port"
              value="1"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_PORT"/>
      <member name="netmask"
              value="2"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_NETMASK"/>
      <member name="credentials"
              value="3"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_CREDENTIALS"/>
    </enumeration>
    <enumeration name="SocketAddressType" c:type="TpSocketAddressType">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unix"
              value="0"
              c:identifier="TP_SOCKET_ADDRESS_TYPE_UNIX"/>
      <member name="abstract_unix"
              value="1"
              c:identifier="TP_SOCKET_ADDRESS_TYPE_ABSTRACT_UNIX"/>
      <member name="ipv4"
              value="2"
              c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV4"/>
      <member name="ipv6"
              value="3"
              c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV6"/>
    </enumeration>
    <bitfield name="StorageRestrictionFlags"
              c:type="TpStorageRestrictionFlags">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Flags indicating restrictions imposed on an Account by its storage         method.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="parameters"
              value="1"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_PARAMETERS"/>
      <member name="enabled"
              value="2"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_ENABLED"/>
      <member name="presence"
              value="4"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_PRESENCE"/>
      <member name="service"
              value="8"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_SERVICE"/>
    </bitfield>
    <enumeration name="StreamComponent" c:type="TpStreamComponent">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Media streams can use more than one UDP socket: one for RTP (data)         and one for RTCP (control). Most of the time, they are adjacent         to each other, but some protocols (xmpp) signal each port separately.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_STREAM_COMPONENT_UNKNOWN"/>
      <member name="data" value="1" c:identifier="TP_STREAM_COMPONENT_DATA"/>
      <member name="control"
              value="2"
              c:identifier="TP_STREAM_COMPONENT_CONTROL"/>
    </enumeration>
    <enumeration name="StreamEndpointState" c:type="TpStreamEndpointState">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Represents the state of ICE negotiation for a single component of a         stream to an endpoint.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="connecting"
              value="0"
              c:identifier="TP_STREAM_ENDPOINT_STATE_CONNECTING"/>
      <member name="provisionally_connected"
              value="1"
              c:identifier="TP_STREAM_ENDPOINT_STATE_PROVISIONALLY_CONNECTED"/>
      <member name="fully_connected"
              value="2"
              c:identifier="TP_STREAM_ENDPOINT_STATE_FULLY_CONNECTED"/>
      <member name="exhausted_candidates"
              value="3"
              c:identifier="TP_STREAM_ENDPOINT_STATE_EXHAUSTED_CANDIDATES"/>
      <member name="failed"
              value="4"
              c:identifier="TP_STREAM_ENDPOINT_STATE_FAILED"/>
    </enumeration>
    <enumeration name="StreamFlowState" c:type="TpStreamFlowState">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The type of SendingState         and ReceivingState.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="stopped"
              value="0"
              c:identifier="TP_STREAM_FLOW_STATE_STOPPED"/>
      <member name="pending_start"
              value="1"
              c:identifier="TP_STREAM_FLOW_STATE_PENDING_START"/>
      <member name="pending_stop"
              value="2"
              c:identifier="TP_STREAM_FLOW_STATE_PENDING_STOP"/>
      <member name="started"
              value="3"
              c:identifier="TP_STREAM_FLOW_STATE_STARTED"/>
    </enumeration>
    <enumeration name="StreamTransportType" c:type="TpStreamTransportType">
      <doc xml:whitespace="preserve">&lt;![CDATA[         A transport that can be used for streaming.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_UNKNOWN"/>
      <member name="raw_udp"
              value="1"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_RAW_UDP"/>
      <member name="ice"
              value="2"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_ICE"/>
      <member name="gtalk_p2p"
              value="3"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_GTALK_P2P"/>
      <member name="wlm_2009"
              value="4"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_WLM_2009"/>
      <member name="shm"
              value="5"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_SHM"/>
      <member name="multicast"
              value="6"
              c:identifier="TP_STREAM_TRANSPORT_TYPE_MULTICAST"/>
    </enumeration>
    <class name="StreamTubeChannel"
           c:symbol-prefix="stream_tube_channel"
           c:type="TpStreamTubeChannel"
           version="0.13.2"
           parent="Channel"
           glib:type-name="TpStreamTubeChannel"
           glib:get-type="tp_stream_tube_channel_get_type"
           glib:type-struct="StreamTubeChannelClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpStreamTubeChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_stream_tube_channel_new"
                   version="0.13.2"
                   deprecated="Use tp_simple_client_factory_ensure_channel() instead."
                   throws="1">
        <doc xml:whitespace="preserve">Creates a new #TpStreamTubeChannel proxy object from the provided path and
properties. Most developers will not need to use this function; use
#TpAutomaticProxyFactory to automatically create #TpStreamTubeChannel proxy
objects.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly-created #TpStreamTubeChannel proxy</doc>
          <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable properties of the channel, as signalled by the NewChannel D-Bus signal or returned by the CreateChannel and EnsureChannel D-Bus methods: a mapping from strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <method name="accept_async"
              c:identifier="tp_stream_tube_channel_accept_async"
              version="0.13.2">
        <doc xml:whitespace="preserve">Accept an incoming stream tube. When the tube has been accepted, @callback
will be called. You can then call tp_stream_tube_channel_accept_finish()
to get a #TpStreamTubeConnection connected to the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the tube has been accepted</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="tp_stream_tube_channel_accept_finish"
              version="0.13.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes accepting an incoming stream tube. The returned
#TpStreamTubeConnection can then be used to exchange data through the tube.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpStreamTubeConnection</doc>
          <type name="StreamTubeConnection" c:type="TpStreamTubeConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_parameters_vardict"
              c:identifier="tp_stream_tube_channel_dup_parameters_vardict"
              version="0.19.10">
        <doc xml:whitespace="preserve">Return the parameters of the dbus-tube channel in a variant of
type %G_VARIANT_TYPE_VARDICT whose keys are strings representing
parameter names and values are variants representing corresponding
parameter values set by the offerer when offering this channel.

The GVariant returned is %NULL if this is an outgoing tube that has not
yet been offered or the parameters property has not been set.

Use g_variant_lookup(), g_variant_lookup_value(), or tp_vardict_get_uint32()
and similar functions for convenient access to the values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to a #GVariant</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_parameters"
              c:identifier="tp_stream_tube_channel_get_parameters"
              version="0.13.2"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeChannel:parameters property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpStreamTubeChannel:parameters</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_service"
              c:identifier="tp_stream_tube_channel_get_service"
              version="0.13.2">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeChannel:service property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpStreamTubeChannel:service</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="offer_async"
              c:identifier="tp_stream_tube_channel_offer_async"
              version="0.13.2">
        <doc xml:whitespace="preserve">Offer an outgoing stream tube. When the tube has been offered, @callback
will be called. You can then call tp_stream_tube_channel_offer_finish()
to get the result of the operation.

You have to connect to the #TpStreamTubeChannel::incoming signal to get a
#TpStreamTubeConnection each time a contact establishes a connection to
the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">parameters of the tube, or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the tube has been offered</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="offer_finish"
              c:identifier="tp_stream_tube_channel_offer_finish"
              version="0.13.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes offering an outgoing stream tube.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE when a Tube has been successfully offered; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="parameters"
                version="0.13.2"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A string to #GValue #GHashTable representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.

In high-level language bindings, use
#TpStreamTubeChannel:parameters-vardict or
tp_stream_tube_channel_dup_parameters_vardict() to get the same
information in a more convenient format.</doc>
        <type/>
      </property>
      <property name="parameters-vardict"
                version="0.19.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A %G_VARIANT_TYPE_VARDICT representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="service" version="0.13.2" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string representing the service name that will be used over the tube.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="StreamTubeChannelPrivate"
              c:type="TpStreamTubeChannelPrivate*"/>
      </field>
      <glib:signal name="incoming" when="last">
        <doc xml:whitespace="preserve">The ::incoming signal is emitted on offered Tubes when a new incoming
connection is made from a remote user (one accepting the Tube).

Consumers of this signal must take their own references to
@tube_connection</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="tube_connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpStreamTubeConnection for the connection</doc>
            <type name="StreamTubeConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="StreamTubeChannelClass"
            c:type="TpStreamTubeChannelClass"
            glib:is-gtype-struct-for="StreamTubeChannel"
            version="0.13.2">
      <doc xml:whitespace="preserve">The class of a #TpStreamTubeChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="StreamTubeChannelPrivate"
            c:type="TpStreamTubeChannelPrivate"
            disguised="1">
    </record>
    <class name="StreamTubeConnection"
           c:symbol-prefix="stream_tube_connection"
           c:type="TpStreamTubeConnection"
           version="0.13.2"
           parent="GObject.Object"
           glib:type-name="TpStreamTubeConnection"
           glib:get-type="tp_stream_tube_connection_get_type"
           glib:type-struct="StreamTubeConnectionClass">
      <doc xml:whitespace="preserve">Data structure representing a connection on a #TpStreamTubeChannel.</doc>
      <method name="get_channel"
              c:identifier="tp_stream_tube_connection_get_channel"
              version="0.13.2">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeConnection:channel property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpStreamTubeConnection:channel</doc>
          <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
        </return-value>
      </method>
      <method name="get_contact"
              c:identifier="tp_stream_tube_connection_get_contact"
              version="0.13.2">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeConnection:contact property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpStreamTubeConnection:contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="get_socket_connection"
              c:identifier="tp_stream_tube_connection_get_socket_connection"
              version="0.13.2">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeConnection:socket-connection property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpStreamTubeConnection:socket-connection</doc>
          <type name="Gio.SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
      </method>
      <property name="channel"
                version="0.13.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpStreamTubeChannel channel associated with this connection

This property can't be %NULL.</doc>
        <type name="StreamTubeChannel"/>
      </property>
      <property name="contact"
                version="0.13.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpContact with who we are exchanging data through this tube, or
%NULL if we can't safely identify the contact.

If not %NULL, the #TpContact objects is guaranteed to have all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <type name="Contact"/>
      </property>
      <property name="socket-connection"
                version="0.13.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GSocketConnection used to transfer data through this connection.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Gio.SocketConnection"/>
      </property>
      <glib:signal name="closed" when="last" version="0.13.2">
        <doc xml:whitespace="preserve">The ::closed signal is emitted when the connection manager reports that
a tube connection has been closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GError representing the error reported by the connection manager</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="StreamTubeConnectionClass"
            c:type="TpStreamTubeConnectionClass"
            disguised="1"
            glib:is-gtype-struct-for="StreamTubeConnection"
            version="0.13.2">
      <doc xml:whitespace="preserve">The class of a #TpStreamTubeConnection.</doc>
    </record>
    <record name="StreamTubeConnectionPrivate"
            c:type="TpStreamTubeConnectionPrivate"
            disguised="1">
    </record>
    <enumeration name="SubscriptionState" c:type="TpSubscriptionState">
      <doc xml:whitespace="preserve">&lt;![CDATA[         An enumeration indicating whether presence subscription is denied,           denied but pending permission, or allowed. The exact semantics           vary according to where this type is used: see the           subscribe and           publish contact attributes for           details.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_SUBSCRIPTION_STATE_UNKNOWN"/>
      <member name="no" value="1" c:identifier="TP_SUBSCRIPTION_STATE_NO"/>
      <member name="removed_remotely"
              value="2"
              c:identifier="TP_SUBSCRIPTION_STATE_REMOVED_REMOTELY"/>
      <member name="ask" value="3" c:identifier="TP_SUBSCRIPTION_STATE_ASK"/>
      <member name="yes" value="4" c:identifier="TP_SUBSCRIPTION_STATE_YES"/>
    </enumeration>
    <class name="TLSCertificate"
           c:symbol-prefix="tls_certificate"
           c:type="TpTLSCertificate"
           version="0.19.0"
           parent="Proxy"
           glib:type-name="TpTLSCertificate"
           glib:get-type="tp_tls_certificate_get_type"
           glib:type-struct="TLSCertificateClass">
      <doc xml:whitespace="preserve">A #TpProxy subclass representing a server or peer's TLS certificate
being presented for acceptance/rejection.</doc>
      <constructor name="new"
                   c:identifier="tp_tls_certificate_new"
                   version="0.19.0"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new TLS certificate proxy. Prepare the feature %TP_TLS_CERTIFICATE_FEATURE_CORE to make it useful.</doc>
          <type name="TLSCertificate" c:type="TpTLSCertificate*"/>
        </return-value>
        <parameters>
          <parameter name="conn_or_chan" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection or #TpChannel parent for this object, whose invalidation will also result in invalidation of the returned object</doc>
            <type name="Proxy" c:type="TpProxy*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of this TLS certificate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_tls_certificate_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_tls_certificate_init_known_interfaces"
                version="0.19.0">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpTLSCertificate have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_TLS_CERTIFICATE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="accept_async"
              c:identifier="tp_tls_certificate_accept_async"
              version="0.19.0">
        <doc xml:whitespace="preserve">Accept this certificate, asynchronously. In or after @callback,
you may call tp_tls_certificate_accept_finish() to check the result.

#GObject::notify::state will also be emitted when the connection manager
signals that the certificate has been accepted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">called on success or failure</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="tp_tls_certificate_accept_finish"
              version="0.19.0"
              throws="1">
        <doc xml:whitespace="preserve">Check the result of tp_tls_certificate_accept_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if acceptance was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to the callback by tp_tls_certificate_accept_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_rejection"
              c:identifier="tp_tls_certificate_add_rejection"
              version="0.19.0">
        <doc xml:whitespace="preserve">Add a pending reason for rejection. The first call to this method is
considered "most important". After calling this method as many times
as are required, call tp_tls_certificate_reject_async() to reject the
certificate.

If @details is a floating reference (see g_variant_ref_sink()),
ownership of @details is taken by this function. This means
you can pass the result of g_variant_new() or g_variant_new_parsed()
directly to this function without additional reference-count management.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the reason for rejection</doc>
            <type name="TLSCertificateRejectReason"
                  c:type="TpTLSCertificateRejectReason"/>
          </parameter>
          <parameter name="dbus_error" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus error name such as %TP_ERROR_STR_CERT_REVOKED, or %NULL to derive one from @reason</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a variant of type %G_VARIANT_TYPE_VARDICT containing the details of the rejection, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cert_data"
              c:identifier="tp_tls_certificate_get_cert_data"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpTLSCertificate:cert-data property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTLSCertificate:cert-data property</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="GLib.Bytes"/>
          </array>
        </return-value>
      </method>
      <method name="get_cert_type"
              c:identifier="tp_tls_certificate_get_cert_type"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpTLSCertificate:cert-type property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTLSCertificate:cert-type property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_nth_rejection"
              c:identifier="tp_tls_certificate_get_nth_rejection"
              version="0.19.0">
        <doc xml:whitespace="preserve">If this certificate has been rejected and @n is less than the number of
rejection reasons, return a #TpTLSCertificateRejection representing the
@n&lt;!----&gt;th rejection reason (starting from 0).

With @n == 0 this is equivalent to tp_tls_certificate_get_rejection().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpTLSCertificateRejection, or %NULL</doc>
          <type name="TLSCertificateRejection"
                c:type="TpTLSCertificateRejection*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rejection reason to return; if 0, return the same thing as tp_tls_certificate_get_detailed_rejection()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_rejection"
              c:identifier="tp_tls_certificate_get_rejection"
              version="0.19.0">
        <doc xml:whitespace="preserve">If this certificate has been rejected, return a #TpTLSCertificateRejection
indicating the first rejection reason (by convention,
the most important).

If you want to list all the things that are wrong with the certificate
(for instance, it might be self-signed and also have expired)
you can call tp_tls_certificate_get_nth_rejection(), increasing @n until
it returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpTLSCertificateRejection, or %NULL</doc>
          <type name="TLSCertificateRejection"
                c:type="TpTLSCertificateRejection*"/>
        </return-value>
      </method>
      <method name="get_state"
              c:identifier="tp_tls_certificate_get_state"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpTLSCertificate:state property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTLSCertificate:state property</doc>
          <type name="TLSCertificateState" c:type="TpTLSCertificateState"/>
        </return-value>
      </method>
      <method name="reject_async"
              c:identifier="tp_tls_certificate_reject_async"
              version="0.19.0">
        <doc xml:whitespace="preserve">Reject this certificate, asynchronously.

Before calling this method, you must call
tp_tls_certificate_add_rejection() at least once, to set the reason(s)
for rejection (for instance, a certificate might be both self-signed and
expired).

In or after @callback,
you may call tp_tls_certificate_reject_finish() to check the result.

#GObject::notify::state will also be emitted when the connection manager
signals that the certificate has been rejected.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">called on success or failure</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reject_finish"
              c:identifier="tp_tls_certificate_reject_finish"
              version="0.19.0"
              throws="1">
        <doc xml:whitespace="preserve">Check the result of tp_tls_certificate_reject_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if rejection was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to the callback by tp_tls_certificate_reject_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="cert-data" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The raw data of the certificate or certificate chain, represented
as a #GPtrArray of #GBytes. It should be interpreted
according to #TpTLSCertificate:cert-type.

The first certificate in this array is the server's certificate,
followed by its issuer, followed by the issuer's issuer and so on.

For "x509" certificates, each certificate is an X.509 certificate in
binary (DER) format.

For "pgp" certificates, each certificate is a binary OpenPGP key.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="cert-type" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The type of the certificate, typically either "x509" or "pgp".</doc>
        <type name="utf8"/>
      </property>
      <property name="parent"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection or #TpChannel which owns this TLS certificate. If the
parent object is invalidated, the certificate is also invalidated, and
this property is set to %NULL.</doc>
        <type name="Proxy"/>
      </property>
      <property name="state" version="0.19.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The state of this TLS certificate as a #TpTLSCertificateState,
initially %TP_TLS_CERTIFICATE_STATE_PENDING.

#GObject::notify::state will be emitted when this changes.</doc>
        <type name="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TLSCertificatePrivate" c:type="TpTLSCertificatePrivate*"/>
      </field>
    </class>
    <record name="TLSCertificateClass"
            c:type="TpTLSCertificateClass"
            glib:is-gtype-struct-for="TLSCertificate"
            version="0.19.0">
      <doc xml:whitespace="preserve">The class of a #TpTLSCertificate.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_future" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="3">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TLSCertificateClassPrivate"
              c:type="TpTLSCertificateClassPrivate*"/>
      </field>
    </record>
    <record name="TLSCertificateClassPrivate"
            c:type="TpTLSCertificateClassPrivate"
            disguised="1">
    </record>
    <record name="TLSCertificatePrivate"
            c:type="TpTLSCertificatePrivate"
            disguised="1">
    </record>
    <enumeration name="TLSCertificateRejectReason"
                 c:type="TpTLSCertificateRejectReason">
      <doc xml:whitespace="preserve">&lt;![CDATA[         Possible reasons to reject a TLS certificate.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="unknown"
              value="0"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_UNKNOWN"/>
      <member name="untrusted"
              value="1"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_UNTRUSTED"/>
      <member name="expired"
              value="2"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_EXPIRED"/>
      <member name="not_activated"
              value="3"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_NOT_ACTIVATED"/>
      <member name="fingerprint_mismatch"
              value="4"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_FINGERPRINT_MISMATCH"/>
      <member name="hostname_mismatch"
              value="5"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_HOSTNAME_MISMATCH"/>
      <member name="self_signed"
              value="6"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_SELF_SIGNED"/>
      <member name="revoked"
              value="7"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_REVOKED"/>
      <member name="insecure"
              value="8"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_INSECURE"/>
      <member name="limit_exceeded"
              value="9"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_LIMIT_EXCEEDED"/>
    </enumeration>
    <class name="TLSCertificateRejection"
           c:symbol-prefix="tls_certificate_rejection"
           c:type="TpTLSCertificateRejection"
           version="0.19.0"
           parent="GObject.Object"
           glib:type-name="TpTLSCertificateRejection"
           glib:get-type="tp_tls_certificate_rejection_get_type"
           glib:type-struct="TLSCertificateRejectionClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpTLSCertificateRejection.</doc>
      <method name="get_dbus_error"
              c:identifier="tp_tls_certificate_rejection_get_dbus_error"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpTLSCertificateRejection:dbus-error property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTLSCertificateRejection:dbus-error property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_details"
              c:identifier="tp_tls_certificate_rejection_get_details"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpTLSCertificateRejection:details property</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the value of #TpTLSCertificateRejection:details property</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_error"
              c:identifier="tp_tls_certificate_rejection_get_error"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpTLSCertificateRejection:error property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTLSCertificateRejection:error property</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </return-value>
      </method>
      <method name="get_reason"
              c:identifier="tp_tls_certificate_rejection_get_reason"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the #TpTLSCertificateRejection:reason property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTLSCertificateRejection:reason property</doc>
          <type name="TLSCertificateRejectReason"
                c:type="TpTLSCertificateRejectReason"/>
        </return-value>
      </method>
      <method name="raise_error"
              c:identifier="tp_tls_certificate_rejection_raise_error"
              version="0.19.0"
              throws="1">
        <doc xml:whitespace="preserve">Convenient function to raise the #TpTLSCertificateRejection:error
property in language binding supporting this feature.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="dbus-error"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus error name of the rejection</doc>
        <type name="utf8"/>
      </property>
      <property name="details"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #G_VARIANT_TYPE_VARDICT containing the details of the rejection</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="error"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GError (likely to be in the %TP_ERROR domain) indicating the reason
of the rejection</doc>
        <type name="GLib.Error"/>
      </property>
      <property name="reason"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">#TpTLSCertificateRejectReason representing the reason of the rejection</doc>
        <type name="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TLSCertificateRejectionPriv"
              c:type="TpTLSCertificateRejectionPriv*"/>
      </field>
    </class>
    <record name="TLSCertificateRejectionClass"
            c:type="TpTLSCertificateRejectionClass"
            glib:is-gtype-struct-for="TLSCertificateRejection"
            version="0.19.0">
      <doc xml:whitespace="preserve">The class of a #TpTLSCertificateRejection.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="TLSCertificateRejectionPriv"
            c:type="TpTLSCertificateRejectionPriv"
            disguised="1">
    </record>
    <enumeration name="TLSCertificateState" c:type="TpTLSCertificateState">
      <doc xml:whitespace="preserve">&lt;![CDATA[         The possible states for a TLSCertificate         object.       ]]&gt;

Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="pending"
              value="0"
              c:identifier="TP_TLS_CERTIFICATE_STATE_PENDING"/>
      <member name="accepted"
              value="1"
              c:identifier="TP_TLS_CERTIFICATE_STATE_ACCEPTED"/>
      <member name="rejected"
              value="2"
              c:identifier="TP_TLS_CERTIFICATE_STATE_REJECTED"/>
    </enumeration>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_GTALK_P2P"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/gtalk-p2p"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_GTALK_P2P">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_ICE_UDP"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/ice-udp"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_ICE_UDP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_2009"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/wlm-2009"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_2009">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_8_5"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/wlm-8.5"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_8_5">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_AUDIO"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/audio"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_AUDIO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_GTALK_P2P"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/gtalk-p2p"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_GTALK_P2P">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_ICE"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/ice"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_ICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_SHM"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/shm"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_SHM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_VIDEO"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/video"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_VIDEO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_TYPE_CALL_WLM_2009"
              value="org.freedesktop.Telepathy.Channel.Type.Call1/wlm-2009"
              c:type="TP_TOKEN_CHANNEL_TYPE_CALL_WLM_2009">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_CONTACT_ID"
              value="org.freedesktop.Telepathy.Connection/contact-id"
              c:type="TP_TOKEN_CONNECTION_CONTACT_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_ADDRESSING_ADDRESSES"
              value="org.freedesktop.Telepathy.Connection.Interface.Addressing1/addresses"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_ADDRESSING_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_ADDRESSING_URIS"
              value="org.freedesktop.Telepathy.Connection.Interface.Addressing1/uris"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_ADDRESSING_URIS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_ALIASING_ALIAS"
              value="org.freedesktop.Telepathy.Connection.Interface.Aliasing/alias"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_ALIASING_ALIAS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_AVATARS_TOKEN"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars/token"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_AVATARS_TOKEN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CAPABILITIES_CAPS"
              value="org.freedesktop.Telepathy.Connection.Interface.Capabilities/caps"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CAPABILITIES_CAPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CLIENT_TYPES_CLIENT_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.ClientTypes/client-types"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CLIENT_TYPES_CLIENT_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_BLOCKING_BLOCKED"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactBlocking/blocked"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_BLOCKING_BLOCKED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_CAPABILITIES_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities/capabilities"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_CAPABILITIES_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups/groups"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_INFO_INFO"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo/info"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_INFO_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList/publish"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH_REQUEST"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList/publish-request"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH_REQUEST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_SUBSCRIBE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList/subscribe"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_SUBSCRIBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_LOCATION_LOCATION"
              value="org.freedesktop.Telepathy.Connection.Interface.Location/location"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_LOCATION_LOCATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_SIMPLE_PRESENCE_PRESENCE"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence/presence"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_SIMPLE_PRESENCE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="TextChannel"
           c:symbol-prefix="text_channel"
           c:type="TpTextChannel"
           version="0.13.10"
           parent="Channel"
           glib:type-name="TpTextChannel"
           glib:get-type="tp_text_channel_get_type"
           glib:type-struct="TextChannelClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpTextChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_text_channel_new"
                   version="0.13.10"
                   deprecated="Use tp_simple_client_factory_ensure_channel() instead."
                   throws="1">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpTextChannel</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpTextChannel</doc>
          <type name="TextChannel" c:type="TpTextChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable properties of the channel, as signalled by the NewChannel D-Bus signal or returned by the CreateChannel and EnsureChannel D-Bus methods: a mapping from strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="const GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_chat_states"
                c:identifier="tp_text_channel_get_feature_quark_chat_states">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_incoming_messages"
                c:identifier="tp_text_channel_get_feature_quark_incoming_messages">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_sms"
                c:identifier="tp_text_channel_get_feature_quark_sms">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="ack_all_pending_messages_async"
              c:identifier="tp_text_channel_ack_all_pending_messages_async"
              version="0.15.3">
        <doc xml:whitespace="preserve">Acknowledge all the pending messages. This is equivalent of calling
tp_text_channel_ack_messages_async() with the list of #TpSignalledMessage
returned by tp_text_channel_dup_pending_messages().

Once the messages have been acked, @callback will be called.
You can then call tp_text_channel_ack_all_pending_messages_finish() to get
the result of the operation.

See tp_text_channel_ack_message_async() about acknowledging messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the messages have been acked</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_all_pending_messages_finish"
              c:identifier="tp_text_channel_ack_all_pending_messages_finish"
              version="0.15.3"
              throws="1">
        <doc xml:whitespace="preserve">Finish an asynchronous acknowledgement operation of all messages.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the messages have been acked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_message_async"
              c:identifier="tp_text_channel_ack_message_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Acknowledge @message. Once the message has been acked, @callback will be
called. You can then call tp_text_channel_ack_message_finish() to get the
result of the operation.

A message should be acknowledged once it has been shown to the user by the
Handler of the channel. So Observers and Approvers should NOT acknowledge
messages themselves.
Once a message has been acknowledged, it is removed from the
pending-message queue and so the #TpTextChannel::pending-message-removed
signal is fired.

You should use the #TpSignalledMessage received from
tp_text_channel_dup_pending_messages() or the
#TpTextChannel::message-received signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the message have been acked</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_message_finish"
              c:identifier="tp_text_channel_ack_message_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Finishes acknowledging a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message has been acked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult passed to the callback for tp_text_channel_ack_message_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_messages_async"
              c:identifier="tp_text_channel_ack_messages_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Acknowledge all the messages in @messages.
Once the messages have been acked, @callback will be called.
You can then call tp_text_channel_ack_messages_finish() to get the
result of the operation.

You should use the #TpSignalledMessage received from
tp_text_channel_dup_pending_messages() or the
#TpTextChannel::message-received signal.

See tp_text_channel_ack_message_async() about acknowledging messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpSignalledMessage</doc>
            <type name="GLib.List" c:type="const GList*">
              <type name="SignalledMessage"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the message have been acked</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_messages_finish"
              c:identifier="tp_text_channel_ack_messages_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Finishes acknowledging a list of messages.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the messages have been acked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult passed to the callback for tp_text_channel_ack_messages_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_pending_messages"
              c:identifier="tp_text_channel_dup_pending_messages"
              version="0.19.9">
        <doc xml:whitespace="preserve">Return a newly allocated list of unacknowledged #TpSignalledMessage
objects.

It is guaranteed that the #TpSignalledMessage:sender of each
#TpSignalledMessage has all of the features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of reffed #TpSignalledMessage</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SignalledMessage"/>
          </type>
        </return-value>
      </method>
      <method name="get_chat_state"
              c:identifier="tp_text_channel_get_chat_state"
              version="0.19.0">
        <doc xml:whitespace="preserve">Return the chat state for the given contact. If tp_proxy_is_prepared()
would return %FALSE for the feature %TP_TEXT_CHANNEL_FEATURE_CHAT_STATES,
the result will always be %TP_CHANNEL_CHAT_STATE_INACTIVE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the chat state for @contact, or %TP_CHANNEL_CHAT_STATE_INACTIVE if their chat state is not known</doc>
          <type name="ChannelChatState" c:type="TpChannelChatState"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpContact</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_delivery_reporting_support"
              c:identifier="tp_text_channel_get_delivery_reporting_support"
              version="0.13.10">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:delivery-reporting-support property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:delivery-reporting-support property</doc>
          <type name="DeliveryReportingSupportFlags"
                c:type="TpDeliveryReportingSupportFlags"/>
        </return-value>
      </method>
      <method name="get_message_part_support_flags"
              c:identifier="tp_text_channel_get_message_part_support_flags"
              version="0.13.10">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:message-part-support-flags property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:message-part-support-flags</doc>
          <type name="MessagePartSupportFlags"
                c:type="TpMessagePartSupportFlags"/>
        </return-value>
      </method>
      <method name="get_message_types"
              c:identifier="tp_text_channel_get_message_types"
              version="0.13.16">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:message-types property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:message-types</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="ChannelTextMessageType"/>
          </array>
        </return-value>
      </method>
      <method name="get_pending_messages"
              c:identifier="tp_text_channel_get_pending_messages"
              version="0.13.10"
              deprecated="Since 0.19.9. New code should use tp_text_channel_dup_pending_messages() instead.">
        <doc xml:whitespace="preserve">Return a newly allocated list of unacknowledged #TpSignalledMessage
objects.

It is guaranteed that the #TpSignalledMessage:sender of each
#TpSignalledMessage has all of the features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a #GList of borrowed #TpSignalledMessage</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SignalledMessage"/>
          </type>
        </return-value>
      </method>
      <method name="get_sms_flash"
              c:identifier="tp_text_channel_get_sms_flash"
              version="0.15.1">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:sms-flash property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:sms-flash property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_sms_length_async"
              c:identifier="tp_text_channel_get_sms_length_async"
              version="0.15.1">
        <doc xml:whitespace="preserve">Starts an async call to get the number of 140 octet chunks required to
send a #message via SMS on #self, as well as the number of remaining
characters available in the final chunk and, if possible,
an estimate of the cost.

Once the request has been satisfied, @callback will be called.
You can then call tp_text_channel_get_sms_length_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpClientMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sms_length_finish"
              c:identifier="tp_text_channel_get_sms_length_finish"
              version="0.15.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async SMS length request.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the number of 140 octet chunks required to send the message has been retrieved, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="chunks_required"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL used to return the number of 140 octet chunks required to send the message.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="remaining_characters"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL used to return the number of further characters that can be fit in the final chunk. A negative value indicates that the message will be truncated by abs(@remaining_characters). The value #G_MININT32 indicates the message will be truncated by an unknown amount.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="estimated_cost"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL used to return the estimated cost of sending this message. The currency and scale of this value are the same as the values of the #TpConnection:balance-scale and #TpConnection:balance-currency properties. A value of -1 indicates the cost could not be estimated.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_supported_content_types"
              c:identifier="tp_text_channel_get_supported_content_types"
              version="0.13.10">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:supported-content-types property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:supported-content-types</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="is_sms_channel"
              c:identifier="tp_text_channel_is_sms_channel"
              version="0.15.1">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:is-sms-channel property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:is-sms-channel property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="send_message_async"
              c:identifier="tp_text_channel_send_message_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Submit a message to the server for sending. Once the message has been
submitted to the sever, @callback will be called. You can then call
tp_text_channel_send_message_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpClientMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting how the message is sent</doc>
            <type name="MessageSendingFlags" c:type="TpMessageSendingFlags"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the message has been submitted to the server</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_finish"
              c:identifier="tp_text_channel_send_message_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Completes a call to tp_text_channel_send_message_async().

@token can be used to match any incoming delivery or failure reports
against the sent message. If this function returns true but the returned
token is %NULL, the message was sent successfully but the protocol does not
provide a way to identify it later.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message has been submitted to the server, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult passed to the callback for tp_text_channel_send_message_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="token"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return the token of the sent message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chat_state_async"
              c:identifier="tp_text_channel_set_chat_state_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Set the local state on channel @self to @state.
Once the state has been set, @callback will be called.
You can then call tp_text_channel_set_chat_state_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannelChatState to set</doc>
            <type name="ChannelChatState" c:type="TpChannelChatState"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the chat state has been set</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chat_state_finish"
              c:identifier="tp_text_channel_set_chat_state_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Completes a call to tp_text_channel_set_chat_state_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the chat state has been changed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult passed to the callback for tp_text_channel_set_chat_state_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_message_type"
              c:identifier="tp_text_channel_supports_message_type"
              version="0.13.16">
        <doc xml:whitespace="preserve">Check if message of type @message_type can be sent on this channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if message of type @message_type can be sent on @self, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannelTextMessageType</doc>
            <type name="ChannelTextMessageType"
                  c:type="TpChannelTextMessageType"/>
          </parameter>
        </parameters>
      </method>
      <property name="delivery-reporting-support"
                version="0.13.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpDeliveryReportingSupportFlags indicating features supported
by this channel.</doc>
        <type name="guint"/>
      </property>
      <property name="is-sms-channel"
                version="0.15.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if messages sent and received on this channel are transmitted
via SMS.

This property is not guaranteed to have a meaningful value until
TP_TEXT_CHANNEL_FEATURE_SMS has been prepared.</doc>
        <type name="gboolean"/>
      </property>
      <property name="message-part-support-flags"
                version="0.13.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpMessagePartSupportFlags indicating the level of support for
message parts on this channel.</doc>
        <type name="guint"/>
      </property>
      <property name="message-types"
                version="0.13.16"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GArray containing the #TpChannelTextMessageType which may be sent on
this channel.</doc>
        <type/>
      </property>
      <property name="sms-flash" version="0.15.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if this channel is exclusively for receiving class 0 SMSes
(and no SMSes can be sent using tp_text_channel_send_message_async()
on this channel). If %FALSE, no incoming class 0 SMSes will appear
on this channel.</doc>
        <type name="gboolean"/>
      </property>
      <property name="supported-content-types"
                version="0.13.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GStrv containing the MIME types supported by this channel, with more
preferred MIME types appearing earlier in the array.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TextChannelPrivate" c:type="TpTextChannelPrivate*"/>
      </field>
      <glib:signal name="contact-chat-state-changed"
                   when="last"
                   detailed="1"
                   version="0.19.0">
        <doc xml:whitespace="preserve">Emitted when a contact's chat state changes after tp_proxy_prepare_async()
has finished preparing features %TP_TEXT_CHANNEL_FEATURE_CHAT_STATES,
%TP_CHANNEL_FEATURE_GROUP and %TP_CHANNEL_FEATURE_CONTACTS.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpContact for the local user or another contact</doc>
            <type name="Contact"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new #TpChannelChatState for the contact</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="message-received" when="last" version="0.13.10">
        <doc xml:whitespace="preserve">The ::message-received signal is emitted when a new message has been
received on @self.

The same @message object will be used by the
#TpTextChannel::pending-message-removed signal once @message has been
acked so you can simply compare pointers to identify the message.

Note that this signal is only fired once the
#TP_TEXT_CHANNEL_FEATURE_INCOMING_MESSAGES has been prepared.

It is guaranteed that @message's #TpSignalledMessage:sender has all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="SignalledMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="message-sent" when="last" version="0.13.10">
        <doc xml:whitespace="preserve">The ::message-sent signal is emitted when @message
has been submitted for sending.

It is guaranteed that @message's #TpSignalledMessage:sender has all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="SignalledMessage"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpMessageSendingFlags affecting how the message was sent</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">an opaque token used to match any incoming delivery or failure reports against this message, or %NULL if the message is not readily identifiable.</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="pending-message-removed"
                   when="last"
                   version="0.13.10">
        <doc xml:whitespace="preserve">The ::pending-message-removed signal is emitted when @message
has been acked and so removed from the pending messages list.

Note that this signal is only fired once the
#TP_TEXT_CHANNEL_FEATURE_INCOMING_MESSAGES has been prepared.

It is guaranteed that @message's #TpSignalledMessage:sender has all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="SignalledMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="TextChannelClass"
            c:type="TpTextChannelClass"
            glib:is-gtype-struct-for="TextChannel"
            version="0.13.10">
      <doc xml:whitespace="preserve">The class of a #TpTextChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="TextChannelPrivate"
            c:type="TpTextChannelPrivate"
            disguised="1">
    </record>
    <enumeration name="TubeChannelState" c:type="TpTubeChannelState">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local_pending"
              value="0"
              c:identifier="TP_TUBE_CHANNEL_STATE_LOCAL_PENDING"/>
      <member name="remote_pending"
              value="1"
              c:identifier="TP_TUBE_CHANNEL_STATE_REMOTE_PENDING"/>
      <member name="open" value="2" c:identifier="TP_TUBE_CHANNEL_STATE_OPEN"/>
      <member name="not_offered"
              value="3"
              c:identifier="TP_TUBE_CHANNEL_STATE_NOT_OFFERED"/>
    </enumeration>
    <enumeration name="TubeState" c:type="TpTubeState">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="local_pending"
              value="0"
              c:identifier="TP_TUBE_STATE_LOCAL_PENDING"/>
      <member name="remote_pending"
              value="1"
              c:identifier="TP_TUBE_STATE_REMOTE_PENDING"/>
      <member name="open" value="2" c:identifier="TP_TUBE_STATE_OPEN"/>
    </enumeration>
    <enumeration name="TubeType" c:type="TpTubeType">
      <doc xml:whitespace="preserve">Bitfield/set of flags generated from the Telepathy specification.</doc>
      <member name="dbus" value="0" c:identifier="TP_TUBE_TYPE_DBUS"/>
      <member name="stream" value="1" c:identifier="TP_TUBE_TYPE_STREAM"/>
    </enumeration>
    <constant name="UNKNOWN_CONNECTION_STATUS"
              value="-1"
              c:type="TP_UNKNOWN_CONNECTION_STATUS">
      <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
    </constant>
    <constant name="UNKNOWN_HANDLE_TYPE"
              value="-1"
              c:type="TP_UNKNOWN_HANDLE_TYPE">
      <type name="HandleType" c:type="TpHandleType"/>
    </constant>
    <constant name="USER_ACTION_TIME_NOT_USER_ACTION"
              value="0"
              c:type="TP_USER_ACTION_TIME_NOT_USER_ACTION">
      <type name="gint64" c:type="gint64"/>
    </constant>
    <record name="WeakRef" c:type="TpWeakRef" disguised="1" version="0.11.3">
      <doc xml:whitespace="preserve">A simple wrapper for a weak reference to a #GObject, suitable for use in
asynchronous calls which should only affect the object if it hasn't already
been freed.

As well as wrapping a weak reference to an object, this structure can
contain an extra pointer to arbitrary data. This is useful for asynchronous
calls which act on an object and some second piece of data, which are quite
common in practice.

If more than one piece of auxiliary data is required, the @user_data
argument to the constructor can be a struct or a #GValueArray.</doc>
      <method name="destroy"
              c:identifier="tp_weak_ref_destroy"
              version="0.11.3"
              introspectable="0">
        <doc xml:whitespace="preserve">Free a weak reference wrapper. This drops the weak reference to the
object (if it still exists), and frees the user data with the user-supplied
destructor function if one was provided.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="dup_object"
              c:identifier="tp_weak_ref_dup_object"
              version="0.11.3"
              introspectable="0">
        <doc xml:whitespace="preserve">If the weakly referenced object still exists, return a new reference to
it. Otherwise, return %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference, or %NULL</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="get_user_data"
              c:identifier="tp_weak_ref_get_user_data"
              version="0.11.3"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the additional data that was passed to tp_weak_ref_new().</doc>
        <return-value>
          <doc xml:whitespace="preserve">the additional data supplied in tp_weak_ref_new(), which may be %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <function name="new"
                c:identifier="tp_weak_ref_new"
                version="0.11.3"
                introspectable="0">
        <doc xml:whitespace="preserve">Return a new weak reference wrapper for @object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new weak-reference wrapper  Free-function: tp_weak_ref_destroy()</doc>
          <type name="WeakRef" c:type="TpWeakRef*"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object to which to take a weak reference</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">optional additional data to store alongside the weak ref</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">destructor for @user_data, called when the weak ref is freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="_DBusPropertiesMixinClass"
            c:type="_TpDBusPropertiesMixinClass">
      <field name="interfaces" writable="1">
        <type name="DBusPropertiesMixinIfaceImpl"
              c:type="TpDBusPropertiesMixinIfaceImpl*"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_5" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_6" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_7" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <function name="asv_dump" c:identifier="tp_asv_dump" introspectable="0">
      <doc xml:whitespace="preserve">Dumps the a{sv} map to the debugging console.

The purpose of this function is give the programmer the ability to easily
inspect the contents of an a{sv} map for debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_boolean"
              c:identifier="tp_asv_get_boolean"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and boolean, return it,
and set *@valid to %TRUE if @valid is not %NULL.

Otherwise return %FALSE, and set *@valid to %FALSE if @valid is not %NULL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a boolean value for @key</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location to store %TRUE if the key actually exists and has a boolean value</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_boxed"
              c:identifier="tp_asv_get_boxed"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is of the desired type,
return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it, for instance with
g_boxed_copy(), if you need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value of @key, or %NULL</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type that the key's value should have, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_bytes"
              c:identifier="tp_asv_get_bytes"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is an array of bytes
(its GType is %DBUS_TYPE_G_UCHAR_ARRAY), return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with
g_boxed_copy (DBUS_TYPE_G_UCHAR_ARRAY, ...) if you need to keep
it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the string value of @key, or %NULL</doc>
        <array name="GLib.Array" c:type="const GArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_double"
              c:identifier="tp_asv_get_double"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and has any numeric type used by
dbus-glib (guchar, gint, guint, gint64, guint64 or gdouble),
return it as a double, and if @valid is not %NULL, set *@valid to %TRUE.

Otherwise, return 0.0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the double precision floating-point value of @key, or 0.0</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_int32"
              c:identifier="tp_asv_get_int32"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a gint32, return it, and if @valid is not %NULL, set *@valid to
%TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 32-bit signed integer value of @key, or 0</doc>
        <type name="gint32" c:type="gint32"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_int64"
              c:identifier="tp_asv_get_int64"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a gint64, return it, and if @valid is not %NULL, set *@valid to
%TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 64-bit signed integer value of @key, or 0</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_object_path"
              c:identifier="tp_asv_get_object_path"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is an object path, return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdup() if you
need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the object-path value of @key, or %NULL</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_string"
              c:identifier="tp_asv_get_string"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is a string, return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdup() if you
need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the string value of @key, or %NULL</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_strv"
              c:identifier="tp_asv_get_strv"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is an array of strings (strv),
return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdupv() if you
need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the %NULL-terminated string-array value of @key, or %NULL</doc>
        <array c:type="const gchar* const*">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_uint32"
              c:identifier="tp_asv_get_uint32"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a guint32, return it, and if @valid is not %NULL, set *@valid to
%TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 32-bit unsigned integer value of @key, or 0</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_uint64"
              c:identifier="tp_asv_get_uint64"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and is non-negative,
return it, and if @valid is not %NULL, set *@valid to %TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 64-bit unsigned integer value of @key, or 0</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_lookup"
              c:identifier="tp_asv_lookup"
              version="0.7.9"
              introspectable="0">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, return it. Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with (for instance)
g_value_copy() if you need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value of @key, or %NULL</doc>
        <type name="GObject.Value" c:type="const GValue*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_new"
              c:identifier="tp_asv_new"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GHashTable for use with a{sv} maps, containing the values
passed in as parameters.

The #GHashTable is synonymous with:
&lt;informalexample&gt;&lt;programlisting&gt;
GHashTable *asv = g_hash_table_new_full (g_str_hash, g_str_equal,
   NULL, (GDestroyNotify) tp_g_value_slice_free);
&lt;/programlisting&gt;&lt;/informalexample&gt;
Followed by manual insertion of each of the parameters.

Parameters are stored in slice-allocated GValues and should be set using
tp_asv_set_*() and retrieved using tp_asv_get_*().

tp_g_value_slice_new() and tp_g_value_slice_dup() may also be used to insert
into the map if required.
&lt;informalexample&gt;&lt;programlisting&gt;
g_hash_table_insert (parameters, "account",
   tp_g_value_slice_new_string ("bob@mcbadgers.com"));
&lt;/programlisting&gt;&lt;/informalexample&gt;

&lt;example&gt;
 &lt;title&gt;Using tp_asv_new()&lt;/title&gt;
 &lt;programlisting&gt;
GHashTable *parameters = tp_asv_new (
   "answer", G_TYPE_INT, 42,
   "question", G_TYPE_STRING, "We just don't know",
   NULL);&lt;/programlisting&gt;
&lt;/example&gt;

Allocated values will be automatically free'd when overwritten, removed or
the hash table destroyed with g_hash_table_unref().</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created #GHashTable for storing a{sv} maps, free with g_hash_table_unref().</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="first_key" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first key (or NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_boolean"
              c:identifier="tp_asv_set_boolean"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boolean(), tp_g_value_slice_new_boolean()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_boxed"
              c:identifier="tp_asv_set_boxed"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boxed(), tp_g_value_slice_new_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_bytes"
              c:identifier="tp_asv_set_bytes"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_bytes(), tp_g_value_slice_new_bytes()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes to copy</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:whitespace="preserve">location of an array of bytes to be copied (this may be %NULL if and only if length is 0)</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_double"
              c:identifier="tp_asv_set_double"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_double(), tp_g_value_slice_new_double()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_int32"
              c:identifier="tp_asv_set_int32"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_int32(), tp_g_value_slice_new_int()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gint32" c:type="gint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_int64"
              c:identifier="tp_asv_set_int64"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_int64(), tp_g_value_slice_new_int64()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_object_path"
              c:identifier="tp_asv_set_object_path"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_object_path(),
tp_g_value_slice_new_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_boxed"
              c:identifier="tp_asv_set_static_boxed"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boxed(),
tp_g_value_slice_new_static_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_object_path"
              c:identifier="tp_asv_set_static_object_path"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_object_path(),
tp_g_value_slice_new_static_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_string"
              c:identifier="tp_asv_set_static_string"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_string(),
tp_g_value_slice_new_static_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_string"
              c:identifier="tp_asv_set_string"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_string(), tp_g_value_slice_new_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_strv"
              c:identifier="tp_asv_set_strv"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_strv()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a %NULL-terminated string array</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_uint32"
              c:identifier="tp_asv_set_uint32"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_uint32(), tp_g_value_slice_new_uint()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_uint64"
              c:identifier="tp_asv_set_uint64"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_uint64(), tp_g_value_slice_new_uint64()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_boxed"
              c:identifier="tp_asv_take_boxed"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boxed(), tp_g_value_slice_new_take_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_bytes"
              c:identifier="tp_asv_take_bytes"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_bytes(), tp_g_value_slice_new_take_bytes()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-NULL #GArray of %guchar, ownership of which will be taken by the #GValue</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_object_path"
              c:identifier="tp_asv_take_object_path"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_object_path(),
tp_g_value_slice_new_take_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_string"
              c:identifier="tp_asv_take_string"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_string(),
tp_g_value_slice_new_take_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_list_copy"
              c:identifier="tp_contact_info_list_copy"
              moved-to="ContactInfoList.copy"
              version="0.11.7"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value>
        <doc xml:whitespace="preserve">a new #GList of newly allocated #TpContactInfoField, free it with tp_contact_info_list_free()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_list_free"
              c:identifier="tp_contact_info_list_free"
              moved-to="ContactInfoList.free"
              version="0.11.7"
              introspectable="0">
      <doc xml:whitespace="preserve">Free all memory used by the #GList and its elements.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_spec_list_copy"
              c:identifier="tp_contact_info_spec_list_copy"
              moved-to="ContactInfoSpecList.copy"
              version="0.11.7"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value>
        <doc xml:whitespace="preserve">a new #GList of newly allocated #TpContactInfoFieldSpec, free it with tp_contact_info_spec_list_free()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_spec_list_free"
              c:identifier="tp_contact_info_spec_list_free"
              moved-to="ContactInfoSpecList.free"
              version="0.11.7"
              introspectable="0">
      <doc xml:whitespace="preserve">Free all memory used by the #GList and its elements.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_add_contact_attributes_iface"
              c:identifier="tp_contacts_mixin_add_contact_attributes_iface"
              moved-to="ContactsMixin.add_contact_attributes_iface"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Declare that the given interface has contact attributes which can be added
to the attributes hash using the filler function. All the handles in the
handle array passed to the filler function are guaranteed to be valid and
referenced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">Name of the interface that has ContactAttributes</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fill_contact_attributes" transfer-ownership="none">
          <doc xml:whitespace="preserve">Contact attribute filler function</doc>
          <type name="ContactsMixinFillContactAttributesFunc"
                c:type="TpContactsMixinFillContactAttributesFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_class_get_offset_quark"
              c:identifier="tp_contacts_mixin_class_get_offset_quark"
              moved-to="ContactsMixinClass.get_offset_quark"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="contacts_mixin_class_init"
              c:identifier="tp_contacts_mixin_class_init"
              moved-to="ContactsMixinClass.init"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_class_init ((GObjectClass *) klass,
                         G_STRUCT_OFFSET (SomeObjectClass, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpContactsMixinClass within the class structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_finalize"
              c:identifier="tp_contacts_mixin_finalize"
              moved-to="ContactsMixin.finalize"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Free resources held by the contacts mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_get_contact_attributes"
              c:identifier="tp_contacts_mixin_get_contact_attributes"
              moved-to="ContactsMixin.get_contact_attributes"
              introspectable="0">
      <doc xml:whitespace="preserve">Get contact attributes for the given contacts. Provide attributes for all requested
interfaces. If contact attributes are not immediately known, the behaviour is defined
by the interface; the attribute should either be omitted from the result or replaced
with a default value.</doc>
      <return-value>
        <doc xml:whitespace="preserve">A dictionary mapping the contact handles to contact attributes.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A connection instance that uses this mixin. The connection must be connected.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">List of handles to retrieve contacts for. Any invalid handles will be dropped from the returned mapping.</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="interfaces" transfer-ownership="none">
          <doc xml:whitespace="preserve">A list of interfaces to retrieve attributes from.</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
        <parameter name="assumed_interfaces" transfer-ownership="none">
          <doc xml:whitespace="preserve">A list of additional interfaces to retrieve attributes from. This can be used for interfaces documented as automatically included, like %TP_IFACE_CONNECTION for GetContactAttributes, or %TP_IFACE_CONNECTION and %TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST for GetContactListAttributes.</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:whitespace="preserve">The DBus client's unique name. If this is not NULL, the requested handles will be held on behalf of this client.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_get_offset_quark"
              c:identifier="tp_contacts_mixin_get_offset_quark"
              moved-to="ContactsMixin.get_offset_quark"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="contacts_mixin_iface_init"
              c:identifier="tp_contacts_mixin_iface_init"
              moved-to="ContactsMixin.iface_init"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the contacts interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceContacts in an object class</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_init"
              c:identifier="tp_contacts_mixin_init"
              moved-to="ContactsMixin.init"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_init ((GObject *) self,
                    G_STRUCT_OFFSET (SomeObject, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpContactsMixin within the object structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_set_contact_attribute"
              c:identifier="tp_contacts_mixin_set_contact_attribute"
              moved-to="ContactsMixin.set_contact_attribute"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Utility function to set attribute for handle to value in the attributes hash
as passed to a TpContactsMixinFillContactAttributesFunc.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="contact_attributes" transfer-ownership="none">
          <doc xml:whitespace="preserve">contacts attribute hash as passed to TpContactsMixinFillContactAttributesFunc</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handle to set the attribute on</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:whitespace="preserve">attribute name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">slice allocated GValue containing the value of the attribute, for instance with tp_g_value_slice_new. Ownership of the GValue is taken over by the mixin</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_bus_name"
              c:identifier="tp_dbus_check_valid_bus_name"
              version="0.7.1"
              throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus bus name of an appropriate
type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible bus name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="allow_types" transfer-ownership="none">
          <doc xml:whitespace="preserve">some combination of %TP_DBUS_NAME_TYPE_UNIQUE, %TP_DBUS_NAME_TYPE_WELL_KNOWN or %TP_DBUS_NAME_TYPE_BUS_DAEMON (often this will be %TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON or %TP_DBUS_NAME_TYPE_ANY)</doc>
          <type name="DBusNameType" c:type="TpDBusNameType"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_interface_name"
              c:identifier="tp_dbus_check_valid_interface_name"
              version="0.7.1"
              throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus interface name. This is
also appropriate to use to check for valid error names.

Since GIO 2.26, g_dbus_is_interface_name() should always return the same
thing, although the GLib function does not raise an error explaining why
the interface name is incorrect.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible interface name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_member_name"
              c:identifier="tp_dbus_check_valid_member_name"
              version="0.7.1"
              throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus member (method or signal) name.

Since GIO 2.26, g_dbus_is_member_name() should always return the same
thing, although the GLib function does not raise an error explaining why
the interface name is incorrect.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible member name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_object_path"
              c:identifier="tp_dbus_check_valid_object_path"
              version="0.7.1"
              throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus object path. Since GLib 2.24,
g_variant_is_object_path() should always return the same thing as this
function, although it doesn't provide an error explaining why the object
path is invalid.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @path is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible object path</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_errors_quark" c:identifier="tp_dbus_errors_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="dbus_g_method_return_not_implemented"
              c:identifier="tp_dbus_g_method_return_not_implemented"
              introspectable="0">
      <doc xml:whitespace="preserve">Return the Telepathy error NotImplemented from the method invocation
given by @context.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus method invocation context</doc>
          <type c:type="DBusGMethodInvocation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_class_init"
              c:identifier="tp_dbus_properties_mixin_class_init"
              version="0.7.3">
      <doc xml:whitespace="preserve">Initialize the class @cls to use the D-Bus Properties mixin.
The given struct member, of size sizeof(TpDBusPropertiesMixinClass),
will be used to store property implementation information.

Each property and each interface must have been declared as a member of
a GInterface implemented by @cls, using
tp_svc_interface_set_dbus_properties_info().

Before calling this function, the array @interfaces must have been
placed in the #TpDBusPropertiesMixinClass structure; if it would be empty,
it may instead be %NULL.

This function should be called from the class_init callback in such a way
that it will only be called once, even if the class is subclassed.

Changed in 0.7.9: TpDBusPropertiesMixinClass::interfaces may now be %NULL,
which means that only interfaces whose properties are set up using
tp_dbus_properties_mixin_implement_interface() will be used.

Changed in 0.7.15: @offset may now be 0, in which case the
#TpDBusPropertiesMixinClass can be omitted from @cls.  It is treated as if
it were present, but with all fields (including
TpDBusPropertiesMixinClass::interfaces) being %NULL, so only interfaces
whose properties are set using
tp_dbus_properties_mixin_implement_interface() will be used.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">a subclass of #GObjectClass</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset within @cls of a TpDBusPropertiesMixinClass structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_emit_properties_changed"
              c:identifier="tp_dbus_properties_mixin_emit_properties_changed"
              version="0.15.6">
      <doc xml:whitespace="preserve">Emits the PropertiesChanged signal for the provided properties. Depending on
the EmitsChangedSignal annotations in the introspection XML, either the new
value of the property will be included in the signal, or merely the fact
that the property has changed.

For example, the MPRIS specification defines a TrackList interface with two
properties, one of which is annotated with EmitsChangedSignal=true and one
annotated with EmitsChangedSignal=invalidates. The following call would
include the new value of CanEditTracks and list Tracks as invalidated:

|[
   const gchar *properties[] = { "CanEditTracks", "Tracks", NULL };

   tp_dbus_properties_mixin_emit_properties_changed (G_OBJECT (self),
       "org.mpris.MediaPlayer2.TrackList", properties);
]|

It is an error to pass a property to this
function if the property is annotated with EmitsChangedSignal=false, or is
unannotated.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface on which properties have changed</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="properties" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a %NULL-terminated array of (unqualified) property names whose values have changed.</doc>
          <type name="utf8" c:type="const gchar* const*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_emit_properties_changed_varargs"
              c:identifier="tp_dbus_properties_mixin_emit_properties_changed_varargs"
              version="0.15.6"
              introspectable="0">
      <doc xml:whitespace="preserve">A shortcut for calling tp_dbus_properties_mixin_emit_properties_changed().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface on which properties have changed</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_fill_properties_hash"
              c:identifier="tp_dbus_properties_mixin_fill_properties_hash"
              version="0.11.11"
              introspectable="0">
      <doc xml:whitespace="preserve">Retrieves the values of several D-Bus properties from an object, and adds
them to a hash mapping the fully-qualified name of the property to its
value. This is equivalent to calling tp_dbus_properties_mixin_get() for
each property and adding it to the table yourself, with the proviso that
this function will g_assert() if retrieving a property fails (for instance,
because it does not exist).

Note that in particular, @table does not have the same memory-allocation
model as the hash tables required by tp_asv_set_string() and similar
functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="table" transfer-ownership="none">
          <doc xml:whitespace="preserve">a hash table where the keys are strings copied with g_strdup() and the values are slice-allocated #GValue&lt;!-- --&gt;s</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="first_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface of the first property to be retrieved</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="first_property" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property to be retrieved</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_get"
              c:identifier="tp_dbus_properties_mixin_get"
              version="0.7.13"
              throws="1">
      <doc xml:whitespace="preserve">Initialize @value with the type of the property @property_name on
@interface_name, and write the value of that property into it as if
by calling the D-Bus method org.freedesktop.DBus.Properties.Get.

If Get would return a D-Bus error, @value remains unset and @error
is filled in instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE (filling @value) on success, %FALSE (setting @error) on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus interface name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus property name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">an unset GValue (initialized to all zeroes)</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_getter_gobject_properties"
              c:identifier="tp_dbus_properties_mixin_getter_gobject_properties">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that
the @getter_data is the name of a readable #GObject property of an
appropriate type, and uses it for the value of the D-Bus property.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="getter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The getter_data from the #TpDBusPropertiesMixinPropImpl, which must be a string containing the GObject property's name</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_iface_init"
              c:identifier="tp_dbus_properties_mixin_iface_init">
      <doc xml:whitespace="preserve">Declare that the DBus.Properties interface represented by @g_iface
is implemented using this mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a #TpSvcDBusPropertiesClass structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_implement_interface"
              c:identifier="tp_dbus_properties_mixin_implement_interface"
              introspectable="0">
      <doc xml:whitespace="preserve">Declare that, in addition to any interfaces set in
tp_dbus_properties_mixin_class_init(), the given class (and its subclasses)
will implement the properties of the interface @iface using the callbacks
@getter and @setter and the properties given by @props.

This function should be called from the class_init callback in such a way
that it will only be called once, even if the class is subclassed.

Typically, the static array @interfaces in the #TpDBusPropertiesMixinClass
should be used for interfaces whose properties are implemented directly by
the class @cls, and this function should be used for interfaces whose
properties are implemented by mixins.

It is an error for the same interface to appear in the array @interfaces
in the #TpDBusPropertiesMixinClass, and also be set up by this function.

If a class C and a subclass S both implement the properties of the same
interface, only the implementations from the subclass S will be used,
regardless of whether the implementations in C and/or S were set up by
this function or via the array @interfaces in the
#TpDBusPropertiesMixinClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">a subclass of #GObjectClass</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">a quark representing the the name of the interface to implement</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="getter" transfer-ownership="none">
          <doc xml:whitespace="preserve">a callback to get properties on this interface, or %NULL if they are all write-only</doc>
          <type name="DBusPropertiesMixinGetter"
                c:type="TpDBusPropertiesMixinGetter"/>
        </parameter>
        <parameter name="setter" transfer-ownership="none">
          <doc xml:whitespace="preserve">a callback to set properties on this interface, or %NULL if they are all read-only</doc>
          <type name="DBusPropertiesMixinSetter"
                c:type="TpDBusPropertiesMixinSetter"/>
        </parameter>
        <parameter name="props" transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of #TpDBusPropertiesMixinPropImpl representing individual properties, terminated by one with @name == %NULL</doc>
          <type name="DBusPropertiesMixinPropImpl"
                c:type="TpDBusPropertiesMixinPropImpl*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_make_properties_hash"
              c:identifier="tp_dbus_properties_mixin_make_properties_hash"
              introspectable="0">
      <doc xml:whitespace="preserve">Retrieves the values of several D-Bus properties from an object, and builds
a hash mapping the fully-qualified name of the property to its value.  This
is equivalent to calling tp_dbus_properties_mixin_get() for each property
and building the table yourself, with the proviso that this function will
g_assert() if retrieving a property fails (for instance, because it does not
exist).

Additional keys and values can be inserted into the returned hash table;
if this is done, the inserted keys and values will be freed when the
hash table is destroyed. The keys must be allocated with g_strdup() or
equivalent, and the values must be slice-allocated (for instance with
tp_g_value_slice_new_string() or a similar function).

Note that in particular, tp_asv_set_string() and similar functions should
not be used with this hash table.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a hash table mapping (gchar *) fully-qualified property names to GValues, which must be freed by the caller (at which point its contents will also be freed).</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="first_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface of the first property to be retrieved</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="first_property" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property to be retrieved</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_set"
              c:identifier="tp_dbus_properties_mixin_set"
              version="0.15.8"
              throws="1">
      <doc xml:whitespace="preserve">Sets a property to the value specified by @value, as if by
calling the D-Bus method org.freedesktop.DBus.Properties.Set.

If Set would return a D-Bus error, sets @error and returns %FALSE</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success; %FALSE (setting @error) on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus interface name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus property name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue containing the new value for this property.</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_setter_gobject_properties"
              c:identifier="tp_dbus_properties_mixin_setter_gobject_properties"
              throws="1">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinSetter which assumes that the
@setter_data is the name of a writable #GObject property of an appropriate
type, and sets that property to the given value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new value for the property</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="setter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The setter_data from the #TpDBusPropertiesMixinPropImpl, which must be a string containing the GObject property's name</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_divert_messages"
              c:identifier="tp_debug_divert_messages"
              version="0.7.1">
      <doc xml:whitespace="preserve">Open the given file for writing and duplicate its file descriptor to
be used for stdout and stderr. This has the effect of closing the previous
stdout and stderr, and sending all messages that would have gone there
to the given file instead.

By default the file is truncated and hence overwritten each time the
process is executed.
Since version 0.7.14, if the filename is prefixed with '+' then the
file is not truncated and output is added at the end of the file.

Passing %NULL to this function is guaranteed to have no effect. This is
so you can call it with the recommended usage
&lt;literal&gt;tp_debug_divert_messages (g_getenv ("MYAPP_LOGFILE"))&lt;/literal&gt;
and it won't do anything if the environment variable is not set.

This function still works if telepathy-glib was compiled without debug
support.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">A file to which to divert stdout and stderr, or %NULL to do nothing</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_all_flags"
              c:identifier="tp_debug_set_all_flags"
              introspectable="0"
              deprecated="since 0.6.1. Use tp_debug_set_flags (&quot;all&quot;) and tp_debug_set_persistent() instead.">
      <doc xml:whitespace="preserve">Activate all possible debug modes. This also activates persistent mode,
which should have been orthogonal.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="debug_set_flags"
              c:identifier="tp_debug_set_flags"
              version="0.6.1">
      <doc xml:whitespace="preserve">Set the debug flags indicated by @flags_string, in addition to any already
set.

The parsing matches that of g_parse_debug_string().

If telepathy-glib was compiled with --disable-debug (not recommended),
this function has no practical effect, since the debug messages it would
enable were removed at compile time.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags_string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The flags to set, comma-separated. If %NULL or empty, no additional flags are set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_flags_from_env"
              c:identifier="tp_debug_set_flags_from_env"
              introspectable="0"
              deprecated="since 0.6.1. Use tp_debug_set_flags(g_getenv(...)) and tp_debug_set_persistent() instead">
      <doc xml:whitespace="preserve">Equivalent to
&lt;literal&gt;tp_debug_set_flags_from_string (g_getenv (var))&lt;/literal&gt;,
and has the same problem with persistence being included in "all".</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="var" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the environment variable to parse</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_flags_from_string"
              c:identifier="tp_debug_set_flags_from_string"
              introspectable="0"
              deprecated="since 0.6.1. Use tp_debug_set_flags() and tp_debug_set_persistent() instead">
      <doc xml:whitespace="preserve">Set the debug flags indicated by @flags_string, in addition to any already
set. Unlike tp_debug_set_flags(), this enables persistence like
tp_debug_set_persistent() if the "persist" flag is present or the string
is "all" - this turns out to be unhelpful, as persistence should be
orthogonal.

The parsing matches that of g_parse_debug_string().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags_string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The flags to set, comma-separated. If %NULL or empty, no additional flags are set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_persistent"
              c:identifier="tp_debug_set_persistent">
      <doc xml:whitespace="preserve">Used to enable persistent operation of the connection manager process for
debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="persistent" transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE prevents the connection manager mainloop from exiting, FALSE enables exiting if there are no connections (the default behavior).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_timestamped_log_handler"
              c:identifier="tp_debug_timestamped_log_handler"
              version="0.7.1">
      <doc xml:whitespace="preserve">A #GLogFunc that prepends the UTC time (currently in ISO 8601 format,
with microsecond resolution) to the message, then calls
g_log_default_handler.

Intended usage is:

&lt;informalexample&gt;&lt;programlisting&gt;if (g_getenv ("MYPROG_TIMING") != NULL)
  g_log_set_default_handler (tp_debug_timestamped_log_handler, NULL);
&lt;/programlisting&gt;&lt;/informalexample&gt;

If telepathy-glib was compiled with --disable-debug (not recommended),
this function is equivalent to g_log_default_handler().

Changed in 0.9.0: timestamps are now printed in UTC, in
RFC-3339 format. Previously, they were printed in local time, in a
format similar to RFC-3339.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message's log domain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:whitespace="preserve">the log level of the message</doc>
          <type name="GLib.LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message to process</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="ignored" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_get_dbus_name"
              c:identifier="tp_error_get_dbus_name"
              version="0.7.31">
      <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the D-Bus error name corresponding to @error.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">a member of the #TpError enum.</doc>
          <type name="Error" c:type="TpError"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_quark"
              c:identifier="tp_error_quark"
              version="0.11.13">
      <doc xml:whitespace="preserve">Return the error domain quark for #TpError.</doc>
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_disconnected_quark"
              c:identifier="tp_errors_disconnected_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_quark"
              c:identifier="tp_errors_quark"
              introspectable="0"
              deprecated="Use tp_error_quark() instead.">
      <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_removed_from_group_quark"
              c:identifier="tp_errors_removed_from_group_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="escape_as_identifier"
              c:identifier="tp_escape_as_identifier">
      <doc xml:whitespace="preserve">Escape an arbitrary string so it follows the rules for a C identifier,
and hence an object path component, interface element component,
bus name component or member name in D-Bus.

Unlike g_strcanon this is a reversible encoding, so it preserves
distinctness.

The escaping consists of replacing all non-alphanumerics, and the first
character if it's a digit, with an underscore and two lower-case hex
digits:

   "0123abc_xyz\x01\xff" -&gt; _30123abc_5fxyz_01_ff

i.e. similar to URI encoding, but with _ taking the role of %, and a
smaller allowed set. As a special case, "" is escaped to "_" (just for
completeness, really).</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the escaped string, which must be freed by the caller with #g_free</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The string to be escaped</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_finalize"
              c:identifier="tp_external_group_mixin_finalize"
              version="0.5.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Remove the external group mixin. This function should usually be called
in the dispose or finalize function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the groups interface using an external group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_get_dbus_property"
              c:identifier="tp_external_group_mixin_get_dbus_property"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
@object has the external group mixin. It can only be used for the Group
interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name, either "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members", "RemotePendingMembers" or "SelfHandle"</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="unused" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_iface_init"
              c:identifier="tp_external_group_mixin_iface_init"
              version="0.5.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the group interface using
the group mixin of another object. This function should usually be called
via G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Unused</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_init"
              c:identifier="tp_external_group_mixin_init"
              version="0.5.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the qdata needed to implement the group interface using
the group mixin of another object. This function should usually be called
in the instance constructor.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the groups interface using an external group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="obj_with_mixin" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GObject with the group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_init_dbus_properties"
              c:identifier="tp_external_group_mixin_init_dbus_properties"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.

This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to channels containing the
mixin used by this class with tp_group_mixin_change_flags() to indicate that
the DBus properties are available.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_hash_table_update"
              c:identifier="tp_g_hash_table_update"
              version="0.7.0"
              introspectable="0">
      <doc xml:whitespace="preserve">Add each item in @source to @target, replacing any existing item with the
same key. @key_dup and @value_dup are used to duplicate the items; in
principle they could also be used to convert between types.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:whitespace="preserve">The hash table to be updated</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:whitespace="preserve">The hash table to update it with (read-only)</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key_dup" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to duplicate a key from @source so it can be be stored in @target. If NULL, the key is not copied, but is used as-is</doc>
          <type name="GObject.BoxedCopyFunc" c:type="GBoxedCopyFunc"/>
        </parameter>
        <parameter name="value_dup" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to duplicate a value from @source so it can be stored in @target. If NULL, the value is not copied, but is used as-is</doc>
          <type name="GObject.BoxedCopyFunc" c:type="GBoxedCopyFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_key_file_get_int64"
              c:identifier="tp_g_key_file_get_int64"
              version="0.7.31"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Returns the value associated with @key under @group_name as a signed
64-bit integer. This is similar to g_key_file_get_integer() but can return
64-bit results without truncation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value associated with the key as a signed 64-bit integer, or 0 if the key was not found or could not be parsed.</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="key_file" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-%NULL #GKeyFile</doc>
          <type name="GLib.KeyFile" c:type="GKeyFile*"/>
        </parameter>
        <parameter name="group_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-%NULL group name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-%NULL key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_key_file_get_uint64"
              c:identifier="tp_g_key_file_get_uint64"
              version="0.7.31"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Returns the value associated with @key under @group_name as an unsigned
64-bit integer. This is similar to g_key_file_get_integer() but can return
large positive results without truncation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value associated with the key as an unsigned 64-bit integer, or 0 if the key was not found or could not be parsed.</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="key_file" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-%NULL #GKeyFile</doc>
          <type name="GLib.KeyFile" c:type="GKeyFile*"/>
        </parameter>
        <parameter name="group_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-%NULL group name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-%NULL key</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_ptr_array_contains"
              c:identifier="tp_g_ptr_array_contains"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no further documentation needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @needle is one of the elements of @haystack</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="haystack" transfer-ownership="none">
          <doc xml:whitespace="preserve">The pointer array to be searched</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="needle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The pointer to look for</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_ptr_array_extend"
              c:identifier="tp_g_ptr_array_extend"
              version="0.14.3"
              introspectable="0">
      <doc xml:whitespace="preserve">Appends all elements of @source to @target. Note that this only copies the
pointers from @source; any duplication or reference-incrementing must be
performed by the caller.

After this function has been called, it is safe to call
g_ptr_array_free() on @source and also free the actual pointer array,
as long as doing so does not free the data pointed to by the new
items in @target.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GPtrArray to copy items to</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GPtrArray to copy items from</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="g_set_error_invalid_handle_type"
              c:identifier="tp_g_set_error_invalid_handle_type"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Set the error NotImplemented for an invalid handle type,
with an appropriate message.

Changed in version 0.7.23: previously, the error was
InvalidArgument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">An invalid handle type</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_set_error_unsupported_handle_type"
              c:identifier="tp_g_set_error_unsupported_handle_type"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Set the error NotImplemented for a handle type which is valid but is not
supported by this connection manager, with an appropriate message.

Changed in version 0.7.23: previously, the error was
InvalidArgument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">An unsupported handle type</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_signal_connect_object"
              c:identifier="tp_g_signal_connect_object"
              version="0.9.2"
              introspectable="0">
      <doc xml:whitespace="preserve">Connects a #GCallback function to a signal for a particular object, as if
with g_signal_connect(). Additionally, arranges for the signal handler to be
disconnected if @gobject is destroyed.

This is similar to g_signal_connect_data(), but uses a closure which
ensures that the @gobject stays alive during the call to @c_handler
by temporarily adding a reference count to @gobject.

This is similar to g_signal_connect_object(), but doesn't have the
documented bug that everyone is too scared to fix. Also, it does not allow
you to pass in NULL as @gobject

This is intended to be a convenient way for objects to use themselves as
user_data for callbacks without having to explicitly disconnect all the
handlers in their finalizers.

Changed in 0.10.4 and 0.11.3: %G_CONNECT_AFTER is now respected.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handler id</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance to connect to.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="c_handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GCallback to connect.</doc>
          <type name="GObject.Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="gobject" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object to pass as data to @c_handler.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="connect_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #GConnectFlags. Only %G_CONNECT_AFTER and %G_CONNECT_SWAPPED are supported by this function.</doc>
          <type name="GObject.ConnectFlags" c:type="GConnectFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_value_slice_dup"
              c:identifier="tp_g_value_slice_dup"
              version="0.5.14"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!-- 'Returns' says it all --&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated copy of @value, to be freed with tp_g_value_slice_free() or g_slice_free().</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_value_slice_free"
              c:identifier="tp_g_value_slice_free"
              introspectable="0">
      <doc xml:whitespace="preserve">Unset and free a slice-allocated GValue.

&lt;literal&gt;(GDestroyNotify) tp_g_value_slice_free&lt;/literal&gt; can be used
as a destructor for values in a #GHashTable, for example.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue which was allocated with the g_slice API</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_bus" c:identifier="tp_get_bus" introspectable="0">
      <doc xml:whitespace="preserve">Returns a connection to the D-Bus daemon on which this process was
activated if it was launched by D-Bus service activation, or the session
bus otherwise.

If dbus_g_bus_get() fails, exit with error code 1.

Note that this function is not suitable for use in applications which can
be useful even in the absence of D-Bus - it is designed for use in
connection managers, which are not at all useful without a D-Bus
connection. See &amp;lt;https://bugs.freedesktop.org/show_bug.cgi?id=18832&amp;gt;.
Most processes should use tp_dbus_daemon_dup() instead.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a connection to the starter or session D-Bus daemon.</doc>
        <type c:type="DBusGConnection*"/>
      </return-value>
    </function>
    <function name="get_bus_proxy"
              c:identifier="tp_get_bus_proxy"
              introspectable="0"
              deprecated="Use tp_dbus_daemon_dup() in new code."
              deprecated-version="0.7.26">
      <doc xml:whitespace="preserve">Return a #DBusGProxy for the bus daemon object. The same caveats as for
tp_get_bus() apply.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a proxy for the bus daemon object on the starter or session bus.</doc>
        <type c:type="DBusGProxy*"/>
      </return-value>
    </function>
    <function name="group_mixin_add_handle_owner"
              c:identifier="tp_group_mixin_add_handle_owner"
              moved-to="GroupMixin.add_handle_owner"
              introspectable="0">
      <doc xml:whitespace="preserve">Note that the given local handle is an alias within this group
for the given globally-valid handle. It will be returned from subsequent
GetHandleOwner queries where appropriate.

Changed in 0.7.10: The @owner_handle may be 0. To comply with telepathy-spec
 0.17.6, before adding any channel-specific handle to the members,
 local-pending members or remote-pending members, you must call either
 this function or tp_group_mixin_add_handle_owners().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="local_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A contact handle valid within this group (may not be 0)</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="owner_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A contact handle valid globally, or 0 if the owner of the @local_handle is unknown</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_add_handle_owners"
              c:identifier="tp_group_mixin_add_handle_owners"
              moved-to="GroupMixin.add_handle_owners"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">Note that the given local handles are aliases within this group
for the given globally-valid handles.

To comply with telepathy-spec 0.17.6, before adding any channel-specific
handle to the members, local-pending members or remote-pending members, you
must call either this function or tp_group_mixin_add_handle_owner().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="local_to_owner_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A map from contact handles valid within this group (which may not be 0) to either contact handles valid globally, or 0 if the owner of the corresponding key is unknown; all handles are stored using GUINT_TO_POINTER</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_add_members"
              c:identifier="tp_group_mixin_add_members"
              moved-to="GroupMixin.add_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Request that the given contacts be added to the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
Otherwise attempt to add the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message associated with the addition request, if supported</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_flags"
              c:identifier="tp_group_mixin_change_flags"
              moved-to="GroupMixin.change_flags"
              introspectable="0">
      <doc xml:whitespace="preserve">Request a change to be made to the flags. If any flags were actually
set or cleared, emits the GroupFlagsChanged signal with the changes.

It is an error to set any of the same bits in both @add and @del.

Changed in 0.7.7: the signal is not emitted if adding @add and
 removing @del had no effect on the existing group flags.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the groups interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags to be added</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags to be removed</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_members"
              c:identifier="tp_group_mixin_change_members"
              moved-to="GroupMixin.change_members"
              introspectable="0">
      <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed) signals were emitted; %FALSE if nothing actually changed and the signals were suppressed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent to the affected contacts if possible; %NULL is allowed, and is mapped to an empty string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="add_local_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="add_remote_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="actor" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact responsible for this change</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:whitespace="preserve">The reason for this change</doc>
          <type name="ChannelGroupChangeReason"
                c:type="TpChannelGroupChangeReason"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_members_detailed"
              c:identifier="tp_group_mixin_change_members_detailed"
              moved-to="GroupMixin.change_members_detailed"
              version="0.7.21"
              introspectable="0">
      <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.

details may contain, among other entries, the well-known
keys (and corresponding type, wrapped in a GValue) defined by the
Group.MembersChangedDetailed signal's specification; these include "actor"
(a handle as G_TYPE_UINT), "change-reason" (an element of
#TpChannelGroupChangeReason as G_TYPE_UINT), "message" (G_TYPE_STRING),
"error" (G_TYPE_STRING), "debug-message" (G_TYPE_STRING).

If all of the information in details could be passed to
tp_group_mixin_change_members() then calling this function instead provides
no benefit. Calling this function without setting
#TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED with
tp_group_mixin_change_members() first is not very useful, as clients will
not know to listen for MembersChangedDetailed and thus will miss the
details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed) signals were emitted; %FALSE if nothing actually changed and the signals were suppressed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="add_local_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="add_remote_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
          <type name="Intset" c:type="const TpIntset*"/>
        </parameter>
        <parameter name="details" transfer-ownership="none">
          <doc xml:whitespace="preserve">a map from strings to GValues detailing the change</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_self_handle"
              c:identifier="tp_group_mixin_change_self_handle"
              moved-to="GroupMixin.change_self_handle"
              introspectable="0">
      <doc xml:whitespace="preserve">Change the self-handle for this group to the given value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="new_self_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new self-handle for this group</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_allow_self_removal"
              c:identifier="tp_group_mixin_class_allow_self_removal"
              moved-to="GroupMixinClass.allow_self_removal"
              version="0.7.27"
              introspectable="0">
      <doc xml:whitespace="preserve">Configure the mixin to allow attempts to remove the SelfHandle from this
Group, even if the group flags would otherwise disallow this. The
channel's #TpGroupMixinRemMemberFunc or
#TpGroupMixinRemMemberWithReasonFunc will be called as usual for such
attempts, and may make them fail with %TP_ERROR_PERMISSION_DENIED if
required.

This function should be called from the GObject @class_init callback,
after calling tp_group_mixin_class_init().

(Recent telepathy-spec changes make it valid to try to remove the
self-handle at all times, regardless of group flags. However, if this was
implemented automatically in TpGroupMixin, this would risk crashing
connection manager implementations that assume that TpGroupMixin will
enforce the group flags strictly. As a result, connection managers should
call this function to indicate to the TpGroupMixin that it may call their
removal callback with the self-handle regardless of flag settings.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_get_offset_quark"
              c:identifier="tp_group_mixin_class_get_offset_quark"
              moved-to="GroupMixinClass.get_offset_quark"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="group_mixin_class_init"
              c:identifier="tp_group_mixin_class_init"
              moved-to="GroupMixinClass.init"
              introspectable="0">
      <doc xml:whitespace="preserve">Configure the mixin for use with the given class.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The offset of the TpGroupMixinClass structure within the class structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="add_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to add contacts to this group</doc>
          <type name="GroupMixinAddMemberFunc"
                c:type="TpGroupMixinAddMemberFunc"/>
        </parameter>
        <parameter name="rem_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group. This must be %NULL if you will subsequently call tp_group_mixin_class_set_remove_with_reason_func().</doc>
          <type name="GroupMixinRemMemberFunc"
                c:type="TpGroupMixinRemMemberFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_set_remove_with_reason_func"
              c:identifier="tp_group_mixin_class_set_remove_with_reason_func"
              moved-to="GroupMixinClass.set_remove_with_reason_func"
              version="0.5.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Set a callback to be used to implement RemoveMembers() and
RemoveMembersWithReason(). If this function is called during class
initialization, the given callback will be used instead of the remove
callback passed to tp_group_mixin_class_init() (which must be %NULL
in this case).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group with a specified reason.</doc>
          <type name="GroupMixinRemMemberWithReasonFunc"
                c:type="TpGroupMixinRemMemberWithReasonFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_finalize"
              c:identifier="tp_group_mixin_finalize"
              moved-to="GroupMixin.finalize"
              introspectable="0">
      <doc xml:whitespace="preserve">Unreference handles and free resources used by this mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_all_members"
              c:identifier="tp_group_mixin_get_all_members"
              moved-to="GroupMixin.get_all_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's current and pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="members" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="local_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's local pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="remote_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_dbus_property"
              c:identifier="tp_group_mixin_get_dbus_property"
              moved-to="GroupMixin.get_dbus_property"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
@object has the group mixin. It can only be used for the Group interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name, either "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members", "RemotePendingMembers" or "SelfHandle"</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="unused" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_group_flags"
              c:identifier="tp_group_mixin_get_group_flags"
              moved-to="GroupMixin.get_group_flags"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Set the guint pointed to by ret to this group's flags, to be
interpreted according to TpChannelGroupFlags.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return the flags</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_handle_owners"
              c:identifier="tp_group_mixin_get_handle_owners"
              moved-to="GroupMixin.get_handle_owners"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">If the mixin has the flag %TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES,
return the global owners of the given local handles, or 0 where
unavailable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE (setting @ret) on success, %FALSE (setting @error) on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of guint representing locally valid handles</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return an array of guint representing globally valid handles, or 0 where unavailable, if %TRUE is returned</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_local_pending_members"
              c:identifier="tp_group_mixin_get_local_pending_members"
              moved-to="GroupMixin.get_local_pending_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's local-pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_local_pending_members_with_info"
              c:identifier="tp_group_mixin_get_local_pending_members_with_info"
              moved-to="GroupMixin.get_local_pending_members_with_info"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's local-pending members and information about their
requests to join the channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GPtrArray of D-Bus structures each containing the handle of a local-pending contact, the handle of a contact responsible for adding them to the group (or 0), the reason code and a related message (e.g. their request to join the group)</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_members"
              c:identifier="tp_group_mixin_get_members"
              moved-to="GroupMixin.get_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's current members</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_offset_quark"
              c:identifier="tp_group_mixin_get_offset_quark"
              moved-to="GroupMixin.get_offset_quark"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="group_mixin_get_remote_pending_members"
              c:identifier="tp_group_mixin_get_remote_pending_members"
              moved-to="GroupMixin.get_remote_pending_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's remote-pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_self_handle"
              c:identifier="tp_group_mixin_get_self_handle"
              moved-to="GroupMixin.get_self_handle"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Set the guint pointed to by ret to the local user's handle in this
group, or to 0 if the local user is not present in this group.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return the local user's handle in this group</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_iface_init"
              c:identifier="tp_group_mixin_iface_init"
              moved-to="GroupMixin.iface_init"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the group interface using
this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Unused</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_init"
              c:identifier="tp_group_mixin_init"
              moved-to="GroupMixin.init"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The offset of the TpGroupMixin structure within the instance structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="handle_repo" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection's handle repository for contacts</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="self_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the local user in this group, if any</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_init_dbus_properties"
              c:identifier="tp_group_mixin_init_dbus_properties"
              moved-to="GroupMixin.init_dbus_properties"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.

This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to any channels of this class
with tp_group_mixin_change_flags() to indicate that the DBus properties are
available.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_remove_members"
              c:identifier="tp_group_mixin_remove_members"
              moved-to="GroupMixin.remove_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_remove_members_with_reason"
              c:identifier="tp_group_mixin_remove_members_with_reason"
              moved-to="GroupMixin.remove_members_with_reason"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpChannelGroupChangeReason</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_client_hold"
              c:identifier="tp_handle_client_hold"
              introspectable="0"
              deprecated="This is no-op so can be safely removed."
              throws="1">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_client_release"
              c:identifier="tp_handle_client_release"
              introspectable="0"
              deprecated="This is no-op so can be safely removed."
              throws="1">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ensure" c:identifier="tp_handle_ensure" throws="1">
      <doc xml:whitespace="preserve">Return a handle for the given string, creating one if necessary. The string
is normalized, if possible.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handle corresponding to the given string, or 0 if it is invalid.</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to be passed to the normalization callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ensure_async"
              c:identifier="tp_handle_ensure_async"
              version="0.19.2"
              introspectable="0">
      <doc xml:whitespace="preserve">Asyncronously normalize an identifier and create an handle for it. This could
involve a server round-trip. This should be used instead of
tp_handle_ensure() for user provided contact identifiers, but it is not
necessary for identifiers from the server.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #TpBaseConnection using this handle repo</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to be passed to the normalization callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="5">
          <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ensure_finish"
              c:identifier="tp_handle_ensure_finish"
              version="0.19.2"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Finishes tp_handle_ensure_async()</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">non-0 #TpHandle if the operation was successful, otherwise 0.</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GAsyncResult</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_get_qdata"
              c:identifier="tp_handle_get_qdata"
              introspectable="0"
              deprecated="Since 0.19.9. It is not recommended to use this function because the associated data won&apos;t be freed until the connection disconnects.">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value>
        <doc xml:whitespace="preserve">the data associated with a given key on a given handle; %NULL if there is no associated data.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="repo" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle to get data from</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Key id of data to fetch</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_inspect"
              c:identifier="tp_handle_inspect"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the string represented by the given handle, or NULL if the handle is absent from the repository. The string is owned by the handle repository and will remain valid as long as a reference to the handle exists.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_is_valid"
              c:identifier="tp_handle_is_valid"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle is nonzero and is present in the repository, else %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository @self</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_lookup"
              c:identifier="tp_handle_lookup"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Return the handle for the given string. The string is normalized if
possible. If no handle already exists for the string, none is created.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handle corresponding to the given string, or 0 if it does not exist or is invalid</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to be passed to the normalization callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ref"
              c:identifier="tp_handle_ref"
              introspectable="0"
              deprecated="This is no-op so can be safely removed.">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.

Changed in 0.13.6: @handle is now returned; previously,
this function didn't return anything.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the same @handle</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_set_qdata"
              c:identifier="tp_handle_set_qdata"
              moved-to="HandleSet.qdata"
              introspectable="0"
              deprecated="Since 0.19.9. It is not recommended to use this function because the associated data won&apos;t be freed until the connection disconnects.">
      <doc xml:whitespace="preserve">Associates a blob of data with a given handle and a given key

If @destroy is set, then the data is freed when the handle is freed.

Since version 0.13.8, handles always last as long as the
connection, so @destroy will not be called until the connection
disconnects.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="repo" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle to set data on</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Key id to associate data with</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to associate with handle</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">A #GDestroyNotify to call to destroy the data, or NULL if not needed.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_type_is_valid"
              c:identifier="tp_handle_type_is_valid"
              throws="1">
      <doc xml:whitespace="preserve">If the given handle type is valid, return %TRUE. If not, set @error
and return %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle type is valid.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle type, valid or not, to be checked</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_type_to_string"
              c:identifier="tp_handle_type_to_string">
      <doc xml:whitespace="preserve">&lt;!----&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a human-readable string describing the handle type, e.g. "contact". For invalid handle types, returns "(no handle)" for 0 or "(invalid handle type)" for others.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle type, which need not be valid</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_unref"
              c:identifier="tp_handle_unref"
              introspectable="0"
              deprecated="This is no-op so can be safely removed.">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_are_valid"
              c:identifier="tp_handles_are_valid"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle is present in the repository, else %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">Array of TpHandle representing handles of the type stored in the repository @self</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="allow_zero" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE, zero is treated like a valid handle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_client_hold"
              c:identifier="tp_handles_client_hold"
              introspectable="0"
              deprecated="This is no-op so can be safely removed."
              throws="1">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_client_release"
              c:identifier="tp_handles_client_release"
              introspectable="0"
              deprecated="This is no-op so can be safely removed."
              throws="1">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_ref"
              c:identifier="tp_handles_ref"
              introspectable="0"
              deprecated="This is no-op so can be safely removed.">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_supported_and_valid"
              c:identifier="tp_handles_supported_and_valid"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Return %TRUE if the given handle type is supported (i.e. repos[handle_type]
is not %NULL) and the given handles are all valid in that repository.
If not, set @error and return %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle type is supported and the handles are all valid.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="repos" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of possibly null pointers to handle repositories, indexed by handle type, where a null pointer means an unsupported handle type</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle type</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing handles of the given type</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="allow_zero" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE, zero is treated like a valid handle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_unref"
              c:identifier="tp_handles_unref"
              introspectable="0"
              deprecated="This is no-op so can be safely removed.">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="iface_quark_account" c:identifier="tp_iface_quark_account">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_addressing"
              c:identifier="tp_iface_quark_account_interface_addressing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_avatar"
              c:identifier="tp_iface_quark_account_interface_avatar">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_storage"
              c:identifier="tp_iface_quark_account_interface_storage">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_manager"
              c:identifier="tp_iface_quark_account_manager">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_authentication_tls_certificate"
              c:identifier="tp_iface_quark_authentication_tls_certificate">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content"
              c:identifier="tp_iface_quark_call_content">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_interface_audio_control"
              c:identifier="tp_iface_quark_call_content_interface_audio_control">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_interface_dtmf"
              c:identifier="tp_iface_quark_call_content_interface_dtmf">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_interface_media"
              c:identifier="tp_iface_quark_call_content_interface_media">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_interface_video_control"
              c:identifier="tp_iface_quark_call_content_interface_video_control">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_media_description"
              c:identifier="tp_iface_quark_call_content_media_description">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_media_description_interface_rtcp_extended_reports"
              c:identifier="tp_iface_quark_call_content_media_description_interface_rtcp_extended_reports">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_media_description_interface_rtcp_feedback"
              c:identifier="tp_iface_quark_call_content_media_description_interface_rtcp_feedback">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_content_media_description_interface_rtp_header_extensions"
              c:identifier="tp_iface_quark_call_content_media_description_interface_rtp_header_extensions">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_stream"
              c:identifier="tp_iface_quark_call_stream">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_stream_endpoint"
              c:identifier="tp_iface_quark_call_stream_endpoint">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_call_stream_interface_media"
              c:identifier="tp_iface_quark_call_stream_interface_media">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel" c:identifier="tp_iface_quark_channel">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatch_operation"
              c:identifier="tp_iface_quark_channel_dispatch_operation">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatcher"
              c:identifier="tp_iface_quark_channel_dispatcher">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatcher_interface_operation_list"
              c:identifier="tp_iface_quark_channel_dispatcher_interface_operation_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_anonymity"
              c:identifier="tp_iface_quark_channel_interface_anonymity">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_call_state"
              c:identifier="tp_iface_quark_channel_interface_call_state">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_captcha_authentication"
              c:identifier="tp_iface_quark_channel_interface_captcha_authentication">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_chat_state"
              c:identifier="tp_iface_quark_channel_interface_chat_state">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_conference"
              c:identifier="tp_iface_quark_channel_interface_conference">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_destroyable"
              c:identifier="tp_iface_quark_channel_interface_destroyable">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_dtmf"
              c:identifier="tp_iface_quark_channel_interface_dtmf">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_file_transfer_metadata"
              c:identifier="tp_iface_quark_channel_interface_file_transfer_metadata">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_group"
              c:identifier="tp_iface_quark_channel_interface_group">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_hold"
              c:identifier="tp_iface_quark_channel_interface_hold">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_media_signalling"
              c:identifier="tp_iface_quark_channel_interface_media_signalling">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_messages"
              c:identifier="tp_iface_quark_channel_interface_messages">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_password"
              c:identifier="tp_iface_quark_channel_interface_password">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_room"
              c:identifier="tp_iface_quark_channel_interface_room">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_room_config"
              c:identifier="tp_iface_quark_channel_interface_room_config">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_sasl_authentication"
              c:identifier="tp_iface_quark_channel_interface_sasl_authentication">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_securable"
              c:identifier="tp_iface_quark_channel_interface_securable">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_service_point"
              c:identifier="tp_iface_quark_channel_interface_service_point">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_sms"
              c:identifier="tp_iface_quark_channel_interface_sms">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_subject"
              c:identifier="tp_iface_quark_channel_interface_subject">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_tube"
              c:identifier="tp_iface_quark_channel_interface_tube">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_request"
              c:identifier="tp_iface_quark_channel_request">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_call"
              c:identifier="tp_iface_quark_channel_type_call">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_contact_list"
              c:identifier="tp_iface_quark_channel_type_contact_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_contact_search"
              c:identifier="tp_iface_quark_channel_type_contact_search">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_dbus_tube"
              c:identifier="tp_iface_quark_channel_type_dbus_tube">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_file_transfer"
              c:identifier="tp_iface_quark_channel_type_file_transfer">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_room_list"
              c:identifier="tp_iface_quark_channel_type_room_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_server_authentication"
              c:identifier="tp_iface_quark_channel_type_server_authentication">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_server_tls_connection"
              c:identifier="tp_iface_quark_channel_type_server_tls_connection">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_stream_tube"
              c:identifier="tp_iface_quark_channel_type_stream_tube">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_streamed_media"
              c:identifier="tp_iface_quark_channel_type_streamed_media">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_text"
              c:identifier="tp_iface_quark_channel_type_text">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_tubes"
              c:identifier="tp_iface_quark_channel_type_tubes">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client" c:identifier="tp_iface_quark_client">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_approver"
              c:identifier="tp_iface_quark_client_approver">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_handler"
              c:identifier="tp_iface_quark_client_handler">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_interface_requests"
              c:identifier="tp_iface_quark_client_interface_requests">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_observer"
              c:identifier="tp_iface_quark_client_observer">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection"
              c:identifier="tp_iface_quark_connection">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_addressing"
              c:identifier="tp_iface_quark_connection_interface_addressing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_aliasing"
              c:identifier="tp_iface_quark_connection_interface_aliasing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_anonymity"
              c:identifier="tp_iface_quark_connection_interface_anonymity">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_avatars"
              c:identifier="tp_iface_quark_connection_interface_avatars">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_balance"
              c:identifier="tp_iface_quark_connection_interface_balance">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_capabilities"
              c:identifier="tp_iface_quark_connection_interface_capabilities">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_cellular"
              c:identifier="tp_iface_quark_connection_interface_cellular">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_client_types"
              c:identifier="tp_iface_quark_connection_interface_client_types">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_blocking"
              c:identifier="tp_iface_quark_connection_interface_contact_blocking">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_capabilities"
              c:identifier="tp_iface_quark_connection_interface_contact_capabilities">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_groups"
              c:identifier="tp_iface_quark_connection_interface_contact_groups">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_info"
              c:identifier="tp_iface_quark_connection_interface_contact_info">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_list"
              c:identifier="tp_iface_quark_connection_interface_contact_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contacts"
              c:identifier="tp_iface_quark_connection_interface_contacts">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_location"
              c:identifier="tp_iface_quark_connection_interface_location">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_mail_notification"
              c:identifier="tp_iface_quark_connection_interface_mail_notification">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_power_saving"
              c:identifier="tp_iface_quark_connection_interface_power_saving">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_presence"
              c:identifier="tp_iface_quark_connection_interface_presence">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_requests"
              c:identifier="tp_iface_quark_connection_interface_requests">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_service_point"
              c:identifier="tp_iface_quark_connection_interface_service_point">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_simple_presence"
              c:identifier="tp_iface_quark_connection_interface_simple_presence">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_manager"
              c:identifier="tp_iface_quark_connection_manager">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_daemon"
              c:identifier="tp_iface_quark_dbus_daemon">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_introspectable"
              c:identifier="tp_iface_quark_dbus_introspectable">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_peer"
              c:identifier="tp_iface_quark_dbus_peer">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_properties"
              c:identifier="tp_iface_quark_dbus_properties">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_debug" c:identifier="tp_iface_quark_debug">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_media_session_handler"
              c:identifier="tp_iface_quark_media_session_handler">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_media_stream_handler"
              c:identifier="tp_iface_quark_media_stream_handler">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_properties_interface"
              c:identifier="tp_iface_quark_properties_interface">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol"
              c:identifier="tp_iface_quark_protocol">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol_interface_addressing"
              c:identifier="tp_iface_quark_protocol_interface_addressing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol_interface_avatars"
              c:identifier="tp_iface_quark_protocol_interface_avatars">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol_interface_presence"
              c:identifier="tp_iface_quark_protocol_interface_presence">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="intset_from_array"
              c:identifier="tp_intset_from_array"
              moved-to="Intset.from_array">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A set containing the same integers as @array.</doc>
        <type name="Intset" c:type="TpIntset*"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of guint</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_managers"
              c:identifier="tp_list_connection_managers"
              version="0.7.1"
              deprecated="since 0.19.1, use tp_list_connection_managers_async()">
      <doc xml:whitespace="preserve">List the available (running or installed) connection managers. Call the
callback when done.

Since 0.7.26, this function will wait for each #TpConnectionManager
to be ready, so all connection managers passed to @callback will have
their %TP_CONNECTION_MANAGER_FEATURE_CORE feature prepared, unless an error
occurred while launching that connection manager.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">proxy for the D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="notified"
                   closure="2"
                   destroy="3">
          <doc xml:whitespace="preserve">callback to be called when listing the CMs succeeds or fails; not called if the @weak_object goes away</doc>
          <type name="ConnectionManagerListCb"
                c:type="TpConnectionManagerListCb"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied data for the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">callback to destroy the user-supplied data, called after @callback, but also if the @weak_object goes away</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">if not %NULL, will be weakly referenced; the callback will not be called, and the call will be cancelled, if the object has vanished</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_managers_async"
              c:identifier="tp_list_connection_managers_async"
              version="0.17.6">
      <doc xml:whitespace="preserve">List the available (running or installed) connection managers,
asynchronously, and wait for their %TP_CONNECTION_MANAGER_FEATURE_CORE
feature to be ready.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dbus_daemon" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a #TpDBusDaemon, or %NULL to use tp_dbus_daemon_dup()</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="2">
          <doc xml:whitespace="preserve">a callback to call with a list of CMs</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_managers_finish"
              c:identifier="tp_list_connection_managers_finish"
              version="0.17.6"
              throws="1">
      <doc xml:whitespace="preserve">Finish listing the available connection managers.

Free the list after use, for instance with
&lt;literal&gt;g_list_free_full (list, g_object_unref)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated list of references to #TpConnectionManager objects</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="ConnectionManager"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:whitespace="preserve">the result of tp_list_connection_managers_async()</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_names"
              c:identifier="tp_list_connection_names"
              version="0.7.1">
      <doc xml:whitespace="preserve">List the bus names of all the connections that currently exist, together
with the connection manager name and the protocol name for each connection.
Call the callback when done.

The bus names passed to the callback can be used to construct #TpConnection
objects for any connections that are of interest.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">proxy for the D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="notified"
                   closure="2"
                   destroy="3">
          <doc xml:whitespace="preserve">callback to be called when listing the connections succeeds or fails; not called if the D-Bus connection fails completely or if the @weak_object goes away</doc>
          <type name="ConnectionNameListCb" c:type="TpConnectionNameListCb"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied data for the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">callback to destroy the user-supplied data, called after @callback, but also if the D-Bus connection fails or if the @weak_object goes away</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">if not %NULL, will be weakly referenced; the callback will not be called if the object has vanished</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mixin_class_get_offset"
              c:identifier="tp_mixin_class_get_offset"
              introspectable="0">
      <doc xml:whitespace="preserve">If the type of @klass, or any of its ancestor types, has had an offset
attached using qdata with the given @quark, return that offset; if not,
return 0.

In older telepathy-glib versions, calling this function on an instance that
did not have the mixin was considered to be a programming error. Since
version 0.13.9, 0 is returned, without error.

This is used to implement the telepathy-glib mixin classes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the offset of the mixin class</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="klass" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to a GObjectClass-derived class structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="quark" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark that was used to store the offset with g_type_set_qdata()</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="mixin_instance_get_offset"
              c:identifier="tp_mixin_instance_get_offset"
              introspectable="0">
      <doc xml:whitespace="preserve">If the type of @instance, or any of its ancestor types, has had an offset
attached using qdata with the given @quark, return that offset. If not,
return 0.

In older telepathy-glib versions, calling this function on an instance that
did not have the mixin was considered to be a programming error. Since
version 0.13.9, 0 is returned, without error.

This is used to implement the telepathy-glib mixin classes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the offset of the mixin</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to a GObject-derived instance structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="quark" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark that was used to store the offset with g_type_set_qdata()</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="mixin_offset_cast"
              c:identifier="tp_mixin_offset_cast"
              introspectable="0">
      <doc xml:whitespace="preserve">Extend a pointer by an offset, provided the offset is not 0.
This is used to cast from an object instance to one of the telepathy-glib
mixin classes.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a pointer @offset bytes beyond @instance</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to a structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The offset of a structure member in bytes, which must not be 0</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_class_get_offset_quark"
              c:identifier="tp_presence_mixin_class_get_offset_quark"
              moved-to="PresenceMixinClass.get_offset_quark"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="presence_mixin_class_init"
              c:identifier="tp_presence_mixin_class_init"
              moved-to="PresenceMixinClass.init"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_class_init ((GObjectClass *) klass,
                              G_STRUCT_OFFSET (SomeObjectClass,
                                               presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixinClass within the class structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="status_available" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to determine if a given presence status can be set on a particular connection. Should usually be %NULL, to consider all statuses with #TpPresenceStatusSpec.self set to %TRUE to be settable.</doc>
          <type name="PresenceMixinStatusAvailableFunc"
                c:type="TpPresenceMixinStatusAvailableFunc"/>
        </parameter>
        <parameter name="get_contact_statuses" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used get the current presence status for contacts. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
          <type name="PresenceMixinGetContactStatusesFunc"
                c:type="TpPresenceMixinGetContactStatusesFunc"/>
        </parameter>
        <parameter name="set_own_status" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to commit changes to the user's own presence status to the server. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
          <type name="PresenceMixinSetOwnStatusFunc"
                c:type="TpPresenceMixinSetOwnStatusFunc"/>
        </parameter>
        <parameter name="statuses" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #TpPresenceStatusSpec structures representing all presence statuses supported by the protocol, terminated by a NULL name.</doc>
          <type name="PresenceStatusSpec"
                c:type="const TpPresenceStatusSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_emit_one_presence_update"
              c:identifier="tp_presence_mixin_emit_one_presence_update"
              moved-to="PresenceMixin.emit_one_presence_update"
              introspectable="0">
      <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for a single contact. This method is just a
convenience wrapper around #tp_presence_mixin_emit_presence_update.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A connection object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to emit the signal for</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new status to emit</doc>
          <type name="PresenceStatus" c:type="const TpPresenceStatus*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_emit_presence_update"
              c:identifier="tp_presence_mixin_emit_presence_update"
              moved-to="PresenceMixin.emit_presence_update"
              introspectable="0">
      <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for multiple contacts. For emitting
PresenceUpdate for a single contact, there is a convenience wrapper called
#tp_presence_mixin_emit_one_presence_update.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A connection object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contact_presences" transfer-ownership="none">
          <doc xml:whitespace="preserve">A mapping of contact handles to #TpPresenceStatus structures with the presence data to emit</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_finalize"
              c:identifier="tp_presence_mixin_finalize"
              moved-to="PresenceMixin.finalize"
              introspectable="0">
      <doc xml:whitespace="preserve">Free resources held by the presence mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_get_offset_quark"
              c:identifier="tp_presence_mixin_get_offset_quark"
              moved-to="PresenceMixin.get_offset_quark"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="presence_mixin_iface_init"
              c:identifier="tp_presence_mixin_iface_init"
              moved-to="PresenceMixin.iface_init"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the presence interface using
this mixin. This function should usually be called via G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfacePresenceClass in an object class</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_init"
              c:identifier="tp_presence_mixin_init"
              moved-to="PresenceMixin.init"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_init ((GObject *) self,
                        G_STRUCT_OFFSET (SomeObject, presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixin within the object structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_iface_init"
              c:identifier="tp_presence_mixin_simple_presence_iface_init"
              moved-to="PresenceMixin.simple_presence_iface_init"
              version="0.7.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the simple presence interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceSimplePresenceClass in an object class</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_init_dbus_properties"
              c:identifier="tp_presence_mixin_simple_presence_init_dbus_properties"
              moved-to="PresenceMixin.simple_presence_init_dbus_properties"
              version="0.7.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the SimplePresence interface's properties.

This automatically sets up a list of the supported properties for the
SimplePresence interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_register_with_contacts_mixin"
              c:identifier="tp_presence_mixin_simple_presence_register_with_contacts_mixin"
              moved-to="PresenceMixin.simple_presence_register_with_contacts_mixin"
              introspectable="0">
      <doc xml:whitespace="preserve">Register the SimplePresence interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance that of the implementation that uses both the Contacts mixin and this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_status_new"
              c:identifier="tp_presence_status_new"
              moved-to="PresenceStatus.new"
              introspectable="0">
      <doc xml:whitespace="preserve">Construct a presence status structure. You should free the returned
structure with #tp_presence_status_free.</doc>
      <return-value>
        <doc xml:whitespace="preserve">A pointer to the newly allocated presence status structure.</doc>
        <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
      </return-value>
      <parameters>
        <parameter name="which" transfer-ownership="none">
          <doc xml:whitespace="preserve">Index of the presence status in the provided supported presence statuses array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="optional_arguments" transfer-ownership="none">
          <doc xml:whitespace="preserve">Optional arguments for the presence statuses. Can be NULL if there are no optional arguments. The presence status object makes a copy of the hashtable, so you should free the original.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="simple_async_report_success_in_idle"
              c:identifier="tp_simple_async_report_success_in_idle"
              version="0.11.9">
      <doc xml:whitespace="preserve">Create a new #GSimpleAsyncResult with no operation result, and call
g_simple_async_result_complete_in_idle() on it.

This is like a successful version of g_simple_async_report_error_in_idle(),
suitable for asynchronous functions that (conceptually) either succeed and
return nothing, or raise an error, such as tp_proxy_prepare_async().

The corresponding finish function should not call a function that attempts
to get a result, such as g_simple_async_result_get_op_res_gpointer().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">the source object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="2">
          <doc xml:whitespace="preserve">the callback</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data for @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="source_tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source tag for the #GSimpleAsyncResult</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdiff" c:identifier="tp_strdiff" introspectable="0">
      <doc xml:whitespace="preserve">Return %TRUE if the given strings are different. Unlike #strcmp this
function will handle null pointers, treating them as distinct from any
string.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE if @left and @right are both %NULL, or if neither is %NULL and both have the same contents; %TRUE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">The first string to compare (may be NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">The second string to compare (may be NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strv_contains"
              c:identifier="tp_strv_contains"
              version="0.7.15"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if @str is an element of @strv, according to strcmp().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="strv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a NULL-terminated array of strings, or %NULL (which is treated as an empty strv)</doc>
          <type name="utf8" c:type="const gchar* const*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-NULL string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="svc_interface_get_dbus_properties_info"
              c:identifier="tp_svc_interface_get_dbus_properties_info"
              version="0.15.8"
              introspectable="0">
      <doc xml:whitespace="preserve">Retrieves the D-Bus property metadata for the given interface, if any.
This function is typically not useful outside telepathy-glib itself, but may
be useful for domain-specific variations on the theme of SetProperty. If in
doubt, you probably don't need this function.</doc>
      <return-value>
        <doc xml:whitespace="preserve">D-Bus property metadata for @g_interface, or %NULL if it has none.</doc>
        <type name="DBusPropertiesMixinIfaceInfo"
              c:type="TpDBusPropertiesMixinIfaceInfo*"/>
      </return-value>
      <parameters>
        <parameter name="g_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GType of a service interface</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="svc_interface_set_dbus_properties_info"
              c:identifier="tp_svc_interface_set_dbus_properties_info"
              version="0.7.3">
      <doc xml:whitespace="preserve">Declare that @g_interface implements the given D-Bus interface, with the
given properties. This may only be called once per GInterface, usually from
a section of its base_init function that only runs once.

This is typically only used within generated code; there is normally no
reason to call it manually.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GType of a service interface</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">an interface description</doc>
          <type name="DBusPropertiesMixinIfaceInfo"
                c:type="TpDBusPropertiesMixinIfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_action_time_from_x11"
              c:identifier="tp_user_action_time_from_x11"
              version="0.11.13">
      <doc xml:whitespace="preserve">Convert an X11 timestamp into a user action time as used in Telepathy.

This also works for the timestamps used by GDK 2, GDK 3 and Clutter 1.0;
it may or may not work with other toolkits or versions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a nonzero Telepathy user action time, or %TP_USER_ACTION_TIME_CURRENT_TIME</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="x11_time" transfer-ownership="none">
          <doc xml:whitespace="preserve">an X11 timestamp, or 0 to indicate the current time</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_action_time_should_present"
              c:identifier="tp_user_action_time_should_present"
              version="0.11.13">
      <doc xml:whitespace="preserve">Interpret a Telepathy user action time to decide whether a Handler should
attempt to gain focus. If %TRUE is returned, it would be appropriate to
call gtk_window_present_with_time() using @x11_time as input, for instance.

@x11_time is used to return a timestamp in the right format for X11,
GDK 2, GDK 3 and Clutter 1.0; it may or may not work with other
toolkits or versions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if it would be appropriate to present a window</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:whitespace="preserve">the Telepathy user action time</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="x11_time"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">a pointer to guint32 used to return an X11 timestamp, or 0 to indicate the current time; if %FALSE is returned, the value placed here is not meaningful</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_make_valid"
              c:identifier="tp_utf8_make_valid"
              version="0.13.15">
      <doc xml:whitespace="preserve">Validate that the provided string is valid UTF8. If not,
replace all invalid bytes with unicode replacement
character (U+FFFD).

This method is a verbatim copy of glib's internal
_g_utf8_make_valid&lt;!-- --&gt;() function, and will be deprecated as
soon as the glib one becomes public.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new valid UTF8 string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">string to coerce into UTF8</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_build"
              c:identifier="tp_value_array_build"
              version="0.9.2"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GValueArray for use with structs, containing the values
passed in as parameters. The values are copied or reffed as appropriate for
their type.

&lt;example&gt;
  &lt;title&gt; using tp_value_array_build&lt;/title&gt;
   &lt;programlisting&gt;
GValueArray *array = tp_value_array_build (2,
   G_TYPE_STRING, host,
   G_TYPE_UINT, port,
   G_TYPE_INVALID);
   &lt;/programlisting&gt;
&lt;/example&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly created #GValueArray, free with g_value_array_free.</doc>
        <type name="GObject.ValueArray" c:type="GValueArray*"/>
      </return-value>
      <parameters>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of elements that should be in the array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type of the first argument.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_unpack"
              c:identifier="tp_value_array_unpack"
              version="0.11.0"
              introspectable="0">
      <doc xml:whitespace="preserve">Unpacks a #GValueArray into separate variables.

The contents of the values aren't copied into the variables, and so become
invalid when @array is freed.

&lt;example&gt;
  &lt;title&gt;using tp_value_array_unpack&lt;/title&gt;
   &lt;programlisting&gt;
const gchar *host;
guint port;

tp_value_array_unpack (array, 2,
   &amp;host,
   &amp;port);
   &lt;/programlisting&gt;
&lt;/example&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:whitespace="preserve">the array to unpack</doc>
          <type name="GObject.ValueArray" c:type="GValueArray*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of elements that should be in the array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="weak_ref_new"
              c:identifier="tp_weak_ref_new"
              moved-to="WeakRef.new"
              version="0.11.3"
              introspectable="0">
      <doc xml:whitespace="preserve">Return a new weak reference wrapper for @object.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new weak-reference wrapper  Free-function: tp_weak_ref_destroy()</doc>
        <type name="WeakRef" c:type="TpWeakRef*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object to which to take a weak reference</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">optional additional data to store alongside the weak ref</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">destructor for @user_data, called when the weak ref is freed</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
